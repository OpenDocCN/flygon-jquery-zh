- en: Advanced Selectors and Traversing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In January 2009, jQuery's creator John Resig introduced a new open source JavaScript
    project called **Sizzle**. A standalone **CSS selector engine**, Sizzle was written
    to allow any JavaScript library to adopt it with little or no modification to
    its codebase. In fact, jQuery has been using Sizzle as its own selector engine
    ever since version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: Sizzle is the component within jQuery that is responsible for parsing the CSS
    selector expressions we put into the `$()` function. It determines which native
    DOM methods to use as it builds a collection of elements that we can then act
    on with other jQuery methods. The combination of Sizzle and jQuery's set of traversal
    methods makes jQuery an extremely powerful tool for finding elements on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml), *Selecting Elements*,
    we looked at each of the basic types of selector and traversal method so that
    we have a roadmap of what''s available to us in the jQuery library. In this more
    advanced chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using selectors to find and filter data in various ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing plugins that add new selectors and DOM traversal methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing our selector expressions for better performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding some of the inner workings of the Sizzle engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting and traversing revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To kick off this more in-depth look into selectors and traversing, we''ll build
    a script that will provide yet more selecting and traversing examples to inspect.
    For our sample, we''ll build an HTML document containing a list of news items.
    We''ll place those items in a table so that we can experiment with selecting rows
    and columns in several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Getting the example code
  prefs: []
  type: TYPE_NORMAL
- en: You can access the example code from the following GitHub repository: [https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
  prefs: []
  type: TYPE_NORMAL
- en: 'From this code fragment, we can see the structure of the document. The table
    has four columns, representing date, headline, author, and topic, but some table
    rows contain a subheading of a calendar year instead of those four items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_001-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Between the title and table, there are sets of links representing each of the
    news topics in the table. For our first task, we'll change the behavior of these
    links to filter the table *in place* rather than requiring navigation to different
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic table filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use the topic links to filter the table, we need to prevent their
    default linking behavior. We should also give the user some feedback about the
    currently selected topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.1
  prefs: []
  type: TYPE_NORMAL
- en: We remove the `selected` class from all the topic links when one is clicked
    on, then add the `selected` class to the new topic. The call to `.preventDefault()` prevents
    the link from being followed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to actually perform the filtering operation. As a first pass
    at this problem, we can hide every row of the table that doesn''t contain the
    text of the topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.2
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re now storing the text of the link in the constant `topic` so that we
    can compare it against the text in the table itself. First, we show all the table
    rows and then, if the topic is not All, we hide the irrelevant ones. The selector
    we''re using for this process is a little complex, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The selector starts off straightforwardly, with `#news tr` locating all of the
    rows in the table. We then filter this element set using the `:has()` custom selector.
    This selector winnows the currently selected elements down to those that contain
    the specified descendant. In this case, we're eliminating the header rows (such
    as the calendar years) from consideration, since they do not contain `<td>` cells.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have found the rows of the table where the actual content lies, we need
    to find out which ones relate to the selected topic. The `:contains()` custom
    selector matches just the elements that have the given text string somewhere inside
    them; wrapping this in a `:not()` selector then gives us all the rows that don't
    have the topic string so we can hide them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code works well enough, unless the topic happens to appear as part of
    a news headline, for instance. We also need to take care of the eventuality that
    one topic is a substring of another. To handle these cases, we will need to execute
    code for each of the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.3
  prefs: []
  type: TYPE_NORMAL
- en: This new code eliminates some of the complex selector expression text by adding
    DOM traversal methods. The `.find()` method acts just like the space previously
    separating `#news` and `tr`, but the `.not()` method does something that `:not()`
    can't do. Just as we saw with the `.filter()` method back in [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml),
    *Selecting Elements*, `.not()` can accept a callback function invoked once per
    element to be tested. If that function returns `true`, the element is excluded
    from the result set.
  prefs: []
  type: TYPE_NORMAL
- en: Selectors versus traversal methods
  prefs: []
  type: TYPE_NORMAL
- en: The choice of using a selector or its equivalent traversal method has performance
    ramifications as well. We'll explore this choice in more detail later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `.not()` method''s filtering function, we examine the child elements
    of the row to find the fourth one (which is the cell in the `Topic` column). A
    simple check of the text of this cell tells us whether the row should be hidden.
    Only the matching rows are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_002-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Striping table rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml), *Selecting Elements*,
    one of our selector examples illustrated the ways in which we can apply alternating
    row colors to a table. We saw that the `:even` and `:odd` custom selectors can
    make short work of this task, and that the CSS-native `:nth-child()` pseudo-class
    can accomplish it as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.4
  prefs: []
  type: TYPE_NORMAL
- en: This straightforward selector finds every other table row, and since each year's
    news articles reside in their own `<tbody>` element, the alternation starts over
    again with each section.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_003-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For a more complicated row-striping challenge, we can attempt to give the `alt`
    class to sets of two rows at a time. The first two rows will receive the class,
    then the next two will not, and so on. To achieve this, we will need to revisit
    **filtering functions**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.5
  prefs: []
  type: TYPE_NORMAL
- en: In our `.filter()` examples in [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml),
    *Selecting Elements*, as well as the `.not()` example in *Listing 9.3*, our filtering
    functions examined each element to determine whether to include it in the result
    set. Here, though, we don't need information about the element to determine if
    it should be included. Instead, we need to know its position within the original
    set of elements. This information is passed as an argument to the function, and
    we're calling it `i`.
  prefs: []
  type: TYPE_NORMAL
- en: The `i` parameter now holds the zero-based index of the element. With this,
    we can use the modulo operator (`%`) to determine whether we are in a pair of
    elements that should receive the `alt` class or not. Now, we have stripes of two
    rows throughout the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of loose ends to clean up, however. Because we''re no longer
    using the `:nth-child()` pseudo-class, the alternation does not begin again within
    each `<tbody>`. Also, we should be skipping table header rows for a consistent
    appearance. These goals can be achieved by making a couple of small modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.6
  prefs: []
  type: TYPE_NORMAL
- en: 'To treat each group of rows independently, we can loop over the `<tbody>` elements
    with an `.each()` call. Within the loop, we then exclude subheading rows just
    as we did in *Listing 9.3*, using `.has()`. This results in a table striped in
    sets of two rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_004-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Combining filtering and striping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our advanced table striping now works nicely, but behaves strangely when the
    topic filter is used. For the two functions to play together well, we need to
    re-stripe the table each time a filter is used. We will also need to consider
    whether rows are currently hidden when calculating where to apply the `alt` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.7
  prefs: []
  type: TYPE_NORMAL
- en: Combining the filtering code from *Listing 9.3* with our row striping routine,
    this script now defines a function called `stripe()`, which is called once when
    the document is loaded, and again each time a topic link is clicked. Within the
    function, we take care of removing the `alt` class from rows that no longer need
    it, as well as limiting the selected rows to those that are currently shown. We
    accomplish this with the `:visible` pseudo-class, which (along with its counterpart
    `:hidden`) respects whether elements are hidden for a variety of reasons, including
    having a `display` value of `none`, or `width` and `height` values of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now filter the rows of our table while preserving our row striping:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: More selector and traversal methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even after all the examples we've seen, we have not come close to exploring
    every way to find elements on a page using jQuery. There are dozens of selectors
    and DOM traversal methods available to us, and each has a particular utility we
    may need to call upon.
  prefs: []
  type: TYPE_NORMAL
- en: To find the appropriate selector or method for our needs, many resources are
    available to us. The quick reference at the end of this book lists each selector
    and method with a very brief description of each. For lengthier descriptions and
    usage examples, though, we will need a more thorough guide, such as the online
    jQuery API reference. This site lists all the selectors at [http://api.jquery.com/category/selectors/](http://api.jquery.com/category/selectors/),
    and the traversal methods at [http://api.jquery.com/category/traversing/](http://api.jquery.com/category/traversing/).
  prefs: []
  type: TYPE_NORMAL
- en: Customizing and optimizing selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many techniques that we've seen give us a tool chest that can be used to find
    any page element we want to work with. The story doesn't end here though; there
    is much to learn about performing our element-finding tasks efficiently. This
    efficiency can take the form of both code that is easier to write and read, and
    code that executes more quickly inside the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom selector plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to improve legibility is to encapsulate code snippets in reusable components.
    We do this all the time by creating functions. In [Chapter 8](091dd3f4-9663-47df-af02-817487c3038f.xhtml),
    *Developing Plugins*, we expanded this idea by crafting jQuery plugins that added
    methods to jQuery objects. This isn't the only way plugins can help us reuse code,
    though. Plugins can also provide additional **selector expressions**, such as
    the `:paused` selector that Cycle gave us in [Chapter 7](e101ee08-ea8f-40f0-966c-e00b6af852ed.xhtml),
    *Using Plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest type of selector expression to add is a **pseudo-class**. This is
    an expression that starts with a colon, such as `:checked` or `:nth-child()`.
    To illustrate the process of creating a selector expression, we'll build a pseudo-class
    called `:group()`. This new selector will encapsulate the code we used to find
    table rows to stripe back in *Listing 9.6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a selector expression to find elements, jQuery looks for instructions
    in an internal object called `expr`. The values in this object behave much like
    the filtering functions that we pass to `.filter()` or `.not()`, containing JavaScript
    code that causes each element to be contained in the result set if and only if
    the function returns `true`. We can add new expressions to this object using the
    `$.extend()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.8
  prefs: []
  type: TYPE_NORMAL
- en: This code tells jQuery that `group` is a valid string that can follow a colon
    in a selector expression, and that, when it is encountered, the given function
    should be called to determine whether the element should be included in the result
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function that is evaluated here is passed four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`element`: The DOM element under consideration. This is needed for most selectors,
    but not ours.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index`: The index of the DOM element within the result set. Unfortunately,
    this is always 0, and we cannot rely on it. The only reason it''s included here
    is because we need positional access to the matches argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matches`: An array containing the result of the regular expression that was
    used to parse this selector. Typically, `matches[3]` is the only relevant item
    in the array; in a selector of the form `:group(2)`, the `matches[3]` item contains
    `2`, the text within the parentheses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pseudo-class selectors can use some or all of the information contained in these
    three arguments to determine whether or not the element belongs in the result
    set. In this case, `element` and `matches` are all that we require. We actually
    do require the index position of every element that's passed to this function.
    Since the `index` argument cannot be relied upon, we simply use the `.index()`
    jQuery method to get the index for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new `:group` selector, we now have a flexible way to select alternating
    groups of elements. For example, we could combine the selector expression and
    `.filter()` function from *Listing 9.5* into a single selector expression: `$(''#news
    tr:group(2)'')`, or we could preserve the per-section behavior from *Listing 9.7*,
    and use `:group()` as an expression within a `.filter()` call. We can even change
    the number of rows to group by simply changing the number within the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.9
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can see that the row striping alternates by groups of three:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_006-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Selector performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In planning any web development project, we need to keep in mind the time it
    takes to create the site, the ease and speed with which we can maintain our code,
    and the performance of the site as users interact with it. Often the first two
    of these concerns are more important than the third. Especially with client-side
    scripting, developers can easily fall into the traps of **premature optimization**
    and **micro-optimization**. These pitfalls can cause us to spend countless hours
    tweaking our code to shave milliseconds from the JavaScript execution time, even
    when there was no noticeable performance lag in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: A good rule of thumb is to consider the developer's time more valuable than
    the computer's time, unless users notice slowness in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Even when performance is an issue, pinpointing the bottlenecks in our jQuery
    code can be difficult. As we hinted at earlier in this chapter, some selectors
    are generally faster than others, and moving part of a selector to a traversal
    method can help speed up the time it takes to find elements on the page. Selector
    and traversal performance is therefore often a good place to start examining our
    code to reduce the amount of delay that users may experience when interacting
    with the page.
  prefs: []
  type: TYPE_NORMAL
- en: Any decrees made about the relative speed of selectors and traversal methods
    are likely to become outdated with the release of newer, faster browsers and clever
    speed tweaks introduced in newer jQuery versions. In matters of performance, it
    is a good idea to routinely question our assumptions and to optimize code after
    performing measurements using a tool such as **jsPerf** ([http://jsperf.com](http://jsperf.com)).
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we'll examine a couple of simple guidelines for producing
    optimized jQuery selector code.
  prefs: []
  type: TYPE_NORMAL
- en: Sizzle selector implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As noted in the beginning of this chapter, when we pass a selector expression
    into the `$()` function, jQuery''s Sizzle implementation parses the expression
    and determines how to gather the elements represented by it. In its basic form,
    Sizzle applies the most efficient native **DOM method** that the browser supports
    to obtain a `nodeList`, a native array-like object of DOM elements that jQuery
    ultimately converts to a true array and adds to the `jQuery` object. The following
    is a list of DOM methods that jQuery uses internally, along with the recent browser
    versions that support them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Selects** | **Supported by** |'
  prefs: []
  type: TYPE_TB
- en: '| `.getElementById()` | The unique element with an ID that matches the given
    string. | All browsers |'
  prefs: []
  type: TYPE_TB
- en: '| `.getElementsByTagName()` | All elements with a tag name that matches the
    given string. | All browsers |'
  prefs: []
  type: TYPE_TB
- en: '| `.getElementsByClassName()` | All elements that have one of their class names
    matching the given string. | IE9+, Firefox 3+, Safari 4+, Chrome 4+, and Opera
    10+ |'
  prefs: []
  type: TYPE_TB
- en: '| `.querySelectorAll()` | All elements that match the given selector expression.
    | IE8+, Firefox 3.5+, Safari 3+, Chrome 4+, and Opera 10+ |'
  prefs: []
  type: TYPE_TB
- en: If a part of the selector expression cannot be handled by one of these methods,
    Sizzle falls back to looping through each element that has already been collected
    and testing each one against the expression part. If *no* part of the selector
    expression can be handled by a DOM method, Sizzle starts with a collection of
    *all* elements in the document, represented by `document.getElementsByTagName('*')`,
    and loops through each one in turn.
  prefs: []
  type: TYPE_NORMAL
- en: This looping and testing of each element is much more costly in terms of performance
    than any of the native DOM methods. Fortunately, the most recent versions of all
    modern desktop browsers include the native `.querySelectorAll()` method, and Sizzle
    uses it when it can't use other, even speedier, native methods--with one exception.
    When the selector expression contains a custom jQuery selector such as `:eq()`
    or `:odd` or `:even` that has no CSS counterpart, Sizzle has no choice but to
    loop and test.
  prefs: []
  type: TYPE_NORMAL
- en: Testing selector speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get an idea of the performance difference between `.querySelectorAll()`
    and the *loop-and-test* procedure, consider a document in which we wish to select
    all the `<input type="text">` elements. We could write the selector expression
    in one of two ways: `$(''input[type="text"]'')`, which uses a *CSS attribute selector*,
    or `$(''input:text'')`, which uses a *custom jQuery selector*. To test just the
    portions of the selectors we are interested in here, we will remove the `input`
    parts and compare the speeds of `$(''[type="text"]'')` and `$('':text'')`. The
    JavaScript benchmarking site [http://jsperf.com/](http://jsperf.com/) lets us
    make this comparison, yielding dramatic results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In jsPerf tests, each test case is cycled to see how many times it can be completed
    in a certain amount of time, so the higher the number, the better. When tested
    in modern browsers that support `.querySelectorAll()` (Chrome 26, Firefox 20,
    and Safari 6), the selector that can take advantage of it is remarkably faster
    than the custom jQuery selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in a browser that does not support `.querySelectorAll()`, such as
    IE 7, the two selectors perform almost identically. In this case, both selectors
    force jQuery to loop through every element on the page and test each one individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_09_08.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2
  prefs: []
  type: TYPE_NORMAL
- en: 'The performance difference between a selector that uses a native method and
    one that doesn''t is also apparent when we look at `$(''input:eq(1)'')` and `$(''input'')
    .eq(1)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_09_09.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3
  prefs: []
  type: TYPE_NORMAL
- en: While the raw number of operations per second varies greatly from browser to
    browser, all of the tested browsers show a significant performance boost when
    we move the custom `:eq()` selector out into the `.eq()` method. Using the simple
    `input` tag name as the argument for the `$()` function allows for a quick lookup,
    and the `.eq()` method then simply calls an array function to retrieve the second
    element in the jQuery collection.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule of thumb, we should prefer selectors that are part of the
    CSS specification over jQuery's custom selectors whenever possible. Still, before
    changing our selectors, it makes sense to first confirm that there is a need to
    increase performance, and then test just how much the change would boost performance
    with a benchmarking tool such as [http://jsperf.com](http://jsperf.com).
  prefs: []
  type: TYPE_NORMAL
- en: DOM traversal under the hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml), *Selecting Elements*,
    and again at the beginning of this chapter, we looked at ways of traveling from
    one set of DOM elements to another by calling DOM traversal methods. Our (far
    from exhaustive) survey of such methods included simple ways to reach neighboring
    cells, such as `.next()` and `.parent()`, and more complex ways of combining selector
    expressions, such as `.find()` and `.filter()`. By now, we should have a fairly
    strong grasp to these approaches of getting from one DOM element to another step
    by step.
  prefs: []
  type: TYPE_NORMAL
- en: Each time we take one of these steps, though, jQuery takes note of our travels,
    laying down a trail of breadcrumbs we can follow back home if needed. A couple
    of the methods we briefly touched on in that chapter, `.end()` and `.addBack()`,
    take advantage of this record keeping. To be able to get the most out of these
    methods, and in general to write efficient jQuery code, we need to understand
    a bit more about how the DOM traversal methods do their jobs.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery traversal properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, we typically construct a jQuery object instance by passing a selector
    expression to the `$()` function. Within the resulting object, there lies an array
    structure containing references to each DOM element that matched that selector.
    What we haven't seen, though, are the other properties hidden in the object. For
    example, when a DOM traversal method is called, the `.prevObject` property holds
    a reference to the jQuery object the traversal method was called upon.
  prefs: []
  type: TYPE_NORMAL
- en: The jQuery object used to expose `selector` and `context` properties as well.
    Since they don't provide any value to us, they've been removed in jQuery 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the `prevObject` property in action, we can highlight an arbitrary cell
    of our table and examine its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.10
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet will highlight the single selected cell, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_09_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that `.prevObject` is undefined since this is a newly created object.
    If we add a traversal method to the mix, though, things get more interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.11
  prefs: []
  type: TYPE_NORMAL
- en: 'This change alters which cells are highlighted, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_09_11.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, the two cells following the one we initially selected are highlighted.
    Within the jQuery object, `.prevObject` now refers to the original jQuery object
    instance before the call to `.nextAll()`.
  prefs: []
  type: TYPE_NORMAL
- en: The DOM element stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since each jQuery object instance has a `.prevObject` property pointing to the
    previous one, we have a linked list structure that implements a **stack**. Each
    traversal method call finds a new set of elements and pushes this set onto the
    stack. This is only useful if we can do something with this stack, which is where
    the `.end()` and `.addBack()` methods come into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.end()` method simply pops one element off the end of the stack, which
    is the same as fetching the value of the `.prevObject` property. We saw an example
    of this in [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml), *Selecting
    Elements*, and we will see more later in this chapter. For a more interesting
    example, though, we''ll investigate how `.addBack()` manipulates the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.12
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, the highlighted cells have changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_09_12.png)'
  prefs: []
  type: TYPE_IMG
- en: When `.addBack()` is called, jQuery looks back one step on the stack and combines
    the two element sets. In our example, this means that the highlighted cells include
    both the two cells found by the `.nextAll()` call and the original cell located
    using the selector. This new, merged element set is then pushed onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of stack manipulation is useful. To make sure these techniques work
    when they are needed, each traversal method implementation must properly update
    the stack; this means that we need to understand some of the system's inner workings
    if we want to provide traversal methods of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a DOM traversal method plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other jQuery object method, traversal methods can be added to jQuery
    by adding properties to `$.fn`. We saw in [Chapter 8](091dd3f4-9663-47df-af02-817487c3038f.xhtml),
    *Developing Plugins*, that new jQuery methods we define should operate on the
    matched set of elements and then return the jQuery object so that users can chain
    on additional methods. When we create DOM traversal methods, the process is similar,
    but the jQuery object we return needs to point to a new set of matched elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we''ll build a plugin that finds all of the table cells in the
    same column as a given cell. First we''ll look at the plugin code in its entirety,
    then examine it piece by piece to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.13
  prefs: []
  type: TYPE_NORMAL
- en: Our `.column()` method could be called on a jQuery object pointing to zero,
    one, or more DOM elements. To account for all of these possibilities, we use the
    `.each()` method to loop over the elements, adding the columns of cells one by
    one into the variable `$cells`. This `$cells` variable starts out as an empty
    jQuery object, but then is expanded with the `.add()` method to point to more
    and more DOM elements as needed.
  prefs: []
  type: TYPE_NORMAL
- en: This explains the outer loop of the function; inside the loop, we need to understand
    how `$columnCells` gets populated with the DOM elements in the table column. First,
    we get a reference to the table cell being examined. We want to allow the `.column()`
    method to be called on table cells or on elements inside table cells. The `.closest()`
    method takes care of this for us; it travels up the DOM tree until it finds an
    element matching the selector we provide. This method will prove very useful to
    us in event delegation, which we'll revisit in [Chapter 10](d150ca06-e7dc-4100-8c91-060f0272ff67.xhtml),
    *Advanced Events*.
  prefs: []
  type: TYPE_NORMAL
- en: With our table cell in hand, we find its column number using the DOM `.cellIndex`
    property. This gives us a zero-based index of the cell's column; we add `1` to
    this number since we'll be using it in a one-based context later. Then, from the
    cell, we travel up to the nearest `<table>` element, back down to the `<td>` and
    `<th>` elements, and filter these cells down to the appropriate column with an
    `:nth-child()` selector expression.
  prefs: []
  type: TYPE_NORMAL
- en: The plugin we're writing is limited to simple, non-nested tables due to the
    `.find('td, th')` call. To support nested tables, we would need to determine whether
    `<tbody>` tags are present and move up and down the DOM tree by the appropriate
    amount, which would add more complexity than is appropriate for this example.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've found all the cells in the column or columns, we need to return the
    new jQuery object. We could just return `$cells` from our method, but this wouldn't
    properly respect the DOM element stack. Instead, we pass `$cells` to the `.pushStack()`
    method and return the result. This method accepts an array of DOM elements and
    adds them to the stack, so that later calls to methods such as `.addBack()`and
    `.end()` behave correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see our plugin in action, we can react to clicks on cells and highlight
    the corresponding column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.14
  prefs: []
  type: TYPE_NORMAL
- en: 'The `active` class is added to the selected column, resulting in different
    shading when, for instance, one of the author''s names is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_09_13.png)'
  prefs: []
  type: TYPE_IMG
- en: DOM traversal performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rule of thumb about selector performance applies equally to DOM traversal
    performance: we should prioritize ease of code writing and code maintenance when
    possible, only sacrificing legibility for optimization when performance is a measurable
    problem. Again, sites such as [http://jsperf.com/](http://jsperf.com/) are helpful
    in determining the best approach given several options.'
  prefs: []
  type: TYPE_NORMAL
- en: While premature optimization should be avoided, it is good practice to minimize
    repetition of selectors and traversal methods. As these can be potentially expensive
    tasks, the fewer times we do them, the better. Two strategies for avoiding this
    repetition are **chaining** and **object caching**.
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance using chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used chaining many times now, and it has allowed us to keep our code
    concise. There can be a performance benefit to chaining as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `stripe()` function from *Listing 9.9* located the element with the ID
    `news` once instead of twice. It needed to remove the `alt` class from rows that
    no longer needed it, and to apply that class to the new set of rows. Using chaining,
    we combined these two thoughts into one and prevented this repetition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.15
  prefs: []
  type: TYPE_NORMAL
- en: In order to merge the two uses of `$('#news')`, we once again exploit the DOM
    element stack within the jQuery object. The first call to `.find()` pushes the
    table rows onto the stack, but then `.end()` pops this off the stack so that the
    next `.find()` call is operating on the `news` table once again. This kind of
    clever manipulation of the stack is a handy way of avoiding selector duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Improving performance with caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching is simply storing the result of an operation so that it can be used
    multiple times without running the operation again. In the context of selector
    and traversal performance, we can cache a jQuery object in a constant for later
    use rather than creating a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our example, we can rewrite the `stripe()` function to avoid selector
    duplication with caching rather than chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.16
  prefs: []
  type: TYPE_NORMAL
- en: The two operations are separate JavaScript statements once again, rather than
    being chained together. We're still executing the `$('#news')` selector only once,
    though, by storing the result in `$news`. This caching approach is a little more
    verbose than chaining, since we need to separately create the variable storing
    the jQuery object. Obviously, creating more constants to manage in our code is
    less desirable than chaining together function calls. But sometimes, chaining
    is simply too complex, and caching objects like this is the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Because selecting elements on the page by ID is extremely fast, neither of these
    examples will have a big performance impact, and in practice we'd choose the approach
    that seemed the most legible and maintainable. These techniques are useful tools,
    though, when performance is found to be a concern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved more deeply into jQuery's extensive capabilities
    for finding elements in a document. We've looked at some of the details of how
    the Sizzle selector engine works, and the implications this has on designing effective
    and efficient code. In addition, we have explored the ways in which we can extend
    and enhance jQuery's selectors and DOM traversal methods.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A complete list of selectors and traversal methods is available in [Appendix
    B](d9485d2d-4300-48c1-825b-1c26c9b57a66.xhtml), *Quick Reference* in this book,
    or in the official jQuery documentation at [http://api.jquery.com/](http://api.jquery.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The challenge exercises may require the use of the official jQuery documentation
    at [http://api.jquery.com/](http://api.jquery.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Modify the table row striping routine so that it gives no class to the first
    row, a class of `alt` to the second row, and a class of `alt-2` to the third row.
    Repeat this pattern for every set of three rows in a section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new selector plugin called `:containsExactly()` that selects elements
    with text content that exactly matches what is put inside the parentheses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this new `:containsExactly()`selector to rewrite the filtering code from
    *Listing 9.3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new DOM traversal plugin method called `.grandparent()` that moves
    from an element or elements to their grandparent elements in the DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Challenge**: Using [http://jsperf.com/](http://jsperf.com/), paste in the
    content of `index.html` and compare the performance of finding the closest ancestor
    table element of `<td id="release">` using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `.closest()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.parents()` method, limiting the result to the first table found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Challenge**: Using [http://jsperf.com/](http://jsperf.com/), paste in the
    content of `index.html` and compare the performance of finding the final `<td>`
    element in each row using the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `:last-child` pseudo-class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `:nth-child()` pseudo-class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.last()` method within each row (using `.each()` to loop over the rows)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `:last` pseudo-class within each row (using `.each()` to loop over the rows)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
