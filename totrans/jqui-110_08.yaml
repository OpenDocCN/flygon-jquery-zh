- en: Chapter 8. The Button and Autocomplete Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The button and autocomplete widgets are two of the more recent additions to
    the library, and were released with Version 1.8.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, it has been tricky to style the form elements consistently across
    all browsers and platforms, and to confound this, most browsers and platforms
    render the form controls uniquely. Both of the widgets covered in this chapter
    are used to improve some of the traditional form elements that are used on the
    web.
  prefs: []
  type: TYPE_NORMAL
- en: The button widget allows us to create visually appealing and highly configurable
    buttons from elements, including the `<button>`, `<input>`, and `<a>` elements
    that can be styled with themes generated using ThemeRoller. The types of the `<input>`
    element that are supported include `submit`, `radio`, and `checkbox`. Additional
    features, such as icons, button sets, and split buttons can be used to further
    enhance the underlying controls.
  prefs: []
  type: TYPE_NORMAL
- en: The autocomplete widget is attached to a standard text `<input>` and is used
    to provide a menu of contextual selections. When the visitor begins typing in
    the `<input>` element, the suggestions that match the characters entered into
    the control are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Autocomplete is fully accessible through the keyboard input, allowing the list
    of suggestions to be navigated with the arrow keys, a selection made with the
    **Enter** key, and the menu closed with the *Esc* key. When the arrow keys are
    used to navigate the list of suggestions, each suggestion will be added to the
    `<input`> element before a selection is made. If the *Esc* key is used to close
    the menu after the list has been navigated, the value of the `<input>` element
    will revert to the text entered by the visitor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard button implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using local data sources with autocomplete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configurable options of autocomplete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autocomplete events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique methods of autocomplete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using remote data sources with autocomplete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTML in the autocomplete suggestions menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the button widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The button widget is used to provide a consistent, fully-themed styling to a
    range of elements and input types. The widget can be created from several different
    elements and the resulting DOM of the widget, as well as the features that can
    be used, will vary slightly depending on which element is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A standard button widget, built from either a `<button>`, `<a>`, or `<input>`
    element with a type of `button`, `submit`, or `reset` will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the button widget](img/2209OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the standard buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the button can be built from several different elements, there are some minor
    variations of the underlying code that we can use. When creating buttons using
    the `<a>`, `<button>`, or `<span>` element will be created automatically by the
    widget and nested within the underlying element. This new `<span>` will contain
    the text label of the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a link button, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as `button1.html`. The script required to create a button, when
    using an `<a>` element as the underlying HTML can be as simple as this, which
    should be added after the last `<script>` element in the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, no special behavior is added to the resulting button; the `<a>`
    element will simply send the visitor to the new page or anchor specified in the
    `href` attribute of the anchor. In this case, the widget is simply themed consistently
    with other jQuery UI widgets that we may be using in the page or site. Markup
    is automatically added by the widget when compiled in the browser—if you use a
    DOM inspector such as Firebug, you will see the following code for `button1.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The button widget requires the following library resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jquery.ui.all.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery-2.0.3.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.core.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.widget.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.button.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating buttons using the <input> or <button> tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not limited to just using hyperlinks to create buttons; the button widget
    will also work with the `<input>` or `<button>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: It is imperative that the `type` attribute of the element is set when using
    `<input>`, so that the appearance of the button matches that of other buttons
    created from other underlying elements. For a standard, single button widget,
    the `type` attribute can be set to be `submit`, `reset`, or `button`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a button from a `<button>` element is identical to the code used in
    `button1.html` (except that we don''t add a `href` attribute to the `<button>`
    tag):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a button from an `<input>` element is also very similar except that
    we use the `value` attribute to set the text on the button instead of adding text
    content to the `<input>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Theming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like all widgets, the button has a variety of class names added to it, which
    contribute to its overall appearance. Of course, we can use the theme's class
    names in our own stylesheets to override the default appearance of the theme in
    use, if we wish to provide custom styling. ThemeRoller is still usually the best
    tool for theming buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the configurable options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The button widget has the following configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Default Value | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `disabled` | `false` | Disables the button instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `icons` | `{primary: null, secondary: null}` | Sets the icons for the button
    instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `label` | `The content of the underlying element or value attribute` | Sets
    the text of the button instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | `true` | Hides the text of the button when using an icon-only instance.
    |'
  prefs: []
  type: TYPE_TB
- en: 'In our first example, the text content of the `<a>` element was used as the
    button''s label. We can easily override this using the `label` option. Change
    the final `<script>` element in `button1.html`, so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `button2.html`. As we'd expect, when we run this file in a
    browser, we see that the `<span>` within the button widget takes the configured
    text as its label, instead of the text content of the `<a>` element.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the button icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can easily configure our buttons, so that they have up to two icons in most
    cases. Whenever an `<a>` or `<button>` element is used as the underlying element
    for the button, we can use the icons' configuration option to specify one or two
    icons.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see icons in action, change the configuration object in `button2.html`,
    so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as `button3.html`. The `icons` property accepts an object with
    up to two keys; `primary` and `secondary`. The values of these options can be
    any of the `ui-icon-` classes found in the `jquery.ui.theme.css` file. The icons
    that we set are displayed as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the button icons](img/2209OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The icons are added to the widget using additional `<span>` elements, which
    are automatically created and inserted by the widget. The `primary` icon is displayed
    to the left of the button text, while the `secondary` icon is displayed to the
    right of the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate an icon-only button that has no text label, change the configuration
    object in `button3.html` to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as `button4.html`. When we view this variation in a browser,
    we see that the button displays only two icons as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the button icons](img/2209OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Input icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As child `<span>` elements are used to display the specified icons, we cannot
    use icons when using an `<input>` element as an underlying markup for a button
    instance. We can add our own icons when using the `<input>` elements, by adding
    an extra container, the required `<span>` elements, and some custom CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `<body>` of `button4.html`, so that it contains the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as `button5.html`. We''ll also need to override some of the
    button''s styling for this example. Create a new stylesheet and add to it the
    following basic styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In older versions of Internet Explorer, the `display: inline-block` style will
    not be applied. To prevent the button taking up the full width of its container,
    we would need to float it, or set a width explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this file in the `css` directory as `buttonTheme.css`. Don''t forget to
    link to the new stylesheet from the `<head>` element of our page (after the link
    to the standard jQuery UI stylesheet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Visually our custom `<input>` based widget is complete, but practically it''s
    not quite there; the icons do not pick up the correct hover states (the reason
    for this is that the widget has applied the required class names to the underlying
    `<input>` element instead of our custom container). We can add the required behavior,
    like we have added the container and `<span>` elements, using jQuery. Change the
    code in the final `<script>` element, so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now our button should work as intended. As the previous example shows, although
    it's technically feasible to manually add the elements, the styling and the behavior
    required to add icons to a button built from an `<input>` element, in most cases,
    it will be easier and more efficient to simply use an `<a>` or `<button>` element.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Button events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Buttons that are built from `<a>` elements will work as intended with no further
    intervention from us—the browser will simply follow the `href` as we would expect—provided
    the `<button>` or `<input>` elements are within a `<form>` element and have the
    relevant type attribute set. These elements will submit the form data in the standard
    way.
  prefs: []
  type: TYPE_NORMAL
- en: If more modern AJAX submission of any `<form>` data is required, or if the button
    is to trigger some other action or process, we can use standard jQuery click event
    handlers to react to the button being clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we use the following underlying markup for the button
    widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The button widget exposes a single event, the `create` event, which is fired
    when the button instance is initially created. We could use this event to run
    additional code each time a button instance is created. For example, if we wanted
    the button to be initially hidden from view (in order to display later, after
    something else has occurred), we could use `.css()` to set the `displa`y property
    to `none`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `document.ready()` code in `button5.html`, with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `button6.html`. Within the event handler, `$(this)` refers
    to the button instance, which is hidden from view using jQuery's `css()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In order for the button to fulfill its primary purpose, that is, to do something
    when clicked, we should attach a handler to the button manually. We might want
    to collect some registration information from our visitors, for example, and use
    a button to send this information to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `<button>` in `button6.html` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the final `<script>` element to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `button7.html`. The underlying `<button>` element is now part
    of a simple `<form>`, which simply provides text inputs for the visitor, their
    name, and an e-mail address. In the script, we first initialize the button widget,
    before creating a `click` event handler. This prevents the default action of the
    browser, which would be to post the form in a traditional non-AJAX way.
  prefs: []
  type: TYPE_NORMAL
- en: We then collect the name and e-mail address entered into the fields, and post
    the data to the server asynchronously using jQuery's `post()` method. In the success
    handler for the request, we use the widget's `option` method to disable the button,
    then create and display a thanks message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re not interested in the server-side of things in this example, and we
    don''t include any validation (although the latter should be included in production
    use), but you can see how easy it is to react to the button being clicked using
    standard jQuery functionality. To see the example work, we''ll need to run the
    page through a web server, and should add a PHP file of the name specified in
    the request in the same directory as the page (which doesn''t need to contain
    anything for the purposes of this example). The following screenshot shows how
    the page should appear after the button has been clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Button events](img/2209OS_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating button sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The button widget can also be used in conjunction with radio buttons and checkboxes.
    The button component is unique in jQuery UI, in that it has not one but two widget
    methods. It has the `button()` method that we have already looked at, and it has
    the `buttonset()` method, which is used to create groups of buttons based on radio
    buttons and checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: Checkbox button sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Change the `<body>` element of `button7.html`, so that it contains the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now change the final `<script>` element, so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `button8.html`. All we need to do is call the `buttonset()`
    method on the container in which the `<label>` and `<input>` elements reside.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this file in a browser, we see that the checkboxes are hidden from
    view and the `<label>` elements are converted into buttons and grouped visually
    in a horizontal set as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checkbox button sets](img/2209OS_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although the actual checkboxes themselves are hidden from view behind the buttons,
    whenever a button is selected, the underlying checkbox will have its `checked`
    attribute updated, so we can still harvest the states from script with ease.
  prefs: []
  type: TYPE_NORMAL
- en: When a checkbox button is clicked, it will have a selected state applied to
    it by the widget, so that the visitor can easily see that it has been selected.
    As we would expect, multiple buttons may be selected at once.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of rules that we need to adhere to when creating buttons
    from checkboxes. In HTML5, it is common to nest form controls within their associated
    `<label>` elements (we did this in an earlier example), but this is not allowed
    when using the button widget. Using the `for` attribute with the `<label>` element
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: Radio button sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Buttons based on radio buttons are visually the same as those based on checkboxes;
    they differ only in their behavior. Only one button can be selected at any one
    time, whereas multiple buttons can be selected when using checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this behavior in action in `button8.html`; change the elements in
    `<body>` to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as `button9.html`. The script to initialize radio buttons is
    the same: we simply call the `buttonset()` method on the container. The only difference
    to the underlying markup, other than specifying `radio` as the type, is that these
    `<input>` elements must have the `name` attribute set.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with button methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The button widget comes with the default `destroy`, `disable`, `enable`, `widget`,
    and `option` methods common to all widgets. In addition to these methods, the
    button widget exposes one custom method, which is the `refresh` method. This method
    is used for changing the state of checkbox and radio buttons, if they are changed
    programmatically. By combining some of the previous examples, we can see this
    method in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `<body>` of `button8.html`, so that it includes two new `<button>`
    elements as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have reverted to the checkboxes, so that we can programmatically
    select or deselect them as a group. Now change the final `<script>` element, so
    that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as `button10.html`. If we preview the results in a browser,
    you can see the effect by clicking on the **Select All** button as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with button methods](img/2209OS_08_06a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we have a **Select All** button and a **Deselect All** button.
    When the **Select All** button is clicked, we set the checked attribute of the
    checkboxes to `true`. This will check the underlying (and hidden) checkboxes,
    but it won't do anything to the `<label>` elements that are styled to appear as
    buttons. To update the state of these buttons, so that they appear selected, we
    call the `refresh` method.
  prefs: []
  type: TYPE_NORMAL
- en: The **Deselect All** button sets the `checked` attribute to `false`, and then
    calls the `refresh` method again to remove the selected states from each button.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the autocomplete widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The autocomplete widget, reintroduced in jQuery UI 1.8, is back and looking
    better than ever. This is one of my favorite widgets in the library, and although
    it doesn't yet have the full set of behavior that it had in its first incarnation,
    it still provides a rich set of functionality to enhance simple text inputs that
    expect data from a predefined range.
  prefs: []
  type: TYPE_NORMAL
- en: A good example is cities; you have a standard `<input type="text">` on the page,
    which asks for the visitor's city. When they begin typing in the `<input>` element,
    all of the cities that contain the letter that the visitor has typed are displayed.
    The range of cities that the visitor can enter is finite and constrained to the
    country in which the visitor lives (this is either assumed by the developer or
    has already been selected previously by the visitor).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how this widget appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the autocomplete widget](img/2209OS_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Like other widgets, a range of elements and class names are added programmatically
    when the widget is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Working with local data sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement a basic autocomplete with a local array as its data source, create
    the following code in a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'All we need on the page is a standard `<input>` element of the `text` type.
    The initialization required for autocomplete is slightly larger than that required
    for other components; add the following `<script>` element, after the autocomplete
    source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `autocomplete1.html`. In our configuration object for the
    autocomplete, we use the `source` option to specify a local array of strings.
    The `source` option is mandatory and must be defined. The object is then passed
    to the `autocomplete` method, which is called on the city `<input>` that the autocomplete
    is to be associated with.
  prefs: []
  type: TYPE_NORMAL
- en: When we run this file in a browser, we should find that as we begin to type
    into the `<input>` element, a list of the cities defined in our source array that
    contain the letter(s) that we have typed is displayed in a drop-down menu attached
    to the `<input>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The autocomplete widget requires the following files in order to function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jquery.ui.all.css`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery-2.0.3.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.core.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.widget.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.position.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.menu.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.autocomplete.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an array of objects as the data source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to providing an array of strings, we can also supply an array of
    objects as the data source, which gives us more flexibility over the text added
    to the `<input>` when a suggestion from the menu is selected. Change the configuration
    object in `autocomplete1.html`, so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as `autocomplete2.html`. Each item in the array that we are
    using as the data source is now an object, instead of a simple string. Each object
    has two keys: `value` and `label`. The value of the `value` key is the text that
    is added to the `<input>` element when a suggestion is selected from the list.
    The value of `label` is what is displayed in the suggestion list. Other keys,
    which store custom data can also be used.'
  prefs: []
  type: TYPE_NORMAL
- en: If each object in the array contains only a single property, the property will
    be used as both the `value` and `label` key. In this case, we might as well use
    an array of strings instead of an array of objects, but it is worth noting the
    alternative format of the local data.
  prefs: []
  type: TYPE_NORMAL
- en: Configurable autocomplete options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following options can be set in order to modify the behavior of the widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Default Value | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `appendTo` | `"body"` | Specifies which element to append the widget to.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `autofocus` | `false` | Focuses the first suggestion in the list when displaying
    the list of suggestions. |'
  prefs: []
  type: TYPE_TB
- en: '| `delay` | `300` | Specifies the number of milliseconds the widget should
    wait before displaying the list of suggestions, after the visitor has started
    typing in the `<input>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `disabled` | `false` | Disables the widget. |'
  prefs: []
  type: TYPE_TB
- en: '| `minLength` | `1` | Specifies the number of characters the visitor needs
    to enter in the `<input>` before the list of suggestions is displayed. Can be
    set to `0` to make the widget display all suggestions in the menu. |'
  prefs: []
  type: TYPE_TB
- en: '| `position` | `{ my: "left top", at: "left bottom", collision: "none" }` |
    Specifies how the list of suggestions should be positioned relative to the `<input>`
    element. This option is used in the exact same way, and accepts the same values
    as the position utility that we looked at earlier in the book. |'
  prefs: []
  type: TYPE_TB
- en: '| `source` | `Array, String or Function` | Specifies the data source used to
    fill the list of suggestions. This option is mandatory and must be configured.
    It accepts an array, string, or function as its value. |'
  prefs: []
  type: TYPE_TB
- en: Configuring minimum length
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `minLength` option allows us to specify the minimum number of characters
    that need to be typed into the associated `<input>` element before the list of
    suggestions is displayed. By default, the suggestions that are displayed by the
    widget only contain the letters typed into the `<input>` element, rather than
    just those starting with the entered letters, which can result in many more suggestions
    being displayed than is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `minLength` option to a number higher than the default value of
    `1` can help narrow the list of suggestions, which may be much more important
    when dealing with large remote data sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the configuration object that we used in `autocomplete1.html` (we''ll
    revert to using an array of strings as the data source for the time being), so
    that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `autocomplete3.html`. When we run this file in a browser,
    we should find that we need to type two characters into the `<input>`, and only
    cities that contain the characters in consecutive order are displayed, which vastly
    reduces the number of suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: Although the benefits are not obvious in this basic example, this can greatly
    reduce the data returned by a remote data source.
  prefs: []
  type: TYPE_NORMAL
- en: Appending the suggestion list to an alternative element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the suggestion list is appended to the `<body>` of the page, when
    using their autocomplete widget. We can change this, and specify that the list
    should be added to another element on the page. The autocomplete widget then uses
    the `position` utility to position the list, so that it appears to be attached
    to the `<input>` element it is associated with. We can change this and specify
    that the list should be added to another element on the page, by using the `appendTo`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap the underlying `<label>` and `<input>` in a container `<div>` in `autocomplete3.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change the configuration object in the final `<script>` element to the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `autocomplete4.html`. Usually, the suggestion list is added
    right at the bottom of the `<body>` element of the code. The `appendTo` option
    accepts a jQuery selector or an actual DOM element as its value.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we see that the list is appended to our `<div>` container instead
    of the `<body>` element, which we can verify using Firebug, or another DOM explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Working with autocomplete events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The autocomplete widget exposes a range of unique events that allow us to react
    programmatically to the widget being interacted with. These events are listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event | Fired when... |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `change` | A suggestion from the list is selected. This event is fired once
    the list has closed and the `<input>` has lost focus. |'
  prefs: []
  type: TYPE_TB
- en: '| `close` | The suggestion list is closed. |'
  prefs: []
  type: TYPE_TB
- en: '| `create` | An instance of the widget is created. |'
  prefs: []
  type: TYPE_TB
- en: '| `focus` | The keyboard is used to focus a suggestion in the list. |'
  prefs: []
  type: TYPE_TB
- en: '| `open` | The suggestion menu is displayed. |'
  prefs: []
  type: TYPE_TB
- en: '| `search` | The request for the suggestions is about to be made. |'
  prefs: []
  type: TYPE_TB
- en: '| `select` | A suggestion from the list is selected. |'
  prefs: []
  type: TYPE_TB
- en: 'The `select` event is useful when we are working with an array of objects as
    the data source and have additional data other than the `label` and `value` properties
    that we used earlier. For the next example, remove the `<div>` container that
    we used in the last example and then change the configuration object, so that
    it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `autocomplete5.html`. We've added an extra property to each
    object in our array data source—the population of each city. We use the `select`
    event to obtain the label and our extra property, and write them to the page whenever
    a city is selected.
  prefs: []
  type: TYPE_NORMAL
- en: The event handler that we pass to the `select` event accepts the `event` object
    and the object from the data source that was selected. The `.length` test is used
    to determine if the `pop` element exists on the page. If it does, we simply replace
    the text within it, with the updated statement. If not, we create a new `<p>`
    element, with an `id` of `pop`, and insert this immediately after the `city` input
    field. We can access any property defined within our object in the standard way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a city has been selected, the page should appear as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with autocomplete events](img/2209OS_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The autocomplete methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the standard methods that all widgets share, the autocomplete
    gives us two unique methods that allow us to initiate certain actions. The unique
    methods are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `close` | Close the suggestion menu. |'
  prefs: []
  type: TYPE_TB
- en: '| `search` | Request the list of suggestions from the data source specifying
    the search term as an optional argument |'
  prefs: []
  type: TYPE_TB
- en: 'The `close` method is extremely easy to use, we simply call the `autocomplete`
    widget method and specify `close` as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the suggestions menu to be closed, and the `close` event to
    be triggered. A possible use for the close event handler is to alert the user
    if there is a problem with the entry they have selected; if it doesn't match an
    entry in a predefined list, then this can be flagged to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The `search` method is slightly more complex, in that it can accept an additional
    argument, although this is not mandatory. If the search method is called without
    passing an argument (which is likely to be the default behavior), the value of
    the associated `<input>` element is used as the search term. Alternatively, the
    term can be provided to the method as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: Working with remote data sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this example, we've worked with a rather small local array of data.
    The autocomplete widget really comes into its own when working with remote data
    sources, which is the recommended way of using the widget when the data source
    is large.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving content based on input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the next example, we''ll use a web service to retrieve the list of countries
    instead of using our local array. Change the `<input>` element in `autocomplete5.html`,
    so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change the final `<script>` element, so that the configuration object
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `autocomplete6.html`. We changed the `<input>` element in
    this example, as we are requesting the visitor's country instead of a city.
  prefs: []
  type: TYPE_NORMAL
- en: We have specified a string as the value of the source configuration object in
    this example. When a string is supplied to this option, the string should contain
    a URL that points to a remote resource. The widget assumes that the resource will
    output JSON data, and it assumes that the JSON data will be in the format that
    we saw earlier when using an array of objects as the source.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when using a simple string as the value of the `source` option, the
    data that is returned should be an array of objects, where each object contains
    at least a key called `label`. The data can be in JSON or JSONP format for cross-domain
    requests. The widget will automatically add the query string `term=`, followed
    by whatever was typed into the `<input>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, I have specified a URL of my own website. The resource at
    this URL will output the data in the correct format, so you can run this example
    from your desktop computer (without even needing a web server) and see the correct
    behavior as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving content based on input](img/2209OS_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One important point that I should make is about the PHP file that I have used.
    It will only return entries from the database that start with the letter(s) typed
    into the `<input>` element, and do not contain the letters as is the default for
    the widget. I wanted to clarify that this is a change that I implemented at the
    server level, and not behavior exhibited by the widget.
  prefs: []
  type: TYPE_NORMAL
- en: So, using a string as the value of the `source` option is useful and convenient
    when we have a data source that outputs data in the exact format we require, which
    is usually when we are in control of the web service that returns the data, as
    well as the data itself. This may not be the case if we are trying to extract
    data from a public web service over which we have no control. In these situations,
    we will need to use a function as the value of the `source` option and parse out
    the data manually.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a function as a source option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Passing a function to the `source` option, instead of a local array or a string,
    is the most powerful way of working with the widget. In this scenario, we have
    complete control over the request and how the data is processed before being passed
    to the widget to display in the suggestion menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll use a different PHP file that returns different data
    which is not in the format that autocomplete expects. We''ll use the function
    to request and process the data before passing it to the widget. The context of
    the example will be the frontend for a messaging system similar to Facebook''s,
    in which the autocomplete suggests possible message recipients, but can also be
    removed after they have been selected and added to the `<input>` element. The
    page we will end up with will appear as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing a function as a source option](img/2209OS_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To start with, change the `<body>` of `autocomplete6.html`, so that it contains
    the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change the final `<script>` element, so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `autocomplete7.html`. On the page, we've got some basic markup
    for a form and the necessary elements to recreate the Facebook-style message dialog.
    To test the effect, try entering Admiral Ozzel, Fode, or Han Solo into the textbox,
    then selecting their name when the autocomplete displays their entry.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The autocomplete parameter will only display certain names; if you would like
    to see possible options, then I would recommend browsing to [http://danwellman.co.uk/contacts.php](http://danwellman.co.uk/contacts.php).
  prefs: []
  type: TYPE_NORMAL
- en: We use a `<div>` element that is styled to look just like an `<input>` element,
    with a totally unstyled actual `<input>` within this.
  prefs: []
  type: TYPE_NORMAL
- en: The actual `<input>` is needed, so that the visitor can type into it and so
    that it can be associated with the autocomplete. We use the `<div>` element because
    we can't insert the `<span>` elements that will make up each contact into the
    `<input>` element. We also have a hidden `<input>` element, which will be used
    to store the actual e-mail addresses.
  prefs: []
  type: TYPE_NORMAL
- en: In the script, we use the `getData` function as the value of our `source` option;
    this is called every time the text in the `<input>` field is updated. We first
    make a JSON request to the PHP file containing the data and then iterate over
    each item in the JSON object returned by the request.
  prefs: []
  type: TYPE_NORMAL
- en: Each newly created object is added to the `suggestions` array, and once each
    item in the returned data has been processed, the `suggestions` array is passed
    to the `resp` callback function, which is passed to the `source` function as the
    second argument.
  prefs: []
  type: TYPE_NORMAL
- en: We then define the `selectEmail` handler for the autocomplete's `select` event;
    this function is automatically passed to two arguments, which are the `event`
    object and a `ui` object containing the suggestion that was selected. We use this
    function to create a `<span>` element to format and hold the text and an anchor
    element that can be used to remove the recipient. The formatted `<span>` is then
    inserted directly before the camouflaged `<input>` element.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we added a click handler for the `#friends` field, so that this gains
    focus when anyone clicks inside it. A click handler has also been added to the
    `#to` field, so that if you click inside it, it will automatically remove the
    contents of the previous entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need a stylesheet to go with this example; add the following CSS
    to a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as `autocompleteTheme.css` in the `css` folder, and link to
    the new file from the `<head>` of our new page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When we run the page in a browser, we should find that we can type into the
    `<input>` element, select a name from the suggestions menu, and get a nicely formatted
    and styled name added to the fake input.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying HTML in the list of suggestions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the autocomplete widget will only display plain text for each suggestion
    in the list. Of course, this plain text is within HTML elements created by the
    widget, but nevertheless, if we try to use HTML within our data source, then it
    will be stripped out and ignored. However, Scott González, the current project
    leader for jQuery UI, has written an extension that allows us to use HTML for
    each suggestion in the list instead of plain text, if the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: This could be handy if we wanted to highlight to the visitor the parts of the
    suggestion that matched with what they had typed in the `<input>` element. We
    will need the extension for this example, which can be found at [https://github.com/scottgonzalez/jquery-ui-extensions/blob/master/src/autocomplete/jquery.ui.autocomplete.html.js](https://github.com/scottgonzalez/jquery-ui-extensions/blob/master/src/autocomplete/jquery.ui.autocomplete.html.js).
  prefs: []
  type: TYPE_NORMAL
- en: 'The file can be saved in our local `js` directory and a reference to it should
    be included on the page, after the source file for the autocomplete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we make a start on our code, let''s take a look at how it will appear,
    when previewed in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying HTML in the list of suggestions](img/2209OS_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our next example, we're going to make use of Scott's plugin with the autocomplete
    widget, to allow a user to search for some city names. If there is a match, each
    letter in the selection drop-down will begin to change color, if the letter matches
    the characters entered in the textbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the final `<script>` element in `autocomplete5.html`, so that it appears
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as `autocomplete8.html`. We also need to add a styling rule
    to our code; add this to the `<head>` of your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Although this appears as a short example, there are some key points here to
    note; let's explore the code we've used in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we've gone back to using a local array of objects, called `cityList`.
    Both the `value` and `label` properties in each object hold the same data to begin
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our configuration object, we specify a new `html` option, which is used
    in conjunction with the HTML extension. We set the value of this option to `true`
    as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve used a function as the value of the `source` option in this example.
    Within the function, we first create a new empty array and define a new regular
    expression object. This will case-insensitively match whatever is typed into the
    `<input>`, at the start of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We then iterate over each object in our data array and test whether our regular
    expression matches any of the `label` values in the objects in our array. If any
    items do match, we create a new object and give it `value` and `label` properties.
    The `value` property (which is added to the `<input>` element when a suggestion
    is selected) is simply the corresponding value from our data array, and the `label`
    (what is displayed in the suggestion menu) is a new string that contains a `<span>`
    element wrapping the text entered into the `<input>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we call the `resp` callback, passing in the newly constructed suggestions
    array. We should always ensure that this callback is called, as this is required
    by the widget. It doesn't matter if the suggestions array is empty, the important
    thing is that the callback is called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So now, each item in the suggestions menu will have a `<span>` element, wrapping
    the text that was typed into the `<input>` element. We can use it to style this
    text slightly differently, such as with the green text `<style>` that we have
    added to our example.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered two widgets in this chapter; both of them are relatively new to the
    library and both work with `<form>` elements of some description. The button widget
    can be used to turn `<a>`, `<button>`, and `<input>` (of the `button`, `submit`,
    or `reset` type) into attractively and consistently styled-rich widgets.
  prefs: []
  type: TYPE_NORMAL
- en: The autocomplete widget is attached to an `<input>` element of the `text` type
    and is used to show a list of suggestions when the visitor begins typing into
    the `<input>` element. The widget is preconfigured to work with a local array
    of data or a URL that outputs data in the expected format. It can also be configured
    to work with data that is not in the expected format. We must first process the
    data being displayed before passing it to the widget, making this an extremely
    versatile and powerful widget.
  prefs: []
  type: TYPE_NORMAL
- en: We're almost at the end of the section covering the visible widgets, before
    focusing on the interaction helpers available with jQuery UI; let's take a look
    at the two newest additions to the library over the next couple of chapters, beginning
    with the menu widget.
  prefs: []
  type: TYPE_NORMAL
