- en: Chapter 8. The Button and Autocomplete Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The button and autocomplete widgets are two of the more recent additions to
    the library, and were released with Version 1.8.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, it has been tricky to style the form elements consistently across
    all browsers and platforms, and to confound this, most browsers and platforms
    render the form controls uniquely. Both of the widgets covered in this chapter
    are used to improve some of the traditional form elements that are used on the
    web.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The button widget allows us to create visually appealing and highly configurable
    buttons from elements, including the `<button>`, `<input>`, and `<a>` elements
    that can be styled with themes generated using ThemeRoller. The types of the `<input>`
    element that are supported include `submit`, `radio`, and `checkbox`. Additional
    features, such as icons, button sets, and split buttons can be used to further
    enhance the underlying controls.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The autocomplete widget is attached to a standard text `<input>` and is used
    to provide a menu of contextual selections. When the visitor begins typing in
    the `<input>` element, the suggestions that match the characters entered into
    the control are displayed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Autocomplete is fully accessible through the keyboard input, allowing the list
    of suggestions to be navigated with the arrow keys, a selection made with the
    **Enter** key, and the menu closed with the *Esc* key. When the arrow keys are
    used to navigate the list of suggestions, each suggestion will be added to the
    `<input`> element before a selection is made. If the *Esc* key is used to close
    the menu after the list has been navigated, the value of the `<input>` element
    will revert to the text entered by the visitor.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Standard button implementations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurable options
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding icons
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button events
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button sets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using local data sources with autocomplete
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configurable options of autocomplete
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autocomplete events
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique methods of autocomplete
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using remote data sources with autocomplete
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTML in the autocomplete suggestions menu
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the button widget
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The button widget is used to provide a consistent, fully-themed styling to a
    range of elements and input types. The widget can be created from several different
    elements and the resulting DOM of the widget, as well as the features that can
    be used, will vary slightly depending on which element is used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'A standard button widget, built from either a `<button>`, `<a>`, or `<input>`
    element with a type of `button`, `submit`, or `reset` will appear as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the button widget](img/2209OS_08_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Implementing the standard buttons
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the button can be built from several different elements, there are some minor
    variations of the underlying code that we can use. When creating buttons using
    the `<a>`, `<button>`, or `<span>` element will be created automatically by the
    widget and nested within the underlying element. This new `<span>` will contain
    the text label of the button.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a link button, use the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save this file as `button1.html`. The script required to create a button, when
    using an `<a>` element as the underlying HTML can be as simple as this, which
    should be added after the last `<script>` element in the previous code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this case, no special behavior is added to the resulting button; the `<a>`
    element will simply send the visitor to the new page or anchor specified in the
    `href` attribute of the anchor. In this case, the widget is simply themed consistently
    with other jQuery UI widgets that we may be using in the page or site. Markup
    is automatically added by the widget when compiled in the browser—if you use a
    DOM inspector such as Firebug, you will see the following code for `button1.html`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The button widget requires the following library resources:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '`jquery.ui.all.css`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery-2.0.3.js`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.core.js`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.widget.js`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.button.js`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating buttons using the <input> or <button> tags
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are not limited to just using hyperlinks to create buttons; the button widget
    will also work with the `<input>` or `<button>` tags.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: It is imperative that the `type` attribute of the element is set when using
    `<input>`, so that the appearance of the button matches that of other buttons
    created from other underlying elements. For a standard, single button widget,
    the `type` attribute can be set to be `submit`, `reset`, or `button`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a button from a `<button>` element is identical to the code used in
    `button1.html` (except that we don''t add a `href` attribute to the `<button>`
    tag):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Creating a button from an `<input>` element is also very similar except that
    we use the `value` attribute to set the text on the button instead of adding text
    content to the `<input>` tag:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Theming
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like all widgets, the button has a variety of class names added to it, which
    contribute to its overall appearance. Of course, we can use the theme's class
    names in our own stylesheets to override the default appearance of the theme in
    use, if we wish to provide custom styling. ThemeRoller is still usually the best
    tool for theming buttons.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the configurable options
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The button widget has the following configuration options:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Default Value | Usage |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| `disabled` | `false` | Disables the button instance. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| `icons` | `{primary: null, secondary: null}` | Sets the icons for the button
    instance. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| `label` | `The content of the underlying element or value attribute` | Sets
    the text of the button instance. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| `text` | `true` | Hides the text of the button when using an icon-only instance.
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: 'In our first example, the text content of the `<a>` element was used as the
    button''s label. We can easily override this using the `label` option. Change
    the final `<script>` element in `button1.html`, so that it appears as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save this file as `button2.html`. As we'd expect, when we run this file in a
    browser, we see that the `<span>` within the button widget takes the configured
    text as its label, instead of the text content of the `<a>` element.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Adding the button icons
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can easily configure our buttons, so that they have up to two icons in most
    cases. Whenever an `<a>` or `<button>` element is used as the underlying element
    for the button, we can use the icons' configuration option to specify one or two
    icons.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'To see icons in action, change the configuration object in `button2.html`,
    so that it appears as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save this file as `button3.html`. The `icons` property accepts an object with
    up to two keys; `primary` and `secondary`. The values of these options can be
    any of the `ui-icon-` classes found in the `jquery.ui.theme.css` file. The icons
    that we set are displayed as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the button icons](img/2209OS_08_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: The icons are added to the widget using additional `<span>` elements, which
    are automatically created and inserted by the widget. The `primary` icon is displayed
    to the left of the button text, while the `secondary` icon is displayed to the
    right of the text.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate an icon-only button that has no text label, change the configuration
    object in `button3.html` to the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save this file as `button4.html`. When we view this variation in a browser,
    we see that the button displays only two icons as shown in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the button icons](img/2209OS_08_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: Input icons
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As child `<span>` elements are used to display the specified icons, we cannot
    use icons when using an `<input>` element as an underlying markup for a button
    instance. We can add our own icons when using the `<input>` elements, by adding
    an extra container, the required `<span>` elements, and some custom CSS.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `<body>` of `button4.html`, so that it contains the following elements:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save this file as `button5.html`. We''ll also need to override some of the
    button''s styling for this example. Create a new stylesheet and add to it the
    following basic styles:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In older versions of Internet Explorer, the `display: inline-block` style will
    not be applied. To prevent the button taking up the full width of its container,
    we would need to float it, or set a width explicitly.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this file in the `css` directory as `buttonTheme.css`. Don''t forget to
    link to the new stylesheet from the `<head>` element of our page (after the link
    to the standard jQuery UI stylesheet):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Visually our custom `<input>` based widget is complete, but practically it''s
    not quite there; the icons do not pick up the correct hover states (the reason
    for this is that the widget has applied the required class names to the underlying
    `<input>` element instead of our custom container). We can add the required behavior,
    like we have added the container and `<span>` elements, using jQuery. Change the
    code in the final `<script>` element, so that it appears as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now our button should work as intended. As the previous example shows, although
    it's technically feasible to manually add the elements, the styling and the behavior
    required to add icons to a button built from an `<input>` element, in most cases,
    it will be easier and more efficient to simply use an `<a>` or `<button>` element.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Button events
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Buttons that are built from `<a>` elements will work as intended with no further
    intervention from us—the browser will simply follow the `href` as we would expect—provided
    the `<button>` or `<input>` elements are within a `<form>` element and have the
    relevant type attribute set. These elements will submit the form data in the standard
    way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: If more modern AJAX submission of any `<form>` data is required, or if the button
    is to trigger some other action or process, we can use standard jQuery click event
    handlers to react to the button being clicked.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we use the following underlying markup for the button
    widget:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The button widget exposes a single event, the `create` event, which is fired
    when the button instance is initially created. We could use this event to run
    additional code each time a button instance is created. For example, if we wanted
    the button to be initially hidden from view (in order to display later, after
    something else has occurred), we could use `.css()` to set the `displa`y property
    to `none`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `document.ready()` code in `button5.html`, with the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Save this file as `button6.html`. Within the event handler, `$(this)` refers
    to the button instance, which is hidden from view using jQuery's `css()` method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In order for the button to fulfill its primary purpose, that is, to do something
    when clicked, we should attach a handler to the button manually. We might want
    to collect some registration information from our visitors, for example, and use
    a button to send this information to the server.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `<button>` in `button6.html` with the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Change the final `<script>` element to the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save this file as `button7.html`. The underlying `<button>` element is now part
    of a simple `<form>`, which simply provides text inputs for the visitor, their
    name, and an e-mail address. In the script, we first initialize the button widget,
    before creating a `click` event handler. This prevents the default action of the
    browser, which would be to post the form in a traditional non-AJAX way.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: We then collect the name and e-mail address entered into the fields, and post
    the data to the server asynchronously using jQuery's `post()` method. In the success
    handler for the request, we use the widget's `option` method to disable the button,
    then create and display a thanks message.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re not interested in the server-side of things in this example, and we
    don''t include any validation (although the latter should be included in production
    use), but you can see how easy it is to react to the button being clicked using
    standard jQuery functionality. To see the example work, we''ll need to run the
    page through a web server, and should add a PHP file of the name specified in
    the request in the same directory as the page (which doesn''t need to contain
    anything for the purposes of this example). The following screenshot shows how
    the page should appear after the button has been clicked:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Button events](img/2209OS_08_04.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: Creating button sets
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The button widget can also be used in conjunction with radio buttons and checkboxes.
    The button component is unique in jQuery UI, in that it has not one but two widget
    methods. It has the `button()` method that we have already looked at, and it has
    the `buttonset()` method, which is used to create groups of buttons based on radio
    buttons and checkboxes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Checkbox button sets
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Change the `<body>` element of `button7.html`, so that it contains the following
    code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now change the final `<script>` element, so that it appears as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Save this file as `button8.html`. All we need to do is call the `buttonset()`
    method on the container in which the `<label>` and `<input>` elements reside.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this file in a browser, we see that the checkboxes are hidden from
    view and the `<label>` elements are converted into buttons and grouped visually
    in a horizontal set as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Checkbox button sets](img/2209OS_08_05.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: Although the actual checkboxes themselves are hidden from view behind the buttons,
    whenever a button is selected, the underlying checkbox will have its `checked`
    attribute updated, so we can still harvest the states from script with ease.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: When a checkbox button is clicked, it will have a selected state applied to
    it by the widget, so that the visitor can easily see that it has been selected.
    As we would expect, multiple buttons may be selected at once.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of rules that we need to adhere to when creating buttons
    from checkboxes. In HTML5, it is common to nest form controls within their associated
    `<label>` elements (we did this in an earlier example), but this is not allowed
    when using the button widget. Using the `for` attribute with the `<label>` element
    is required.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Radio button sets
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Buttons based on radio buttons are visually the same as those based on checkboxes;
    they differ only in their behavior. Only one button can be selected at any one
    time, whereas multiple buttons can be selected when using checkboxes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this behavior in action in `button8.html`; change the elements in
    `<body>` to the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Save this file as `button9.html`. The script to initialize radio buttons is
    the same: we simply call the `buttonset()` method on the container. The only difference
    to the underlying markup, other than specifying `radio` as the type, is that these
    `<input>` elements must have the `name` attribute set.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Working with button methods
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The button widget comes with the default `destroy`, `disable`, `enable`, `widget`,
    and `option` methods common to all widgets. In addition to these methods, the
    button widget exposes one custom method, which is the `refresh` method. This method
    is used for changing the state of checkbox and radio buttons, if they are changed
    programmatically. By combining some of the previous examples, we can see this
    method in action.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `<body>` of `button8.html`, so that it includes two new `<button>`
    elements as shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, we have reverted to the checkboxes, so that we can programmatically
    select or deselect them as a group. Now change the final `<script>` element, so
    that it appears as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Save this file as `button10.html`. If we preview the results in a browser,
    you can see the effect by clicking on the **Select All** button as shown in the
    following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with button methods](img/2209OS_08_06a.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: In this example, we have a **Select All** button and a **Deselect All** button.
    When the **Select All** button is clicked, we set the checked attribute of the
    checkboxes to `true`. This will check the underlying (and hidden) checkboxes,
    but it won't do anything to the `<label>` elements that are styled to appear as
    buttons. To update the state of these buttons, so that they appear selected, we
    call the `refresh` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The **Deselect All** button sets the `checked` attribute to `false`, and then
    calls the `refresh` method again to remove the selected states from each button.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the autocomplete widget
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The autocomplete widget, reintroduced in jQuery UI 1.8, is back and looking
    better than ever. This is one of my favorite widgets in the library, and although
    it doesn't yet have the full set of behavior that it had in its first incarnation,
    it still provides a rich set of functionality to enhance simple text inputs that
    expect data from a predefined range.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: A good example is cities; you have a standard `<input type="text">` on the page,
    which asks for the visitor's city. When they begin typing in the `<input>` element,
    all of the cities that contain the letter that the visitor has typed are displayed.
    The range of cities that the visitor can enter is finite and constrained to the
    country in which the visitor lives (this is either assumed by the developer or
    has already been selected previously by the visitor).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how this widget appears:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the autocomplete widget](img/2209OS_08_06.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Like other widgets, a range of elements and class names are added programmatically
    when the widget is initialized.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Working with local data sources
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement a basic autocomplete with a local array as its data source, create
    the following code in a new file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'All we need on the page is a standard `<input>` element of the `text` type.
    The initialization required for autocomplete is slightly larger than that required
    for other components; add the following `<script>` element, after the autocomplete
    source file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Save this file as `autocomplete1.html`. In our configuration object for the
    autocomplete, we use the `source` option to specify a local array of strings.
    The `source` option is mandatory and must be defined. The object is then passed
    to the `autocomplete` method, which is called on the city `<input>` that the autocomplete
    is to be associated with.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: When we run this file in a browser, we should find that as we begin to type
    into the `<input>` element, a list of the cities defined in our source array that
    contain the letter(s) that we have typed is displayed in a drop-down menu attached
    to the `<input>`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'The autocomplete widget requires the following files in order to function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '`jquery.ui.all.css`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery-2.0.3.js`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.core.js`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.widget.js`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.position.js`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.menu.js`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.autocomplete.js`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an array of objects as the data source
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to providing an array of strings, we can also supply an array of
    objects as the data source, which gives us more flexibility over the text added
    to the `<input>` when a suggestion from the menu is selected. Change the configuration
    object in `autocomplete1.html`, so that it appears as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Save this file as `autocomplete2.html`. Each item in the array that we are
    using as the data source is now an object, instead of a simple string. Each object
    has two keys: `value` and `label`. The value of the `value` key is the text that
    is added to the `<input>` element when a suggestion is selected from the list.
    The value of `label` is what is displayed in the suggestion list. Other keys,
    which store custom data can also be used.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: If each object in the array contains only a single property, the property will
    be used as both the `value` and `label` key. In this case, we might as well use
    an array of strings instead of an array of objects, but it is worth noting the
    alternative format of the local data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Configurable autocomplete options
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following options can be set in order to modify the behavior of the widget:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Default Value | Usage |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| `appendTo` | `"body"` | Specifies which element to append the widget to.
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| `autofocus` | `false` | Focuses the first suggestion in the list when displaying
    the list of suggestions. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| `delay` | `300` | Specifies the number of milliseconds the widget should
    wait before displaying the list of suggestions, after the visitor has started
    typing in the `<input>`. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| `disabled` | `false` | Disables the widget. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| `minLength` | `1` | Specifies the number of characters the visitor needs
    to enter in the `<input>` before the list of suggestions is displayed. Can be
    set to `0` to make the widget display all suggestions in the menu. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `minLength` | `1` | 指定访问者需要在`<input>`中输入的字符数，然后建议列表才会显示出来。可以设置为`0`以使部件在菜单中显示所有建议。'
- en: '| `position` | `{ my: "left top", at: "left bottom", collision: "none" }` |
    Specifies how the list of suggestions should be positioned relative to the `<input>`
    element. This option is used in the exact same way, and accepts the same values
    as the position utility that we looked at earlier in the book. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `position` | `{ my: "left top", at: "left bottom", collision: "none" }` |
    指定建议列表相对于`<input>`元素应该定位的方式。该选项使用方式与我们之前在本书中看到的`position`实用程序完全相同，接受相同的值。'
- en: '| `source` | `Array, String or Function` | Specifies the data source used to
    fill the list of suggestions. This option is mandatory and must be configured.
    It accepts an array, string, or function as its value. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `source` | `Array, String or Function` | 指定用于填充建议列表的数据源。此选项是强制性的，必须进行配置。它将数组、字符串或函数作为其值。'
- en: Configuring minimum length
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置最小长度
- en: The `minLength` option allows us to specify the minimum number of characters
    that need to be typed into the associated `<input>` element before the list of
    suggestions is displayed. By default, the suggestions that are displayed by the
    widget only contain the letters typed into the `<input>` element, rather than
    just those starting with the entered letters, which can result in many more suggestions
    being displayed than is necessary.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`minLength` 选项允许我们指定在建议列表显示之前必须在关联的`<input>`元素中键入的最小字符数。默认情况下，部件显示的建议只包含键入到`<input>`元素中的字母，而不仅仅是以输入字母开头的字母，这可能会导致显示比必要更多的建议。'
- en: Setting the `minLength` option to a number higher than the default value of
    `1` can help narrow the list of suggestions, which may be much more important
    when dealing with large remote data sources.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将`minLength`选项设置为比默认值`1`更高的数字可以帮助缩小建议列表，当处理大型远程数据源时，这可能更加重要。
- en: 'Change the configuration object that we used in `autocomplete1.html` (we''ll
    revert to using an array of strings as the data source for the time being), so
    that it appears as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更改我们在`autocomplete1.html`中使用的配置对象（暂时回到使用字符串数组作为数据源），使其显示如下：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Save this file as `autocomplete3.html`. When we run this file in a browser,
    we should find that we need to type two characters into the `<input>`, and only
    cities that contain the characters in consecutive order are displayed, which vastly
    reduces the number of suggestions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`autocomplete3.html`。当在浏览器中运行此文件时，我们应该发现需要在`<input>`中键入两个字符，只有包含连续顺序字符的城市才会显示出来，这大大减少了建议的数量。
- en: Although the benefits are not obvious in this basic example, this can greatly
    reduce the data returned by a remote data source.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个基本示例中，好处并不明显，但这可以大大减少远程数据源返回的数据量。
- en: Appending the suggestion list to an alternative element
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将建议列表附加到另一个元素
- en: By default, the suggestion list is appended to the `<body>` of the page, when
    using their autocomplete widget. We can change this, and specify that the list
    should be added to another element on the page. The autocomplete widget then uses
    the `position` utility to position the list, so that it appears to be attached
    to the `<input>` element it is associated with. We can change this and specify
    that the list should be added to another element on the page, by using the `appendTo`
    option.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用自动补全部件时，建议列表会附加到页面的`<body>`中。我们可以更改这一点，并指定列表应添加到页面上的另一个元素。然后自动补全部件使用`position`实用程序来定位列表，使其看起来附加到与其关联的`<input>`元素。我们可以使用`appendTo`选项更改这一点，并指定列表应添加到页面上的另一个元素。
- en: 'Wrap the underlying `<label>` and `<input>` in a container `<div>` in `autocomplete3.html`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`autocomplete3.html`中，将基础的`<label>`和`<input>`包装在容器`<div>`中：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then change the configuration object in the final `<script>` element to the
    following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将最终`<script>`元素中的配置对象更改为以下代码：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Save this file as `autocomplete4.html`. Usually, the suggestion list is added
    right at the bottom of the `<body>` element of the code. The `appendTo` option
    accepts a jQuery selector or an actual DOM element as its value.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`autocomplete4.html`。通常，建议列表被添加到代码的`<body>`元素的最底部。`appendTo`选项接受一个jQuery选择器或实际的DOM元素作为其值。
- en: In this example, we see that the list is appended to our `<div>` container instead
    of the `<body>` element, which we can verify using Firebug, or another DOM explorer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Working with autocomplete events
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The autocomplete widget exposes a range of unique events that allow us to react
    programmatically to the widget being interacted with. These events are listed
    as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '| Event | Fired when... |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| `change` | A suggestion from the list is selected. This event is fired once
    the list has closed and the `<input>` has lost focus. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| `close` | The suggestion list is closed. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| `create` | An instance of the widget is created. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| `focus` | The keyboard is used to focus a suggestion in the list. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| `open` | The suggestion menu is displayed. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| `search` | The request for the suggestions is about to be made. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| `select` | A suggestion from the list is selected. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: 'The `select` event is useful when we are working with an array of objects as
    the data source and have additional data other than the `label` and `value` properties
    that we used earlier. For the next example, remove the `<div>` container that
    we used in the last example and then change the configuration object, so that
    it appears as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Save this file as `autocomplete5.html`. We've added an extra property to each
    object in our array data source—the population of each city. We use the `select`
    event to obtain the label and our extra property, and write them to the page whenever
    a city is selected.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The event handler that we pass to the `select` event accepts the `event` object
    and the object from the data source that was selected. The `.length` test is used
    to determine if the `pop` element exists on the page. If it does, we simply replace
    the text within it, with the updated statement. If not, we create a new `<p>`
    element, with an `id` of `pop`, and insert this immediately after the `city` input
    field. We can access any property defined within our object in the standard way.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a city has been selected, the page should appear as shown in the following
    screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with autocomplete events](img/2209OS_08_07.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: The autocomplete methods
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the standard methods that all widgets share, the autocomplete
    gives us two unique methods that allow us to initiate certain actions. The unique
    methods are listed as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Usage |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `close` | Close the suggestion menu. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| `search` | Request the list of suggestions from the data source specifying
    the search term as an optional argument |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: 'The `close` method is extremely easy to use, we simply call the `autocomplete`
    widget method and specify `close` as an argument:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will cause the suggestions menu to be closed, and the `close` event to
    be triggered. A possible use for the close event handler is to alert the user
    if there is a problem with the entry they have selected; if it doesn't match an
    entry in a predefined list, then this can be flagged to the user.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The `search` method is slightly more complex, in that it can accept an additional
    argument, although this is not mandatory. If the search method is called without
    passing an argument (which is likely to be the default behavior), the value of
    the associated `<input>` element is used as the search term. Alternatively, the
    term can be provided to the method as the argument.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Working with remote data sources
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this example, we've worked with a rather small local array of data.
    The autocomplete widget really comes into its own when working with remote data
    sources, which is the recommended way of using the widget when the data source
    is large.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving content based on input
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the next example, we''ll use a web service to retrieve the list of countries
    instead of using our local array. Change the `<input>` element in `autocomplete5.html`,
    so that it appears as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then change the final `<script>` element, so that the configuration object
    is defined as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Save this file as `autocomplete6.html`. We changed the `<input>` element in
    this example, as we are requesting the visitor's country instead of a city.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We have specified a string as the value of the source configuration object in
    this example. When a string is supplied to this option, the string should contain
    a URL that points to a remote resource. The widget assumes that the resource will
    output JSON data, and it assumes that the JSON data will be in the format that
    we saw earlier when using an array of objects as the source.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when using a simple string as the value of the `source` option, the
    data that is returned should be an array of objects, where each object contains
    at least a key called `label`. The data can be in JSON or JSONP format for cross-domain
    requests. The widget will automatically add the query string `term=`, followed
    by whatever was typed into the `<input>` element.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, I have specified a URL of my own website. The resource at
    this URL will output the data in the correct format, so you can run this example
    from your desktop computer (without even needing a web server) and see the correct
    behavior as shown in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving content based on input](img/2209OS_08_08.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: One important point that I should make is about the PHP file that I have used.
    It will only return entries from the database that start with the letter(s) typed
    into the `<input>` element, and do not contain the letters as is the default for
    the widget. I wanted to clarify that this is a change that I implemented at the
    server level, and not behavior exhibited by the widget.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: So, using a string as the value of the `source` option is useful and convenient
    when we have a data source that outputs data in the exact format we require, which
    is usually when we are in control of the web service that returns the data, as
    well as the data itself. This may not be the case if we are trying to extract
    data from a public web service over which we have no control. In these situations,
    we will need to use a function as the value of the `source` option and parse out
    the data manually.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Passing a function as a source option
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Passing a function to the `source` option, instead of a local array or a string,
    is the most powerful way of working with the widget. In this scenario, we have
    complete control over the request and how the data is processed before being passed
    to the widget to display in the suggestion menu.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll use a different PHP file that returns different data
    which is not in the format that autocomplete expects. We''ll use the function
    to request and process the data before passing it to the widget. The context of
    the example will be the frontend for a messaging system similar to Facebook''s,
    in which the autocomplete suggests possible message recipients, but can also be
    removed after they have been selected and added to the `<input>` element. The
    page we will end up with will appear as in the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing a function as a source option](img/2209OS_08_09.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'To start with, change the `<body>` of `autocomplete6.html`, so that it contains
    the following markup:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then change the final `<script>` element, so that it appears as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Save this file as `autocomplete7.html`. On the page, we've got some basic markup
    for a form and the necessary elements to recreate the Facebook-style message dialog.
    To test the effect, try entering Admiral Ozzel, Fode, or Han Solo into the textbox,
    then selecting their name when the autocomplete displays their entry.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The autocomplete parameter will only display certain names; if you would like
    to see possible options, then I would recommend browsing to [http://danwellman.co.uk/contacts.php](http://danwellman.co.uk/contacts.php).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We use a `<div>` element that is styled to look just like an `<input>` element,
    with a totally unstyled actual `<input>` within this.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The actual `<input>` is needed, so that the visitor can type into it and so
    that it can be associated with the autocomplete. We use the `<div>` element because
    we can't insert the `<span>` elements that will make up each contact into the
    `<input>` element. We also have a hidden `<input>` element, which will be used
    to store the actual e-mail addresses.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In the script, we use the `getData` function as the value of our `source` option;
    this is called every time the text in the `<input>` field is updated. We first
    make a JSON request to the PHP file containing the data and then iterate over
    each item in the JSON object returned by the request.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Each newly created object is added to the `suggestions` array, and once each
    item in the returned data has been processed, the `suggestions` array is passed
    to the `resp` callback function, which is passed to the `source` function as the
    second argument.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: We then define the `selectEmail` handler for the autocomplete's `select` event;
    this function is automatically passed to two arguments, which are the `event`
    object and a `ui` object containing the suggestion that was selected. We use this
    function to create a `<span>` element to format and hold the text and an anchor
    element that can be used to remove the recipient. The formatted `<span>` is then
    inserted directly before the camouflaged `<input>` element.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we added a click handler for the `#friends` field, so that this gains
    focus when anyone clicks inside it. A click handler has also been added to the
    `#to` field, so that if you click inside it, it will automatically remove the
    contents of the previous entry.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also need a stylesheet to go with this example; add the following CSS
    to a new file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Save this file as `autocompleteTheme.css` in the `css` folder, and link to
    the new file from the `<head>` of our new page:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When we run the page in a browser, we should find that we can type into the
    `<input>` element, select a name from the suggestions menu, and get a nicely formatted
    and styled name added to the fake input.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Displaying HTML in the list of suggestions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the autocomplete widget will only display plain text for each suggestion
    in the list. Of course, this plain text is within HTML elements created by the
    widget, but nevertheless, if we try to use HTML within our data source, then it
    will be stripped out and ignored. However, Scott González, the current project
    leader for jQuery UI, has written an extension that allows us to use HTML for
    each suggestion in the list instead of plain text, if the need arises.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: This could be handy if we wanted to highlight to the visitor the parts of the
    suggestion that matched with what they had typed in the `<input>` element. We
    will need the extension for this example, which can be found at [https://github.com/scottgonzalez/jquery-ui-extensions/blob/master/src/autocomplete/jquery.ui.autocomplete.html.js](https://github.com/scottgonzalez/jquery-ui-extensions/blob/master/src/autocomplete/jquery.ui.autocomplete.html.js).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'The file can be saved in our local `js` directory and a reference to it should
    be included on the page, after the source file for the autocomplete:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Before we make a start on our code, let''s take a look at how it will appear,
    when previewed in a browser:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying HTML in the list of suggestions](img/2209OS_08_10.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: In our next example, we're going to make use of Scott's plugin with the autocomplete
    widget, to allow a user to search for some city names. If there is a match, each
    letter in the selection drop-down will begin to change color, if the letter matches
    the characters entered in the textbox.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the final `<script>` element in `autocomplete5.html`, so that it appears
    as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Save this file as `autocomplete8.html`. We also need to add a styling rule
    to our code; add this to the `<head>` of your file:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Although this appears as a short example, there are some key points here to
    note; let's explore the code we've used in more detail.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we've gone back to using a local array of objects, called `cityList`.
    Both the `value` and `label` properties in each object hold the same data to begin
    with.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'In our configuration object, we specify a new `html` option, which is used
    in conjunction with the HTML extension. We set the value of this option to `true`
    as in the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We''ve used a function as the value of the `source` option in this example.
    Within the function, we first create a new empty array and define a new regular
    expression object. This will case-insensitively match whatever is typed into the
    `<input>`, at the start of a string:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then iterate over each object in our data array and test whether our regular
    expression matches any of the `label` values in the objects in our array. If any
    items do match, we create a new object and give it `value` and `label` properties.
    The `value` property (which is added to the `<input>` element when a suggestion
    is selected) is simply the corresponding value from our data array, and the `label`
    (what is displayed in the suggestion menu) is a new string that contains a `<span>`
    element wrapping the text entered into the `<input>` element:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, we call the `resp` callback, passing in the newly constructed suggestions
    array. We should always ensure that this callback is called, as this is required
    by the widget. It doesn't matter if the suggestions array is empty, the important
    thing is that the callback is called.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So now, each item in the suggestions menu will have a `<span>` element, wrapping
    the text that was typed into the `<input>` element. We can use it to style this
    text slightly differently, such as with the green text `<style>` that we have
    added to our example.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered two widgets in this chapter; both of them are relatively new to the
    library and both work with `<form>` elements of some description. The button widget
    can be used to turn `<a>`, `<button>`, and `<input>` (of the `button`, `submit`,
    or `reset` type) into attractively and consistently styled-rich widgets.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The autocomplete widget is attached to an `<input>` element of the `text` type
    and is used to show a list of suggestions when the visitor begins typing into
    the `<input>` element. The widget is preconfigured to work with a local array
    of data or a URL that outputs data in the expected format. It can also be configured
    to work with data that is not in the expected format. We must first process the
    data being displayed before passing it to the widget, making this an extremely
    versatile and powerful widget.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: We're almost at the end of the section covering the visible widgets, before
    focusing on the interaction helpers available with jQuery UI; let's take a look
    at the two newest additions to the library over the next couple of chapters, beginning
    with the menu widget.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经快接近结束覆盖可见小部件的章节，接下来将专注于 jQuery UI 提供的交互助手；让我们在接下来的几章中一起看看库中的两个最新添加，从菜单小部件开始。
