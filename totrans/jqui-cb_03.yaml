- en: Chapter 3. Crafting Buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Making simple checklists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the spacing within buttonsets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling space with buttons automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting buttons within a group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using effects with the button hover state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button icons and hiding text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **button** widget is an easy way to decorate the HTML button and link elements
    in your user interface. With a simple call to the button widget, we're able to
    decorate the standard elements with the theme framework found in jQuery UI. Additionally,
    there are two types of buttons. There is the singular notion of a button, the
    more popular use case. But there is also the notion of a **buttonset**—used in
    cases where we would like to decorate checkboxes and radio buttons found in typical
    HTML forms.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we take a much closer look at what the button entails, covering
    some usage scenarios by example. We'll go from the simple usage, such as creating
    a checklist and sorting buttons, to more advanced usage, such as applying effects
    and automatically filling space. Along the way, you'll learn how the widget framework
    supports developers in extending the button where it doesn't quite do what they
    need it to.
  prefs: []
  type: TYPE_NORMAL
- en: Making simple checklists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checklists are easy enough to do in plain old HTML, all you really need are
    some checkboxes and some labels beside them. If you're using a widget framework
    such as jQuery UI, however, we can enhance that list with ease. The button widget
    knows how to behave when applied to an `input` element of type `checkbox`. So
    let's start off with a basic list and see how we can apply the button widget to
    the `input` elements. We'll also see if we can take the user interactivity a step
    further with some state and icon enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by creating a simple HTML `div` to hold our checklist. Inside, each
    item is represented by an `input` element of type `checkbox`, along with a `label`
    for the element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With this markup, we actually have a functioning checklist UI, albeit, a less-than-usable
    one. We can use the toggling capability of the jQuery UI button widget to encapsulate
    the `label` and the `checkbox` together as a checklist item.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll introduce the following JavaScript code to collect our `checkbox` inputs
    and use their `labels` to assemble the **toggle button** widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With that, you have a toggle-button checklist, complete with icons to assist
    in conveying the state. When the user clicks on the toggle-button, it goes into
    "on" state, which is depicted by the change in background color, and other theme
    properties. We've also added icons that toggle along with the button state.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2186_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our event handler, fired when the DOM is ready, requires only one line of code
    to turn the `input` elements on the page into toggle buttons. Within the button
    constructor, we're specifying that the default icon to use is the `ui-icon-bullet`
    icon class from the theme framework. The button widget knows that we're creating
    a toggle button because of the underlying HTML element. Since these are checkboxes,
    the widget will change its behavior when the button is clicked—in the case of
    a `checkbox`, we want the button to give the appearance of toggling on and off.
    Additionally, the button widget knows which `label` belongs to which button based
    on the `for` attribute. For example, the label for `for="first"` will be assigned
    to the button with `id="first"`.
  prefs: []
  type: TYPE_NORMAL
- en: Next we apply the `change` event handler to all our buttons. This handler is
    the same for each button, so we can bind it to all buttons at once. The job of
    this handler is to update the button icon. We don't have to change anything else
    about the button state because the default button implementation will do that
    for us. All we need to do in our event handler is check the state on the `checkbox`
    itself. If checked, we show the `ui-icon-check` icon. Otherwise, we show the `ui-icon-bullet`
    icon.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the spacing with buttonsets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The jQuery UI toolkit gives developers a container widget used for working with
    groups of buttons called a **buttonset**. You would use a buttonset for things
    like groups of checkboxes or groups of radio buttons—things that form a collaborative
    set.
  prefs: []
  type: TYPE_NORMAL
- en: The default appearance of the buttonset is of a unified whole. That is, the
    goal is to form a seemingly single widget out of several buttons. By default,
    the buttonset widget has no spacing controls for the developer. The buttons within
    the set, by default, are all stacked up against one another. This may not be what
    we're after, depending on the context of the buttonset widget in our overall user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To better illustrate the spacing constraints we''re presented with, let''s
    build a buttonset widget and look at the result before we go about trying to resolve
    the issue. We''ll use the following group of radio buttons as our markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''ll create the buttonset widget as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here is what our buttonset looks like. Notice that this widget still exhibits
    radio button functionality. Here the third item is selected, but will become deselected
    if I were to click elsewhere in the widget.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/2186_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, there is nothing wrong with the default presentation of the buttonset widget.
    The only potential challenge we might face is if we have a spacing theme happening
    elsewhere in the application—the stacked against one another look of the widget
    just might not fit in from an aesthetic perspective. We can tackle this issue
    with relatively little effort by extending the widget with an option that allows
    us to "explode" the buttons so that they're no longer touching.
  prefs: []
  type: TYPE_NORMAL
- en: We'll implement this new exploding `buttonset` capability by extending the buttonset
    widget and adding a new option that will enable this behavior. The HTML stays
    the same as previous, but here is the new JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll want to include the following CSS on the page—including it via a new
    stylesheet is the recommended practice here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/2186_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our extension of the buttonset widget adds the `exploded` option, allowing the
    programmer using the widget to specify whether they would like the individual
    buttons separated from one another or not. We also override the `refresh()` method
    here in order to alter the display if the `exploded` option is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we create a jQuery object representing all the individual buttons
    in the buttonset. The reason we're using `map()` here is because of a work-around
    required with `checkbox` and `radio` buttons. The `ui-buttonset-exploded` class
    adds the `margin` that we're looking for between the buttons—it explodes them
    outward. Next, we remove the `ui-corner-left` and `ui-corner-right` classes from
    any of the buttons, and add the `ui-corner-all` class to each button that gives
    them each their own independent borders.
  prefs: []
  type: TYPE_NORMAL
- en: Filling space with buttons automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The width of any given button widget is controlled by what goes inside it. What
    this amounts to is either the primary or secondary icons, or neither, plus the
    text. The actual rendered width of the button itself isn't concretely specified,
    but instead is determined by the browser. Of course, this is a desirable feature
    of any widget—relying on the browser to compute dimensions. This approach scales
    well when there are lots of widgets in the UI to consider, and when there are
    lots of browser resolution configurations to consider.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, a few cases where the automatic width set forth by the browser
    isn't desirable. Think about several buttons in the same context, perhaps a `div`
    element. In all likelihood, these buttons will not render as having the same width,
    when this is in fact a desired property. Just because one button in the group
    has slightly more or slightly less text doesn't mean that we don't want them to
    share a consistent width.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal here is to treat the widest button within a group of buttons as the
    target width. The siblings of the group get notified when a new button is added,
    potentially creating a new target width if it is the widest. Let's illustrate
    the problem further by looking at the default button functionality and what it
    means in terms of width.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the HTML we'll use to create the button widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We're explicitly marking each button as a block-level element so we can easily
    contrast the widths. Notice, too, that the buttons are all siblings.
  prefs: []
  type: TYPE_NORMAL
- en: The following JavaScript turns each button element into a button widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first two buttons are of the same length while the last
    button uses more text and is the widest.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/2186_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now extend the button widget with some new behavior that allows the
    developer to synchronize the width of each button within a group. The modified
    JavaScript code to extend the button widget looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see that the buttons communicate with one another to establish
    the correct width for each sibling within the group. In other words, the first
    two buttons altered their widths as a result of the last button being added to
    the group.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2186_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The extension to the button widget we've just added creates a new `matchWidth`
    option, which, if `true`, will change the width of this button to match that of
    the widest in this group if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Our extension of the `_create()` method calls the default `_create()` button
    implementation, and then we tell all our siblings to `refresh()`. We include this
    button in the list of siblings by using `addBack()`—the reason being, we might
    have to adjust our own width if there is already someone bigger than us. Alternatively,
    if we're now the widest sibling, we have to tell everyone so that they can adjust
    their widths.
  prefs: []
  type: TYPE_NORMAL
- en: The `refresh()` method calls the base `refresh()` implementation, then figures
    out whether the width of this button should be updated or not. The first step
    is to generate a width array for all siblings in the group, including ourselves.
    With an array of widths, we can pass it to `Math.max()` to get the maximum width.
    If the current width of this button is less than the widest button in the group,
    we adjust to the new width.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we're not actually collecting or changing the width of the button
    element itself, but rather, the `span` element within. This `span` has the `ui-button-text`
    class, and is the element of variable width we're interested in. If we took the
    other route of simply measuring the button's width, we could end up with some
    messy margin issues that leave us in a state worse than we were in to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll notice in the previous example that the text of the resized buttons remained
    centered. We could, if so inclined, introduce a small CSS adjustment when making
    button width changes that would keep the button text aligned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that within the `_refresh()` method, we're now stating that the `text-align`
    CSS property is `left`. Additionally, we have to add a new `_destroy()` method
    to clean up this property when the button is destroyed. The end result is the
    same as our previous example, except now the button text is aligned.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/2186_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sorting buttons within a group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the `sortable()` interaction widget to provide the user which some
    flexibility. Why not let the user move buttons around? Especially given the small
    amount of code it takes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll use a list to organize our buttons, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the following CSS to fix the list layout to better display button
    widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript code to make this happen is actually quite miniscule—we create
    the buttons, then we apply the sortable interaction widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we're able to drag-and-drop buttons—but only within the designated
    container element, in this case, `ul`.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/2186_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we're doing in this example, once the document is ready, is
    creating the button widgets. We're using anchors as the underlying element, which
    works just as well as `button` elements. You'll notice too, that we've structured
    the button widgets on the page inside of an unordered list. The styles added to
    the page just remove the list indentation and the bullets. But the `ul` element
    is what we're targeting for the sortable interaction. By default, the sortable
    widget looks for all child elements and makes them the sortable items, in our
    case, these are `li` elements. The `opacity` option specified in the example tells
    `sortable` to change the visual opacity of the element being dragged.
  prefs: []
  type: TYPE_NORMAL
- en: Using effects with the button hover state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The button widget utilizes the various states found in the jQuery UI theme framework.
    For example, when the user hovers over a button widget, this event triggers a
    handler inside the button widget that applies the `ui-state-hover` class to the
    element, changing its appearance. Likewise, when the mouse leaves the widget,
    a different handler removes that class.
  prefs: []
  type: TYPE_NORMAL
- en: This default functionality of the button widget works fine—it just uses the
    `addClass()` and `removeClass()` jQuery functions to apply the hover class. As
    the user moves around and considers what he/she wants to do next, the mouse is
    likely to move in and out of button widgets; this is where we tweak the experience
    by providing the user with some subtle effects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this example, we'll just create three simple button elements that will serve
    as the button widgets. This way, we can experiment with moving the mouse pointer
    over several buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's extend the capabilities of the default button widget to include a new
    option called `animateHover` that when `true`, animates the addition and removal
    of the `ui-state-hover` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've added a new option to the button widget called `animateHover`. When `true`,
    buttons will animate the addition or removal of the CSS properties found in `ui-state-hover`
    class. This is all done by overriding the `_create()` method, called when the
    button widget is first instantiated. Here, we're checking if the `animateHover`
    option is `false`, after we call the original `_create()` method that performs
    routine button initialization tasks.
  prefs: []
  type: TYPE_NORMAL
- en: If the option is set, the first job is unbinding the original `mouseenter` and
    `mouseleave` event handlers from the button. These handlers are what, by default,
    simply add or remove the hover class. This is exactly what we want to change,
    so once the original handlers are removed, we're free to register our own using
    `_on()`. This is where we use the `stop()`, `addClass()`, and `removeClass()`
    functions. The jQuery UI effects extensions apply to the `addClass()` and `removeClass()`
    functions if a duration is given after the class name, which we've done here.
    We want the adding of the `ui-state-hover` class to take `200` milliseconds and
    the removal of the class to take `100` milliseconds since the initial hover is
    more noticeable by the user. Finally, the `stop( true, true )` call is a common
    technique in jQuery for ensuring animations don't overlap and cause jittery behavior
    from the user perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Button icons and hiding text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With buttons, developers can choose to render icon-only buttons. This is accomplished
    by telling the button we don't want the text displayed. This is easy enough to
    do and serves a number of use cases—often, depending on context, an icon will
    suffice in explaining its action. What's more, we can add the button label back
    any time we wish with a simple option change. We can do this because the button
    text is part of the underlying HTML component. With icons, however, things become
    a little trickier because they're an adornment on the button. We can't turn the
    icons on and off as we can do with the text—the entire icon specification needs
    to be applied once again.
  prefs: []
  type: TYPE_NORMAL
- en: Something to aim for, then, would be a method to specify the icons in the button
    constructor, but remember them once turned off. This way, the icons will behave
    as though they're part of the original DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start with creating the structure necessary for three icon buttons. We'll
    also introduce two links that alter the state of each button.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll provide the button widget with our icon toggling capability by adding
    a new `icon` option. The idea, remember, is to provide the same capability as
    the `text` option, except for icons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Initially, the three buttons are created with `text` disabled, even though the
    button text still exists as part of the underlying DOM element. Next, we set the
    `icon` option for each of the three buttons. When the page first loads, you should
    just see icon buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2186_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The two links on the page, **no icons** and **icons** remove and add icons to
    the button widgets, respectively. The function callback for each link does this
    by setting a value for the custom `icon` option we've added to the `button` widget.
    Clicking on the **no icons** link would result in the button icons being removed,
    and replaced with their text.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2186_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By clicking on the **icons** link, we're re-enabling the `icons` option we had
    set previously for each button. This is done by changing our custom `icon` button,
    so if we click on that link now, we can see that our icons are restored, without
    having to specify what icons were used.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/2186_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You'll notice that by setting the `icon` value to `true`, we didn't hide the
    text, as was the case in the original state of the buttons. We can still do this
    by manually setting `text` to `false`, but that should be a manual process, and
    not a modification by our button extension.
  prefs: []
  type: TYPE_NORMAL
- en: Our extension adds a new `_hiddenIcons` attribute where we can store the value
    of the `icons` option when the `icon` option is set to `false`. We perform the
    bulk of our work in `_setOption()`, which is called any time a developer wants
    to set an option on the widget. We only care about the new `icon` option we've
    added. First, we check if we're disabling the icons, in which case, we store a
    copy of the `icons` option in the `_hiddenIcons` attribute so that it can be restored
    at another time. We also set the `text` option to `true`, so that the text will
    display if hidden. It would be a bad idea to hide the button icon and the text
    at the same time. Finally, we actually hide the icons by unsetting the `icons`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, we're enabling icons, we need to look them up in the
    `_hiddenIcons` attribute and set them as the `icons` button option. The `_create()`
    implementation we're overriding here simply stores the icons setting in `_hiddenIcons`
    and hides them if this has been specified when the widget is first created.
  prefs: []
  type: TYPE_NORMAL
