- en: Chapter 3. Custom Bindings and Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the concepts you have learned in the last two chapters, you can build
    most of the applications you find in the real world. Of course, if you write code
    with just the knowledge of these two chapters, you should be very tidy because
    your code will become bigger and bigger and will be difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a Google engineer was asked about how to build large applications. His
    answer was short and eloquent: *Don''t*. Don''t write large applications. Instead,
    write small applications, small pieces of isolated code that interact with each
    other, and build a large system with them.'
  prefs: []
  type: TYPE_NORMAL
- en: How can we write small, reusable, and isolated pieces of code that extend the
    functionality of Knockout? The answer is by using custom bindings and components.
  prefs: []
  type: TYPE_NORMAL
- en: Custom bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know what a binding is, it is everything we write inside the `data-bind`
    attribute. We have some built-in bindings. Click and value are two of them. But
    we can write our own custom bindings that extend the functionality of our application
    in a tidy way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing a custom binding is very easy. It has a basic structure that we should
    always follow to begin with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Knockout has an internal object called `bindingHandlers`. We can extend this
    object with our custom binding. Our binding should have a name to refer to it
    inside the `bindingHandlers` object. Our custom binding is an object that has
    two functions, `init` and `update`. Sometimes you should use just one of them,
    sometimes both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `init` method, we should initialize the state of our binding. Inside
    the `update` method, we should set the code to update the binding when its model
    or value is updated. These methods give us some parameters to undertake this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '`element`: This is the DOM element involved in the binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valueAccessor`: This is the value of the binding. It is usually a function
    or an observable. It is safer if you use `ko.unwrap` to get the value, such as
    `var value = ko.unwrap(valueAccessor());`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allBindings`: This is an object that you can use to access other bindings.
    You can get a binding using `allBindings.get(''name'')`, or ask if a binding exists
    using `allBindings.has(''name'');`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viewModel`: That is deprecated in Knockout 3.x. You should use `bindingContext.$data`
    or `bindigContext.$rawData` instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bindingContext`: With the binding context, we can access familiar context
    objets such as `$root`, `$parents`, `$parent`, `$data`, or `$index` to navigate
    through different contexts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use custom bindings for many things. For example, we can format data
    automatically (currency or dates are clear examples) or increase the semantic
    meaning of other bindings. It's more descriptive to have a binding that is called
    `toggle` than just set `click` and `visible` bindings to show and hide an element.
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom bindings](img/7074OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: New folder structure with custom bindings and components
  prefs: []
  type: TYPE_NORMAL
- en: The toggle binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add new custom bindings to our application we are going to create a new
    folder called `custom` inside our `js` folder. Then we are going to create a file
    called `koBindings.js` and we are going to link it inside our `index.html` file,
    just below our template engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our first custom binding will be called `toggle`. We will use this custom binding
    to change the value of a Boolean variable. With this behavior, we can show and
    hide elements, in our case, our cart. Just write this code at the beginning of
    the `koBindings.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we don't need to use the `update` method because we set all the
    behavior when we initialize the binding. We use the `ko.applyBingidsToNode` method
    to link the `click` function to the element. The `applyBindingsToNode` method
    has the same behavior as `applyBindings` but we set a context, a node from the
    DOM where the bindings are applied. We can say that `applyBindings` is an alias
    of `applyBindingsToNode($('body'), viewmodel)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use this binding in our application. Update the `showCartDetails`
    button inside the `views/header.html` template. Remove the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the code for the following button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now we don't need the `showCartDetails` and `hideCartDetails` methods any more
    and we can attack the `visibleCart` variable directly with the `toggle` binding.
  prefs: []
  type: TYPE_NORMAL
- en: With this simple binding, we have removed two methods of our code and we have
    created a reusable code that doesn't depend on our cart view-model. Because of
    that you can reuse the toggle binding in every project you want, as it doesn't
    have any external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also update the `cart.html` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have made this update, we realize that there is no need to use `hideCartDetails`
    anymore. To remove it definitively, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `finishOrder` function, remove the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is no need to keep a function that manages just a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: The currency binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other useful utility that custom bindings offer is the option of formatting
    the data of the node they are applied to. For example, we can format the currency
    fields of our cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this binding just below the toggle binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we are not going to initialize anything because the initial state and the
    update behavior is the same. As a must, when the `init` and the `update` method
    do the same thing, just use the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are going to return the number with the format we want. First
    we use the built-in binding called `text` to update the value of our element.
    This binding gets the element and a function that indicates how to update the
    text inside this element. In the local variable value, we are going to write the
    value that is inside `valueAccessor`. Remember that `valueAccessor` can be an
    observable; this is why we use the `unwrap` method. We should do the same with
    the `symbol` binding. The `symbol` is another binding that we use to set the currency
    symbol. We don't need to define it because this binding does not have a behavior
    and is just a write/read binding. We can access it using `allBindingsAccesor`.
    Finally, we return the value of joining the two variables and set a regular expression
    to convert the value in a formatted currency.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update the price binding in the `catalog` and the `cart` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set the symbol we want and the price will be formatted as: €100, or
    if we set the symbol `$` or empty we will see `$100` (if the price value is 100).'
  prefs: []
  type: TYPE_NORMAL
- en: '![The currency binding](img/7074OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Currency custom binding
  prefs: []
  type: TYPE_NORMAL
- en: Notice how easy it is to add more and more useful bindings to increase the power
    of Knockout.
  prefs: []
  type: TYPE_NORMAL
- en: '![The currency binding](img/7074OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debug the container with the $root context displayed
  prefs: []
  type: TYPE_NORMAL
- en: Create a binding to debug – the toJSON binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we develop our project, we make mistakes and we find unexpected behaviors.
    The Knockout view-model is hard to read because we don't have plain objects, we
    have observables. Because of this, maybe it's useful to have a method and a container
    inside our application that shows us the state of the view-model during the development
    process. This is why we are going to build a `toJSON` binding that becomes our
    view-model into a plain JSON object that we can show into the screen or in our
    console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have used the `ko.toJSON` object to convert the value we get into a JSON
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function has the same interface that the native `JSON.stringify` function
    has. It gets three parameters as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is the object we want to convert into a plain JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second one is the replacer parameter. It can be a function or an array.
    It should return the value that should be added to the JSON string. For more information
    on the replace parameter, please refer the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_native_JSON#The_replacer_parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_native_JSON#The_replacer_parameter)'
  prefs: []
  type: TYPE_NORMAL
- en: The last one represents the spaces that should be applied to the prettified
    result. So in this case, we are saying that we are going to convert the object
    contained in the `valueAccesor()` method, using no replacement function and it
    will be indented with two spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see it in action, we should put this line at the end of the element that
    has the `container-fluid` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now inside this `<div>` tag, we can see the `$root` context as a JSON object.
    The `$root` context is the top of our entire Knockout context, so we can see all
    our view-models inside this box.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work on older browsers that have no native JSON serializer (for
    example, IE 7 or earlier), you must also reference the `json2.js` library.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/douglascrockford/JSON-js/blob/master/json2.js](https://github.com/douglascrockford/JSON-js/blob/master/json2.js)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about how Knockout converts observables into plain JSON at
    this link: [http://knockoutjs.com/documentation/json-data.html](http://knockoutjs.com/documentation/json-data.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Being semantic with our bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes we write code that seems easy to us, but when we look closely at
    it, we realize that it isn''t. For example, in Knockout, we have the visible built-in
    binding. It''s easy to think that if we want to hide something, we just need to
    write: `data-bind="visible:!isVisible"` and you write this every time we want
    to hide something. That is not clear enough. What do we want to express? That
    this element should be hidden by default? That it should be visible when the variable
    is not visible?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The best approach is to write a binding that is called `hidden`. If you have
    a `hidden` binding, you can write `data-bind="hidden: isHidden";` this seems clearer,
    doesn''t it? This binding is easy, let''s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We just use the `visible` type of `bindingHandler` to change the value of the
    `valueAccessor` method. So we have built a more semantic binding.
  prefs: []
  type: TYPE_NORMAL
- en: Look how powerful and extensible Knockout is. We can build more and more behaviors.
    For example, if we want to practice with custom bindings, we can create our own
    image binding that receives an array of photos instead of just one and we can
    create a carousel. We can create our own link binding that helps us to navigate
    inside our application. The possibilities are endless.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how to integrate a jQuery plugin into our bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a jQuery plugin into a custom binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knockout is compatible with jQuery. Actually, there is no need to wrap a jQuery
    plugin into a binding. It will work because Knockout and jQuery are compatible
    with each other. However, as we mentioned earlier, jQuery is a DOM manipulation
    library, so we will need to set an ID to locate the element we want to apply the
    plugin to, and this will create a dependency. If we wrap the plugin inside a custom
    binding, we can access the element and its value with the element and `valueAccessor`
    parameters and we can pass everything we need with the help of the `allBindings`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to integrate a simple plugin called `iCheck` that will give us
    a cool theme for our checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First download the `iCheck` plugin and set the `iCheck.js` file inside the
    `js` folder. Then save the `skins` folder inside the `css` folder. The download
    link for the `iCheck` plugin is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/fronteed/iCheck/archive/2.x.zip](https://github.com/fronteed/iCheck/archive/2.x.zip)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Link both the `css` and `javascript` files with the `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to initialize the plugin and update the value of the element. In
    this case, the `init` and `update` methods are different. So we need to code what
    happens when the binding starts working and what happens when the value is updated.
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrapping a jQuery plugin into a custom binding](img/7074OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Add iCheck to our project
  prefs: []
  type: TYPE_NORMAL
- en: The `iCheck` plugin works just giving a style to our checkboxes. Now the problem
    is that we need to link this plugin with our element.
  prefs: []
  type: TYPE_NORMAL
- en: The basic behavior of `iCheck` is `$('input [type=checkbox]').icheck(config)`.
    When the value of the checkbox changes, we need to update the value of our binding.
    Fortunately, `iCheck` has events to detect when the value changes.
  prefs: []
  type: TYPE_NORMAL
- en: This binding is going to manage just the `iCheck` behavior. This means that
    the value of the observable is going to be handled by another binding.
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense that we use the `checked` binding. Use these two bindings separately
    so that the `iCheck` binding manages presentation and the `checked` binding manages
    value behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, we can remove the `icheck` binding or use another binding for
    presentation and the checkbox will still work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Following the `init` convention we saw in the first part of the chapter, we
    are going to initialize the plugin and set the events inside the `init` method.
    In the `update` method, we are going to update the value of the checkbox when
    the observable handled by the checked binding changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we use the `allBindingsAccesor` object to get the value of the
    checked binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use this to create cool checkboxes in our app in an isolated way.
    We are going to hide and show our search box with this plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this just below the **Show Cart Details** / **Hide Cart Details** button
    in the `header.html` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then go to the `catalog.html` file and add a visible binding in the search
    bar as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the variable to the view-model, and also set it in the `return` statement,
    as we have done with all the other variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can see a cool checkbox that allows the user to show and hide the search
    bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrapping a jQuery plugin into a custom binding](img/7074OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Components – isolated view-models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Custom bindings are powerful but sometimes we need more powerful behaviors.
    We want to create an isolated element that behaves as a black box for the rest
    of the application. These kind of elements are called **components**. A component
    has its own view-model and template. It also has its own methods and events also
    we can say that it is an application by itself. Of course we can use dependency
    injection to link our component with our main application view-model, but a component
    can work with every application that gives it the right data.
  prefs: []
  type: TYPE_NORMAL
- en: We can build complex components such as tables, charts, and everything you can
    imagine. To learn how to build a component, you can build a simple one. We are
    going to build an `add-to-cart` button. This is a component that links our catalog
    and our cart, so that with this component we can isolate our catalog and our cart.
    They will be linked through this component, which is just a button that receives
    the cart and the item of the catalog and will have all the logic to insert the
    item to the cart. This is very useful because the cart doesn't need to care about
    inserted items and neither does the catalog. Also, if you need to do some logic
    before or after inserting the item, you can do it in an isolated scope.
  prefs: []
  type: TYPE_NORMAL
- en: '![Components – isolated view-models](img/7074OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Components have isolated view-models that interact with the main application
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic structure of a component is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With the help of this schema, we are going to build our `add-to-cart` button.
    Create a file called `components.js` inside the `custom` folder and write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We send the item we want to add to the cart and the cart itself as parameters
    and define the `addToCart` method. This method is the one we use in our view-model
    but is now isolated inside this component, so our code becomes cleaner. The template
    is the button to add items that we had in our catalog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can update our catalog lines as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Advanced techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to speak about some advanced techniques. We are
    not going to add them to our project because there is no need, but it's good that
    we know we can use these methods if our application requires it.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling descendant bindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If our custom binding has nested bindings, we can tell our binding whether
    Knockout should apply bindings or we should control how these bindings will be
    applied. We just need to return `{ controlsDescendantBindings: true }` in the
    `init` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is telling Knockout that the binding called `allowBindings` is going
    to handle all the descendant bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If we want to extend the context with new properties, we can extend the `bindingContext`
    property with new values. Then we only need to use `ko.applyBindingsToDescendants`
    to update the view-model of its children. Of course we should tell the binding
    that it should control the descendant bindings. If we don't, they will be updated
    twice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here we are not creating a child context. We are just extending the parent context.
    If we want to create child contexts to manage descendant nodes and have the ability
    to use the `$parentContext` magic variable to access our parent context, we need
    to create a new context using the `createChildContext` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the magic variables inside our child nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: By modifying binding contexts and controlling descendant bindings, you have
    a powerful and advanced tool to create custom binding mechanisms of your own.
  prefs: []
  type: TYPE_NORMAL
- en: Using virtual elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Virtual elements** are custom bindings that are allowed to use Knockout comments.
    You just need to tell Knockout that our binding is allowed to be virtual.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To add our binding to the allowed virtual elements, we write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Virtual elements have an API to manipulate the DOM. You can use jQuery to manipulate
    virtual elements because one of the advantages of Knockout is that it is fully
    compatible with DOM libraries, but we have a complete API of virtual elements
    in the Knockout documentation. This API allows us to perform the kinds of transformations
    needed when implementing control flow bindings. For more information on custom
    bindings for virtual elements, please refer the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://knockoutjs.com/documentation/custom-bindings-for-virtual-elements.html](http://knockoutjs.com/documentation/custom-bindings-for-virtual-elements.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessing data before binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are able to preprocess data or nodes before the binding will be applied.
    This could be useful to format data before it is displayed or add new classes
    or behaviors to our nodes. You can also set default values, for example. We just
    need to use the `preprocess` and `preproccessNode` methods. Using the first method,
    we can manipulate the value of our binding. With the second one, we can manipulate
    the DOM element (template) of our binding as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We can manipulate DOM nodes using the hook `preprocessNode`. This hook is thrown
    each time we process a DOM element with Knockout. It does not bind to a concrete
    binding. It is fired to all processed nodes, so you need a mechanism to locate
    the node you want to manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to extend Knockout using custom bindings
    and components. Custom bindings extend the options we can use inside the `data-bind`
    attribute and give us the power to make our code more readable, isolating DOM
    and data manipulation inside them. On the other hand, we have components. Components
    have their own view-model. They are an isolated application themselves. They help
    us to build complex applications through small pieces of code that interact with
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to split applications into small pieces of code, in the
    next chapter, you are going to learn how to use events in an unobtrusive way and
    how to extend observables to increase the performance and capabilities of Knockout.
  prefs: []
  type: TYPE_NORMAL
- en: To download the code from this chapter, go to the GitHub repository at [https://github.com/jorgeferrando/knockout-cart/tree/chapter3](https://github.com/jorgeferrando/knockout-cart/tree/chapter3).
  prefs: []
  type: TYPE_NORMAL
