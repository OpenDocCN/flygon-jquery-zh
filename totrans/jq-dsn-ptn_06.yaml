- en: Chapter 6. The Builder and Factory Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will showcase the Builder and Factory Patterns, two of the
    most commonly used Creational Design Patterns. These two design patterns have
    some similarities with each other, share some common goals, and are dedicated
    to easing the creation of complex results. We will analyze the benefits that their
    adoption can bring to our implementations and also the ways in which they differ.
    Finally, we will learn how to use them properly and choose the most appropriate
    one for the different use cases of our implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduce the Factory Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how the Factory Pattern is used by jQuery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have an example of the Factory Patten in a jQuery application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce the Builder Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare the Builder and Factory Patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how the Builder Pattern is used by jQuery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have an example of the Builder Patten in a jQuery application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Factory Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Factory Pattern is part of the group of Creational Patterns and overall
    it describes a generic way for object creation and initialization. It is commonly
    implemented as an object or function that is used to generate other objects. According
    to the majority of Computer Science resources, the reference implementation of
    the Factory Pattern is described as a class that provides a method that returns
    newly created objects. The returned objects are commonly the instances of a specific
    class or subclass, or they expose a set of specific characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the Factory Pattern](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The key concept of the Factory pattern is to abstract the way an object or a
    group of related objects are created and initialized for a specific purpose. The
    point of this abstraction is to avoid coupling an implementation with specific
    classes or the way that each object instance needs to be created and configured.
    The result is an implementation that works as an abstract way for object creation
    and initialization, which follows the concept of Separation of Concerns.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting implementations are only based on the object methods and properties
    that are required by their algorithm or business logic. Such an approach can benefit
    the modularity and extensibility of an implementation, by following the concept
    of programming over Object Features and Functionality instead of Object Classes.
    This gives us the flexibility to change the used classes with any other object
    that exposes the same functionality.
  prefs: []
  type: TYPE_NORMAL
- en: How it is adopted by jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already noted in the earlier chapters, one of the early goals of
    jQuery was to provide a solution that worked the same across all browsers. The
    1.12.x version series of jQuery are focused on providing support for browsers
    as old as Internet Explorer 6 (IE6), while maintaining the same API with the newer
    v2.2.x versions that only focus on modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a similar structure and maximize the common code between the
    two versions, the jQuery team tried to abstract most compatibility mechanisms
    in a different implementation layer. Such a development practice greatly improves
    the readability of the code and reduces the complexity of the main implementation,
    encapsulating it into different smaller pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great example of this is the implementation of the AJAX-related methods that
    jQuery provides. Specifically, in the following code, you can find a part of it,
    as found in version 1.12.0 of jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Every time a new AJAX request is issued on jQuery, the `jQuery.ajaxSettings.xhr`
    method is used as a Factory that creates a new instance of the appropriate XHR
    object based on the support of the current browser. Looking in more detail, we
    can see that the `jQuery.ajaxSettings.xhr` method orchestrates the use of two
    smaller Factory functions, with each responsible for a specific implementation
    of AJAX. Moreover, we can see that it actually tries to avoid running the compatibility
    tests on every call by directly wiring up its reference to the smaller `createStandardXHR`
    Factory function when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Using Factories in our applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an example use case of Factories, we will create a data-driven form where
    our users will be able to fill some fields that are dynamically created and inserted
    into the page. We will assume the existence of an array containing objects that
    describe each form field that needs to be presented. Our Factory method will encapsulate
    the way in which each form field needs to be constructed, and properly handle
    each specific case, based on the characteristics defined on the related objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Factories in our applications](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The HTML code for this page is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It only contains an `<h1>` element with the page heading and an empty `<form>`
    element that will host the generated fields. As for the CSS used, we only style
    the `<button>` elements in the same way as we did in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the JavaScript implementation of the application, we create a module
    and declare `dataDrivenForm` as the namespace of this example. This module will
    contain the data that describes our form, the Factory method that will generate
    the HTML of each form element and, of course, the initialization code that will
    combine the aforementioned parts to create the resulting form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our Factory method will be invoked with three parameters. Starting from the
    most important one, it accepts the `type` and the `name` of the form field and
    also the `title` that will be used as its description. Since most form fields
    share some common characteristics, like their title, the Factory method tries
    to abstract them in order to have less code repetition. As you can see, the Factory
    method also contains some sensible extra configuration for each field type, like
    the `maxlength` attribute of the text fields, that is specific for this use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object structure that will be used to represent each form element will
    be a plain JavaScript object that has a `type`, `name`, and `title` property.
    The collection of objects that describe the form fields will be grouped in an
    array and be available on the `dataDrivenForm.parts` property of our module. In
    a real-world application, these fields would commonly either be retrieved with
    an AJAX request or be injected into some part of the HTML of the page. In the
    following code snippet, we can see the data that will be used to drive the creation
    of our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define and immediately invoke an `init` method for our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The initialization code waits until the DOM of the page is fully loaded and
    then uses the Factory method to create the form elements and attach them to the
    `<form>` element of our page. An extra concern of the preceding code is to check
    the result of the Factory method invocation before actually starting to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Most Factories, when invoked with parameters for a case they can't handle, return
    `null` or empty objects. As a result, it's a good common practice, when using
    Factories, to check whether the result of each invocation is actually valid.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, having Factories that accept only simple parameters (for example,
    strings and numbers), in many cases, leads to an increased number of parameters.
    Even though these parameters may only be used in specific cases, the API of our
    Factory starts to be awkwardly long and needs proper documentation for each special
    case in order to be usable.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, a Factory method should accept as few arguments as possible, otherwise
    it will start looking like a Facade that only provides a different API. Since,
    in some cases, using a single string or numeric argument does not suffice, in
    order to avoid using a huge number of parameters, we can follow a practice where
    the Factory is designed to accept a single object as its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in our case, we can just pass the whole object that describes
    the form field as a parameter to the Factory method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This practice is suggested for the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When we create generic Factories that are not focused on specific use cases
    and we need to configure their results differently for each specific use case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the constructed objects have many optional configuration parameters that
    largely differ. In this case, adding them as separate parameters to the Factory
    method would lead to invocations that have a number of `null` arguments, depending
    on which exact argument we are interested in defining.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another practice, especially in JavaScript programming, is to create a Factory
    method that accepts a simple string or numeric value as its first argument and
    optionally provide a complementary object as a second parameter. This enables
    us to have a simple generic API that can be use-case-specific and also gives us
    some extra points of freedom to configure some special cases. This approach is
    used by the `$.ajax( url [, settings ] )` method that allows us to generate simple
    GET requests by just providing a URL and also accepts an optional `settings` parameter
    that allows us to configure any aspect of the request. Changing the above implementation
    to use this variation is left as an exercise for the reader, in order to experiment
    and get familiar with the use of Factory methods.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Builder Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Builder Pattern is part of the group of Creational Patterns and provides
    us a way to create objects that require a lot of configuration before they reach
    the point where they can be used. The Builder Pattern is often used for objects
    that accept many optional parameters in order to define their operation. Another
    matching case is for the creation of objects where their configuration needs to
    be done in several steps or in a specific order.
  prefs: []
  type: TYPE_NORMAL
- en: The common paradigm for the Builder Pattern according to Computer Science is
    that there is a Builder Object that provides one or more setter methods (`setA(...)`,
    `setB(...)`) and a single generation method that constructs and returns the newly
    created result object (`getResult()`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the Builder Pattern](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This pattern has two important concepts. The first one is that the Builder Object
    exposes a number of methods as a way to configure the different parts of the object
    that is under construction. During the configuration phase, the Builder Object
    preserves an internal state that reflects the effects of the invocations of the
    provided setter methods. This can be beneficial when used to create objects that
    accept a large number of configuration parameters, solving the problem of Telescopic
    Constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Telescopic Constructors is an anti-pattern of object-oriented programming that
    describes the situation where a class provides several constructors that tend
    to differ on the number, the type, and the combination of the arguments that they
    require. Object classes with several parameters that can be used in many different
    combinations can often lead to implementations falling into this anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The second important concept is that it also provides a generation method that
    returns the actual constructed object based on the preceding configuration. Most
    of the time, the instantiation of the requested object is done lazily and actually
    takes place at the moment that this method is invoked. In some cases, the Builder
    Object allows us to invoke the generation method more than once, allowing us to
    generate several objects with the same configuration.
  prefs: []
  type: TYPE_NORMAL
- en: How it is adopted by jQuery's API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Builder Pattern can also be found as part of the API that jQuery exposes.
    Specifically, the jQuery `$()` function can also be used to create new DOM elements
    by invoking it with an HTML string as an argument. As a result, we can create
    new DOM elements and set their different parts as we need them, instead of having
    to create the exact HTML string that is needed for the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `$('<input />')` call returns a Composite Object containing an element that
    is not attached to the DOM tree of the page. This unattached element is only an
    in-memory object that is neither fully constructed nor fully functional until
    we attach it to the page. In this case, this Composite Object acts like a Builder
    Object Instance having an internal state of objects that are not yet finalized.
    Right after this, we do a series of manipulations on it using some jQuery methods
    that act like the setter methods described by the Builder Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after we apply all the required configurations, so that the resulting
    object behaves in the desired way, we invoke the `$.fn.appendTo()` method. The
    `$.fn.appendTo()` method works as the generation method of the Builder Pattern,
    by attaching the in-memory element of the `$input` variable to the DOM tree of
    the page, transforming it into an actual attached DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the above example can get more readable and less repetitive by utilizing
    the Fluent API that jQuery provides for its methods, and also combine the `$.fn.attr()`
    method invocations. Moreover, jQuery allows us to use almost all its methods to
    do traversals and manipulations on the elements that are under construction, just
    as we can on normal DOM element Composite Objects. As a result, the above example
    can get a little more complete as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it is adopted by jQuery''s API](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The criteria that allow us to categorize this overloaded way of invoking the
    `$()` function as an implementation that adopts the Builder Pattern, is the fact
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: It returns an object with an internal state containing partially constructed
    elements. The contained elements are only in-memory objects that are not part
    of the page's DOM tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides us methods to manipulate its internal state. Most jQuery methods
    can be used for this purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides us method(s) to generate the final result. We can use jQuery methods
    such as `$.fn.appendTo()` and `$.fn.insertAfter()`, as a way to complete the construction
    of the internal elements and make them part of the DOM tree with properties that
    reflect their earlier in-memory representation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we have already seen in [Chapter 1](part0014_split_000.html#DB7S2-e8d3cd3d052d4ee0b4673af57a64ddef
    "Chapter 1. A Refresher on jQuery and the Composite Pattern"), *A Refresher on
    jQuery and the Composite Pattern*, the primary way to use the `$()` function is
    to invoke it with a CSS selector as a string parameter and in turn it will retrieve
    the matching page elements and return them in a Composite Object. On the other
    hand, when the `$()` function detects that it has been invoked with a string parameter
    that looks like a piece of HTML, it works as a DOM element Builder. This overloaded
    way of invoking the `$()` function bases its detection on the assumption that
    the provided HTML code starts and ends with the inequality symbols `<` and `>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, this overload uses the `jQuery.parseHTML()`
    helper method that ultimately leads to a call of the `createDocumentFragment()`
    method. The created **Document Fragment** is then used as a host of the under
    construction tree structure of elements. After jQuery finishes converting the
    HTML into elements, the Document Fragment is discarded and only it''s hosted elements
    are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This results in the creation of a new jQuery Composite Object containing an
    in-memory tree structure of elements. Even though these elements are not attached
    to the actual DOM tree of the page, we can still do traversals and manipulations
    on them like any other jQuery Composite Object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on Document Fragments, you can visit: [https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment](https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment).'
  prefs: []
  type: TYPE_NORMAL
- en: How it is used by jQuery internally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An undoubtedly big part of jQuery is its AJAX-related implementation, which
    aims to provide a simple API for asynchronous calls that is also configurable
    to a large degree. Using the jQuery Source Viewer and searching for `jQuery.ajax`,
    or directly searching jQuery''s source code for `"ajax:"`, will bring us the aforementioned
    implementation. In order to make its implementation more straightforward and also
    allow it to be configurable, jQuery internally uses a special object structure
    that acts as a Builder Object for the creation and handling of each AJAX request.
    As we will see, this is not the most common way of using a Builder Object, but
    it is actually a special variant with some modifications in order to fit the requirements
    of this complex implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The main method that the `jqXHR` object exposes to configure the generated asynchronous
    request is the `setRequestHeader()` method. The implementation of this method
    is quite generic, enabling jQuery to set all the different HTTP headers for the
    request, using only one method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to provide an even greater degree of flexibility and abstraction,
    jQuery internally uses a separate `transport` object as a wrapper of the `jqXHR`
    object. This transport object handles the part of actually sending the AJAX request
    to the server, working like a *partner builder object* that cooperates with the
    `jqXHR` object for the creation of the final result. This way, jQuery can fetch
    Scripts, XML, JSON, and JSONP responses from the same or cross-origin servers,
    using the same API and overall implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Another special thing about this implementation of the Builder Pattern is that
    it should be able to operate in both synchronous and asynchronous manner. As a
    result, the `send()` method of the `transport` object that acts as the result
    generator method of the wrapped `jqXHR` object can't just return a result object,
    but it is instead invoked with a callback.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the request is complete, jQuery uses the `getResponseHeader()`
    method to retrieve all the required response headers. Right after this, the headers
    are used to properly convert the received response that is stored in the `responseText`
    property of the `jqXHR` object.
  prefs: []
  type: TYPE_NORMAL
- en: How to use it in our applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an example use case of the Builder Pattern in a client-side application that
    uses jQuery, we will create a simple data-driven multiple-choice quiz. The main
    reason that the Builder Pattern is a better match for this case, as compared to
    the Factory Pattern example that we saw earlier, is that the result is more complex
    and has more degrees of configuration. Each question will be generated based on
    a model object that will represent its desired properties.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to use it in our applications](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once again, the required HTML is very simple, containing just an `<h1>` element
    with the header of the page, an empty `<form>` tag, and some references to our
    CSS and JavaScript resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the common, simple styles that we have seen in the previous chapters,
    the CSS of this example additionally defines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For the needs of this example, we will create a module with a new namespace
    named `dataDrivenQuiz`. As we saw earlier in this chapter, we will assume the
    existence of an array containing the model objects that describe each multiple-choice
    question that needs to be presented. Each of these model objects will have:'
  prefs: []
  type: TYPE_NORMAL
- en: A `title` property that will hold the question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `options` property that will be an array with the available answers to choose
    from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional `acceptsMultiple` property to signify whether we should use radio
    or check boxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The array with the model objects that describe the form questions will be available
    at the `dataDrivenQuiz.parts` property of our module, while keeping in mind that
    our implementation could easily be modified to fetch the models with an AJAX request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defining the data structures that are required to describe a problem, before
    starting the actual implementation, allows us to focus on the needs of the application
    and get an estimate of its overall complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the preceding sample data, let''s now proceed to the implementation of
    our Builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using the Prototypical Object-Oriented approach of JavaScript, we firstly define
    the Constructor Function for our `MultipleChoiceBuilder` class. When the Constructor
    Function is invoked using the `new` operator, it will create a new instance of
    the Builder and initialize its `title` property to `"Untitled"` and the `options`
    property to an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: Right after this, we complete the definition of the Constructor Function of
    our Builder, we attach it as a member of our module, and continue with the definition
    of its setter methods. Following the Prototypical Class paradigm, the `setTitle()`,
    `setAcceptsMultiple()`, and `addOption()` methods are defined as properties of
    our Builder's Prototype and are used to modify the internal state of the under
    construction element. Additionally, in order to enable us to chain several invocations
    of these methods, which results in a more readable implementation, all of them
    end with the `return this;` statement.
  prefs: []
  type: TYPE_NORMAL
- en: We complete the implementation of the Builder with the `getResult()` method
    that has the duty of gathering all the parameters that are applied on the Builder
    object instance and generating the resulting element wrapped inside a jQuery Composite
    Object. In its first line, it creates a header of the question. Right after this,
    it creates a `<ul>` element with the `unstyled` CSS class to hold the possible
    answers to the question and a unique identifier that will be used as the `name`
    of the generated `<input>` of the question.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the for loop that follows, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `<input />` element for each option of the question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properly set its `type` as a `checkbox` or a `radio` button, based on the value
    of the `acceptsMultiple` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the for loop's iteration number as its `value`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the unique identifier that we generated earlier for the question as the
    input's `name` in order to group the answers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, add a `<label>` with the option's text, which wraps all of them inside
    an `<li>`, and append it to the question's `<ul>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the header and the list of options are wrapped in an `<article>` element,
    which is then returned as the final result of the Builder.
  prefs: []
  type: TYPE_NORMAL
- en: In the above implementation, we use the `$.fn.text()` method to assign the content
    of the question's header and its available choices instead of string concatenation,
    in order to properly escape the `<` and `>` characters that are found in their
    descriptions. As an extra note, since some of the answers also contain single
    quotes, we need to escape them in the model objects using a backslash (`\'`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in our module''s implementation, we define and immediately invoke
    the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The execution of the initialization code is delayed until the DOM tree of the
    page is fully loaded. Then the `init()` method iterates over the model objects
    array and uses the Builder to create each question and populate the `<form>` element
    of our page.
  prefs: []
  type: TYPE_NORMAL
- en: A good exercise for the reader would be to extend the above implementation in
    order to support the client-side evaluation of the quiz. Firstly, this would require
    you to extend the question objects to contain information about the validity of
    each choice. Then, it would be suggested that you create a Builder that would
    retrieve the answers from the form, evaluate them, and create a result object
    with the user choices and the overall success on the quiz.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the concepts of the Builder and Factory Patterns,
    two of the most commonly used Creational Design Patterns. We analyzed their common
    goals, their different approaches on abstracting the process of generating and
    initializing new objects for specific use cases, and how their adoption can benefit
    our implementations. Finally, we learned how to use them properly and how to choose
    the most appropriate one for the different use cases of any given implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed our introduction to the most important Creational
    Design Patterns, we can move on to the next chapter where we will be introduced
    to the development patterns that are used to program asynchronous and concurrent
    procedures. In more detail, we will learn how to orchestrate the execution of
    asynchronous procedures that run either in order or parallel to each other, by
    using callbacks and jQuery Deferred and Promises APIs.
  prefs: []
  type: TYPE_NORMAL
