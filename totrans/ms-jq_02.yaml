- en: Chapter 2. Customizing jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, so we've downloaded a version of jQuery…what do we do next, I wonder?
  prefs: []
  type: TYPE_NORMAL
- en: This is a really good question—let me reveal all!
  prefs: []
  type: TYPE_NORMAL
- en: jQuery has, over the years, become an accomplished library and is used in millions
    of websites around the world. While we can usually find a way to fulfill a need
    using the library, there may be instances where we have to provide our own patch
    or alteration, to satisfy our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a plugin, but that gets tedious after a while—it soon becomes a
    case of "plugin this, plugin that" syndrome, where we become too reliant on plugins.
    Instead, we can look to the override functionality within jQuery itself; yes,
    it has some risks, but as we''ll see, it is well worth the effort. Throughout
    this chapter, we''ll cover the basics of overriding jQuery, some of the benefits
    and pitfalls of doing so, and work our way through some examples of replacing
    the functionality. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing duck punching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing or modifying existing behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic monkey patch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering the benefits and pitfalls of monkey patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributing or applying patches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ready to begin your adventure…? Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting prepared
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, I will recommend that you create a project folder somewhere on
    your PC—for the purposes of this demo, I will assume that it is called `project`
    and is at the root of your main hard disk or `C:` drive.
  prefs: []
  type: TYPE_NORMAL
- en: Within the folder, go ahead and create several subfolders; these need to be
    called `fonts`, `css`, `js`, and `img`.
  prefs: []
  type: TYPE_NORMAL
- en: Patching the library on the run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, hundreds of developers have spent countless hours creating patches
    for jQuery, to either fix a bug of some description or provide new functionality
    within the library.
  prefs: []
  type: TYPE_NORMAL
- en: The usual route is to submit a pull request against the Core jQuery library
    for peer consideration. As long as the patch works as expected and does not cause
    issues elsewhere in the library, then it will be submitted to core.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this approach means that we're constrained by the release schedule
    for jQuery; while the developers do an outstanding job, it nevertheless can take
    time before a patch is committed to core.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing monkey patching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What to do? Do we wait in the hope that our patch will be committed?
  prefs: []
  type: TYPE_NORMAL
- en: For some, this won't be an issue—for others, patience may not be their strongest
    virtue and waiting is the last thing they will want to do! Fortunately, we can
    get around this by using a method called monkey patching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now—before you ask—let me tell you that I''m not advocating any form of animal
    cruelty! **Monkey patching**, or **duck punching** as it is otherwise known, is
    a valid technique to create a patch that temporarily overrides the existing functionality
    within the jQuery Core library during runtime. Monkey patching comes with its
    risks: the primary one being that of clashing, should an update introduce a method
    or function of the same name within the library.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Later in this chapter, we'll take a look at some of the risks that need to be
    considered.
  prefs: []
  type: TYPE_NORMAL
- en: That said, if monkey patching is used with care and forethought, it can be used
    to update functionality until a more permanent fix can be applied. It's time,
    I think, for a demo—we'll be taking a look at how we can improve animation support
    in jQuery, but first let's take a look at the basics of replacing or modifying
    the jQuery core at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing or modifying existing behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, how can we effect a (temporary) change in the core functionality of jQuery?
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with the use of an **Immediately Invoked Function Expression**
    (**IIFE**); we then simply save a version of the original function before overriding
    it with our new function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have heard the term *self-executing anonymous function* being used;
    it is a misleading phrase, although it means the same thing as an IIFE, which
    is a more accurate description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the basic framework looks like in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you were expecting something more complex, then I am sorry to disappoint
    you; there isn't a great deal of complexity required for a basic monkey patch!
    The extent of what goes into a patch will really come down to what it is that
    you are trying to fix or alter within the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: To prove that this really is all that is required, let's take a look at an (albeit
    over-simplified) example. In the example, we'll use a standard click handler to
    show the response that a dog will give to its owner…except that our dog seems
    to have developed a personality problem.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic monkey patch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"A personality change?" I hear you ask. Yes, that''s right; our dog seems to
    like miaowing…. (I can''t think of a reason why; I don''t know of any that would!)'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we're going to use a simple click handler to prove that (in
    some cases) our dog can meow; we will then work through what is required in order
    to persuade it to do what it should do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by cracking open a text editor of our choice and then adding the
    following markup as a basis for our patch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save it as the `duck.html` file. In a separate file, we need to animate our
    button, so let''s first add in a simple event handler for this purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, if we run the demo in a browser and then click on **Make it
    a dog!**, we can definitely see that our poor pet has some issues, as shown in
    the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Creating a basic monkey patch](img/image00334.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We clearly need to show it the error of its ways, so let's fix that now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix the problem, we need to override the original `toBark()` function. With
    our new fixed replacement; this will take the form of a monkey patch. Insert the
    following code immediately below the `.on()` click handler, leaving a line space
    for clarity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If all is well, we should now at least see that our dog has come to its senses,
    albeit gradually, as shown in the following screenshot:![Creating a basic monkey
    patch](img/image00335.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This little exercise, albeit heavily simplified, illustrates some key points—it's
    worth spending a little time going through this in more detail, so let's do that
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting our monkey patch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The patching of a core library should be done with care and consideration; the
    technical process may be straightforward, but it will raise some questions that
    need to be answered first. We will cover some of these questions later in the
    chapter, but for now, let's assume that we need to apply a patch.
  prefs: []
  type: TYPE_NORMAL
- en: The basic patch takes the format of an IIFE—we include all the functionality
    within a single module; its scope is protected from the environment in which it
    is placed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a more detailed explanation of IIFEs, please refer to [http://en.wikipedia.org/wiki/Immediately-invoked_
    function_expression](http://en.wikipedia.org/wiki/Immediately-invoked_%20function_expression).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we started by storing a copy of the original function as an
    object, within `orig`. We then initiated our new replacement, the `.toBark()`
    function, within which we first call our `.toBark()` function, but follow it with
    the replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A key part of our patch is the use of the `.apply()` function—this will call
    a function with the context being set to the object where the function is applied.
    In this instance, within the function, referencing the `this` keyword will refer
    to that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using an IIFE in the format used in our demo presents a number of advantages,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can reduce the scope's lookup—IIFEs allow you to pass commonly used objects
    to the anonymous function, so they can be referenced within the IIFE at a local
    scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: As JavaScript first looks for properties within the local scope, this removes
    the need to look globally, providing faster lookup speeds and performance. Using
    an IIFE prevents the local variable from being overwritten by a global variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IIFEs help optimize the code through minification—we can pass objects to an
    IIFE as local values; a minifier can reduce the names of each global object to
    a single letter, provided there isn't a variable already present with the same
    name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The downside of using an IIFE is readability; if our IIFE contains a lot of
    code, then we have to scroll to the top in order to work out what objects are
    being passed. In more complex examples, we can consider using a pattern developed
    by Greg Franko in order to get around this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that this pattern is about splitting the variables into
    two sections so that we can avoid the need to scroll up and down the page too
    often; it will still produce the same end result.
  prefs: []
  type: TYPE_NORMAL
- en: We will delve more into using patterns within jQuery, in [Chapter 3](part0031.xhtml#aid-TI1E1
    "Chapter 3. Organizing Your Code"), *Organizing Your Code*. Now that we've seen
    a patch in action, let's move on and take some time to consider some of the benefits
    we may gain from using the monkey patching process.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the benefits of monkey patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, so we've seen what a typical patch will look like; the question, though,
    is, why would we want to patch the core library functionality using this method?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very good question—it''s a method that has its risks (as we will
    see later in this chapter, in the *Considering the pitfalls of monkey patching*
    section). The key to using this method is to take a considered approach; with
    this in mind, let''s take a moment to consider the benefits of duck punching jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: We can replace methods, attributes, or functions at runtime, where they lack
    functionality or contain a bug that needs to be fixed and we can't wait for an
    official patch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duck punching jQuery allows you to modify or extend the existing behavior of
    jQuery without maintaining a private copy of the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have the safety net of being able to apply a patch to objects running in
    memory, instead of the source code; in other words, if it goes completely wrong,
    we can simply pull the patch from the site and leave the original source code
    untouched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monkey patching is a good way to distribute security or behavioral fixes that
    live alongside the original source code; if there is any doubt with the resiliency
    of a patch, we can stress test it before committing it to the source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enough of the talking, let's get to coding some demos! We're going to work through
    some example patches that can be equally applied to jQuery, beginning with a look
    at animation.
  prefs: []
  type: TYPE_NORMAL
- en: Updating animation support in jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have spent any time developing with jQuery, you've most likely created
    some form of animation that included managing changes at a regular frequency—does
    this sound familiar?
  prefs: []
  type: TYPE_NORMAL
- en: We can, of course, use the `setInterval()` function for this, but it—like the
    `setTimeOut()` function—is not ideal. Both these functions have a delay before
    being initiated, which varies from browser to browser; they are both equally resource
    intensive!
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can use the **requestAnimationFrame** (**rAF**) API, which is now
    supported by most modern browsers, according to this chart from [caniuse.com](http://caniuse.com)
    where green labels show which browser versions support **requestAnimationFrame**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating animation support in jQuery](img/image00336.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The great thing about the requestAnimationFrame API is that it is less resource-intensive,
    doesn't impact other elements on the page, and is disabled when it loses focus
    (perfect for reducing power usage!). You may think, therefore, that it makes sense
    to implement it in jQuery by default, right?
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the requestAnimationFrame API's past
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ironically, jQuery used rAF back in version 1.6.2; it was pulled in 1.6.3, principally
    due to the animations piling up when windows regained focus. Part of this can
    be attributed to how rAF was (incorrectly) being used and that it would require
    major changes to its use, in order to correct the issues.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see some of the issues with timing, browse to [http://xlo.co/requestanimationframe](http://xlo.co/requestanimationframe)—there
    are some demos on this site that illustrate perfectly why timing is so critical!
  prefs: []
  type: TYPE_NORMAL
- en: Using the requestAnimationFrame method today
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thankfully, we can still use requestAnimationFrame with jQuery today; Corey
    Frang, one of the developers of JQuery, wrote a plugin that can hook into and
    override the `setInterval()` method within the core library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The original version of the plugin is available from GitHub for download at
    [https://github.com/gnarf/jquery-requestAnimationFrame/blob/master/src/jquery.requestAnimationFrame.js](https://github.com/gnarf/jquery-requestAnimationFrame/blob/master/src/jquery.requestAnimationFrame.js).
  prefs: []
  type: TYPE_NORMAL
- en: This is probably one of the simplest changes we can make when using jQuery—we
    will explore this, and more, at the end of the exercise. For now, let's get on
    and create some code!
  prefs: []
  type: TYPE_NORMAL
- en: Creating our demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our next demo, we're going to use an updated version of a CodePen example,
    created by developer Matt West—the original demo is available from [http://codepen.io/matt-west/pen/bGdEC/](http://codepen.io/matt-west/pen/bGdEC/);
    I've refreshed the look and removed the vendor prefix elements of Corey's plugin,
    as they are no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give you some idea of what we''re going to achieve, we will override the
    main `setInterval` method; this method does not call a jQuery method although
    it may look like it is; `setInterval` is a plain JavaScript function, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I've incorporated a change of font too—for this demo, I've used the Noto Sans
    typeface, which can be downloaded from [http://www.fontsquirrel.com/fonts/noto-sans](http://www.fontsquirrel.com/fonts/noto-sans);
    feel free to alter the code accordingly, if you want to use a different font.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ready? Let''s make a start by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From a copy of the code download link that accompanies this book, go ahead and
    extract the `raf.css`, `raf.js` and `raf.html` files and save them to your project
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new file, add the following code—this is our monkey patch or a modified
    version of Corey''s original plugin. We start by initiating a number of variables,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up comes the animating function, which is called from the main `requestAnimationFrame`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need our main `requestAnimationFrame` method; go ahead and add the following
    lines of code directly below the `raf()` event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file as `jquery.requestAnimationFrame.js`, within a subfolder called
    `js` under the main project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you run the demo in a browser, you can expect to see the bar move when you
    press **Start Animation**, as shown in the following screenshot:![Creating our
    demo](img/image00337.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To prove that the plugin is being used, we can use Google Chrome's **Timeline**
    option (within **Developer Tools**)—clicking on the red **Record** icon, then
    running the demo, and then stopping it produces this extract:![Creating our demo](img/image00338.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that you have the **JS Profiler** checkbox ticked under **Timeline**
    —the details will be shown; you may have to scroll down to view the **Event**
    entry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is probably one of the easiest changes we can make to override functionality
    in jQuery, yet potentially one of the most controversial—the latter being down
    to how we use it. The key point though is that we can override functionality using
    several formats.
  prefs: []
  type: TYPE_NORMAL
- en: The safest way is by the use of a plugin; in our example here, we used a modified
    one—the original was introduced from jQuery 1.8, so the changes made here just
    brought it up to the modern day. We could completely go in the opposite direction
    though and create a function that overrides an existing function—it carries a
    higher risk, but if done carefully, it is worth the effort! Let's take a look
    at a simple example, in the form of overriding `.hasClass()` to switch in the
    WebP format images when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Adding WebP support to jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, I have a slight confession to make: adding full-blown WebP support
    to jQuery will probably be outside the scope of this book, let alone fill most
    of its pages!'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WebP is a relatively new image format created by Google, which offers better
    compression than standard PNG files—you can read more about it at [https://developers.google.com/speed/webp/](https://developers.google.com/speed/webp/).
    At present, both Chrome and Opera support this format natively; other browsers
    will display WebP images once support is added.
  prefs: []
  type: TYPE_NORMAL
- en: The next demo is really about how we can make the switch between two different
    ways of presenting content on screen, depending on whether our browser supports
    the newer format. A good example of this is where we might use CSS3 animation
    wherever possible and fall back to using jQuery for those browsers that do not
    support CSS3 animation natively.
  prefs: []
  type: TYPE_NORMAL
- en: In our next demo, we're going to use a similar principle to create a monkey
    patch that overrides the `.hasClass()` method in order to automatically switch
    to the WebP format images, where supported.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to learn more, there is a useful discussion on how to get started
    with the format at [http://blog.teamtreehouse.com/getting-started-webp-image-format](http://blog.teamtreehouse.com/getting-started-webp-image-format).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the purpose of this demo, we will need to avail ourselves of an image in
    two different formats; I will assume JPEG has been used as our base format. The
    other image, of course, needs to be in the WebP format!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not have the means already in place to convert your image to the
    WebP format, then you can do this using tools provided by Google, which are available
    for download at [https://developers.google.com/speed/webp/download](https://developers.google.com/speed/webp/download).
    Versions for Windows, Linux, and Mac OS are available for download here—for this
    exercise, I will assume that you are using Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: On the download page, click on [http://downloads.webmproject.org/releases/webp/index.html](http://downloads.webmproject.org/releases/webp/index.html)
    and then look for `libwebp-0.4.2-windows-x64.zip` (if you are still using a 32-bit
    platform for Windows, then please select the `x86` version).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once downloaded, extract the `libwebp-0.4.2-windows-x64` folder to a safe folder
    within your project folder and then navigate to the `bin` folder within it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up a second Explorer view, then navigate to where your image is stored,
    and copy it into the `bin` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up command prompt and then navigate to `C:\libwebp-0.4.2-windows-x64\bin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter this command, replacing both the names with the names
    of your JPEG and WebP images, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If all is well, we will get a screen similar to the following screenshot, along
    with our WebP format image in the `bin` folder:![Getting started](img/image00339.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step is to copy the images into our project folder, so they are ready
    to be used for the next stage of our demo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating our patch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our images prepared, we can go ahead and set up the markup
    for our demo:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and copy the following code into a new file, saving it as `replacewebp.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add in our monkey patch—in a new file, add the following code
    and save it as `jquery.replacewebp.js`. This is a little more involved, so we''ll
    go through it in chunks, beginning with the standard declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next comes the function that performs the test to see whether our browser supports
    the use of the WebP image format; add the following code immediately below the
    variable assignments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we make use of the `testWebP` function to determine whether our browser
    can support the WebP image format—if it can, we alter the file extension used
    to `.webp`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We finish off our function by executing the original version of our function,
    before terminating it with the closing brackets normally associated with an IIFE:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then need to add one more function—this is used to initiate the call to
    `.hasClass()`; go ahead and add the following lines of code below the monkey patch
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If all went well, when we run our demo, we will see an image of an Phalaenopsis,
    or Moth Orchid, as shown in the following screenshot:![Creating our patch](img/image00340.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is nothing out of the ordinary at this point; in fact, you're probably
    wondering what we've produced, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Aha! You''ll see the answer to this question if you inspect the source using
    a DOM inspector, such as Firebug, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our patch](img/image00341.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how it is showing a JPEG format image? That''s because Firefox doesn''t
    natively support this format out of the box; only Google Chrome does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our patch](img/image00342.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you switch to using Google Chrome, then you can view the source by pressing
    *Ctrl* + *Shift* + *I*. You can clearly see the change in the format being used.
    If you are still in doubt, you can even take a look at the **Console** tab of
    Google Chrome. Here, it clearly shows that the patch has been referenced, as it
    displays the two messages that you expect to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our patch](img/image00343.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We've created our patch and it seems to work fine—that's all that we need to
    do, right? Wrong, there are more steps that we should consider, some of which
    may even prevent us from releasing the patch to a wider audience, at least for
    the time being.
  prefs: []
  type: TYPE_NORMAL
- en: There are some points that we need to consider and some actions that we may
    need to take as a result; let's pause for a moment and consider where we need
    to go from here, in terms of development.
  prefs: []
  type: TYPE_NORMAL
- en: Taking things further
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we've overwritten an existing method as a means to illustrate
    duck punching—in reality, we will need to spend a little more time finessing our
    patch before we can release it!
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle reason for this is the age-old issue of downloading more content
    than we really need; to prove this, take a look at the **Resources** tab of Google
    Chrome, when running the demo in that browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking things further](img/image00344.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As if we need further confirmation, this extract from the **Timeline** tab
    also confirms the presence of both the JPEG and WebP images being called and the
    resulting impact on download times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Taking things further](img/image00345.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We created a patch here to illustrate what *can* be done; in reality, we will
    very likely include code to perform different actions on our content. As a start,
    we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Include support for more image formats—this can include JPEG, GIF, or SVG.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardcode the code to accept one image format; we can extend the usability of
    our patch by making it more generic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jQuery is moving more toward a plugin-based architecture; should we really be
    considering patching the core code? There may be more mileage in creating a hook
    within the code, which then allows you to extend the existing functionality with
    a new plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used `.hasClass()` as the basis for overriding an existing method; is this
    really the most appropriate thing to do? Although at face value it may appear
    to be useful, in reality, others may not agree with our choice of overriding `.hasClass`
    and consider other methods more useful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are plenty of questions that may be raised and need answering; it's only
    as a result of careful consideration that will we maximize any opportunity of
    our patch being successful and potentially consider it for submission to the core.
  prefs: []
  type: TYPE_NORMAL
- en: Let's change tack and switch to examining a key part of monkey patching. The
    process has its risks, so let's take a moment to consider some of these risks
    and the impact these may have on our work.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the pitfalls of monkey patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve seen some examples in action, it''s worth taking a moment to
    consider some of the risks of monkey patching libraries, such as jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: The principle risk and one that is likely to cause the most trouble is clashing.
    Imagine that you've created a patch that contains some functions—we'll call these
    functions `1`, `2`, and `3`. Add another patch, and it is essential that we do
    *not* use the same function names; otherwise, it's difficult to determine whether
    function `1`, or `2`, or even `3` comes first?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another risk is security. If a library such as jQuery can be monkey patched,
    what is to stop anyone from introducing malicious constructs that damage the existing
    code? One can argue that this risk is always present in client-side scripting;
    the risk is greater when you override core jQuery functionality, compared to a
    standard plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is always a risk that an upgrade to the core library may introduce a change
    that not only breaks your patch but also removes or alters the functionality that
    would otherwise provide a basis for your patch to work. This will prevent a site
    that uses jQuery from being upgraded and ultimately leave it vulnerable to attack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding too many patches without due care and consideration will make your API
    bloated and slow; this will reduce responsiveness and make it harder to manage,
    as we have to spend more time dissecting the code before we can get to the crux
    of an issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any monkey patches should really be kept within your site; they will be based
    on the code that directly alters jQuery, rather than use the predefined mechanism
    that a standard jQuery plugin provides. It is likely that authors may not have
    tested their monkey patches as extensively as they might have otherwise done for
    plugins; this presents a greater degree of risk if you are using someone else's
    patch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a patch contains a large number of functions, then the impact of changing
    the core functionality is higher and wider; making these changes may break someone
    else's patch or plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ouch! There are serious concerns here! If we face these risks, then why use
    the process at all?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good question; when used judiciously, monkey patching is a useful
    technique to help provide that little extra functionality or correct an issue.
    It can even act as a means of stress testing the code before it is submitted for
    committal. There''s also an argument that says that the functionality should be
    included in a plugin, with good reason:'
  prefs: []
  type: TYPE_NORMAL
- en: Plugins can be released for use by others; they can contribute fixes or updates
    via sites such as GitHub, if the plugin is available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins are likely to work with a wider range of versions of jQuery than a simple
    patch; the latter is likely to be tailored to fix a specific issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing a patch to cover multiple fixes may result in a large file size or
    a lot of changes to the core functionality; this is better managed within the
    framework of a plugin, which can include other functionality, such as internationalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The jQuery Core is moving toward a leaner, faster architecture; adding lots
    of patches will increase the level of redundant functionality and make it less
    appealing for use to other developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key with monkey patching is not to abuse it; it is a valid tool but really
    only effective if you've exhausted all other possible solutions. If you have an
    urgent need for fixing an issue and cannot wait for an official update, then consider
    monkey patching jQuery—just be careful about how you do it!
  prefs: []
  type: TYPE_NORMAL
- en: Distributing or applying patches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once our patch is completed, we need to distribute it; it is tempting to simply
    update a version of jQuery and release that with our plugin or use it within our
    site. There are some disadvantages of using this method though:'
  prefs: []
  type: TYPE_NORMAL
- en: We can't take advantage of our browser's caching capabilities; if we use a cached
    version of jQuery, then it will either not contain our patched code or pull a
    fresh copy from the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patching a copy of jQuery means that we're locked into that version of jQuery.
    This prevents the end user from being able to use their own version of jQuery,
    a CDN link, or even a newer version of jQuery (assuming that the patch still works!).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing a patch to run separately at runtime means that it only patches the
    objects in the source code; if it goes horribly wrong, then we can drop the patch
    and still leave ourselves with a clean (unpatched) version of jQuery. Making changes
    to the source code does not afford us this luxury.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead, there are some alternatives that we can use to apply patches:'
  prefs: []
  type: TYPE_NORMAL
- en: We can simply include our patch in a separate file within our plugin or website—this
    keeps the Core jQuery library clean, although it means a slight overhead of requesting
    the patch file from the server. Users can then simply link to a copy of the file
    from runtime and discard if it circumstances change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patches can also be distributed as a Gist—this makes it independent of our site
    or plugin and allows others to comment or suggest tweaks that can be incorporated
    into our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an example, I''ve created the following Gist for the `replacewebp.js` patch—this
    is available at [https://gist.github.com/alibby251/89765d464e03ed6e0bc1](https://gist.github.com/alibby251/89765d464e03ed6e0bc1)
    and can be linked into projects as a means of distributing the code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can take this a step further if the patch is available within a GitHub repository—either
    as part of an existing project or on its own. GitHub will allow users to submit
    pull requests in order to help improve an existing patch before it is considered
    for submission to core.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is an alternative route that we can take: the patch can be packaged and
    delivered via a frontend package manager, such as Bower ([http://www.bower.io](http://www.bower.io))
    or Jam ([http://www.jamjs.org](http://www.jamjs.org)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on packaging content for download via Bower, please refer
    to [http://bower.io/docs/creating-packages/](http://bower.io/docs/creating-packages/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These are some of the options we can use to distribute our patches; using a
    selection of these means that we can make our patch available to the widest possible
    audience and hopefully benefit from their testing and feedback!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a lot of content in the last few pages, some of which may make
    your head spin, so let's take a breather and consider what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: We kicked off with an introduction to the patching of libraries, such as jQuery,
    and the term duck punching (or monkey patching). We looked at how we can replace
    or modify the existing behavior of jQuery by using this method, before moving
    on to create a basic monkey patch and working through its application to code.
  prefs: []
  type: TYPE_NORMAL
- en: Next up came a look at some of the benefits we can gain by using monkey patches;
    we spoke about the risk involved and some pitfalls that we need to consider when
    creating and applying patches.
  prefs: []
  type: TYPE_NORMAL
- en: We then switched to working through a number of demos that explored some of
    the ways in which we can alter code temporarily, before finishing with a look
    at how we can get our patches out into use for production.
  prefs: []
  type: TYPE_NORMAL
- en: Developing any form of patch or plugin requires well-maintained code if were
    to be successful. In the next chapter, we'll see how we can improve our skills
    in this area, with a look at using design patterns to better organize our code.
  prefs: []
  type: TYPE_NORMAL
