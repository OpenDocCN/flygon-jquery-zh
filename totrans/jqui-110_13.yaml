- en: Chapter 13. Selecting and Sorting with jQuery UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you spend any time working with lists (in an application such as Microsoft
    Excel), then it is possible that you will need to select and sort items into some
    logical order, in a similar fashion to selecting and ordering icons on your computer's
    desktop.
  prefs: []
  type: TYPE_NORMAL
- en: The selectable and sortable interaction helpers in jQuery UI allow you to define
    a series of elements that can be chosen by dragging a selection square around
    them, and then reordered into a new order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics that will be covered in this section include:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the default selectable implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How selectable class names reflect the state of selectable elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering selectable elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with selectables' built-in callback functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A look at selectables' methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a default sortable widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic configurable properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sortables' wide range of built-in event handlers and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting the sorted result to a server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding drag elements to a sortable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting and sorting has been a standard part of modern operating systems for
    a long time. For example, if you wanted to select and sort some of the icons on
    your desktop, you could hold the mouse button down on a blank part of the desktop
    and drag a square around the icons you wanted to select, or select the **Auto
    arrange icons** option from your desktop.
  prefs: []
  type: TYPE_NORMAL
- en: The selectable and sortable interaction helpers add this same functionality
    to our web pages, which allows us to build more user-friendly interfaces without
    needing to use external environments, such as Flash or Silverlight.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the selectable widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we should do is invoke the default implementation to get a glimpse
    of the basic functionality provided by this component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new file in your text editor, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `selectable1.html` in the `jqueryui` folder. We simply call the
    `selectable` widget method on the parent `<ul>` element and then all of its child
    `<li>` elements are made selectable. This allows selection by clicking on them
    or using the selection square (like you would do on your desktop).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there is no styling associated with the selectable component. Default
    behavior includes clicking on individual elements, causing them only to be selected,
    and clicking on one of the selected elements to deselect them. Holding down the
    *Ctrl* key will enable multiselect. The following screenshot shows the selection
    square enclosing the list items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the selectable widget](img/2209OS_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The minimum set of library files we need for a selectable implementation is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jquery-2.0.3.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.core.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.widget.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.mouse.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.selectable.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along with building selectables from list items, we can also build them from
    other elements, such as a collection of `<div>` elements. Add the following link
    to the `<head>` of the `selectable1.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, replace the list elements in `selectable1.html` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `selectable2.html`. Everything is essentially the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: We're just basing the example on different elements. However, due to the nature
    of these elements, we should add a little basic styling so that we can see what
    we're working with.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new file in your text editor, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this as `selectable.css` in the `css` folder. It''s not much, but it helps
    to clarify the individual selectables in the example, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the selectable widget](img/2209OS_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Introducing the Selectee class names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The elements that are made selectable are all initially given the `ui-selectee`
    class, and the parent element that contains them is given the `ui-selectable`
    class. While elements are selected, they are given the `ui-selected` class.
  prefs: []
  type: TYPE_NORMAL
- en: While the selecting square is around selectable elements, they are given the
    `ui-selecting` class, and whilst an element is being deselected it is given the
    `ui-unselecting` class. These classnames are added purely for our benefit, so
    that we can highlight different states that the selectable may be in.
  prefs: []
  type: TYPE_NORMAL
- en: 'This extensive class system makes it very easy to add custom styling to show
    when elements are either in the process of being selected or have been selected.
    Let''s add some additional styling now to reflect the selecting and selected states.
    Add the following new selectors and rules to `selectable.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this `selectableStates.css` in the `css` folder. Change the link to the
    stylesheet reference in the `<head>` of `selectable2.html`, then save this file
    as `selectable3.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With the addition of this very simple CSS, we can add visual cues to elements
    that are part of the current selection, both during and following a select interaction.
    The following screenshot shows some elements in the process of being selected
    on the left, and the same elements having been selected on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the Selectee class names](img/2209OS_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring the selectable component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `selectable` class is quite compact, with relatively few configurable options
    compared to some of the other components that we've looked at.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following options are available for configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Default value | Used to... |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `autoRefresh` | `True` | Automatically refresh the size and position of each
    selectable at the start of a select interaction. |'
  prefs: []
  type: TYPE_TB
- en: '| `cancel` | `":input, option"` | Prevent the specified elements from being
    selected with a click. The default string contains the `:input` jQuery filter,
    which matches all `<input>`, `<textarea>`, `<select>`, and `<button>` elements
    along with the standard option element selector. |'
  prefs: []
  type: TYPE_TB
- en: '| `delay` | `0` | Set the delay in milliseconds before the element is selected.
    The mouse button must be held down on the element before the selection will begin.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `disabled` | `false` | Disable selection when the page initially loads. |'
  prefs: []
  type: TYPE_TB
- en: '| `distance` | `0` | Set the distance the mouse pointer must travel, with the
    mouse button held down, before selection will begin. |'
  prefs: []
  type: TYPE_TB
- en: '| `filter` | `"*"` | Specify child elements to make selectable. |'
  prefs: []
  type: TYPE_TB
- en: '| `tolerance` | `"touch"` | Set the tolerance of the selection square. Possible
    values are `touch` or `fit`. If `fit` is specified the element must be completely
    within the selection square before the element will be selected. |'
  prefs: []
  type: TYPE_TB
- en: Filtering selectables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There may be situations when we don''t want to allow all of the elements within
    the targeted container to be made selectable. In this situation we can make use
    of the `filter` option to nominate specific elements, based on a CSS selector,
    that we want selecting to be enabled on. In `selectable3.html,` change the collection
    of `<div>` elements so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change the final `<script>` element to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The width of each selectable needs to be increased, so in `selectableStates.css`,
    change the `#selectables div` rule to have a width of 190 px.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this version as `selectable4.html`. In the underlying markup, we have
    given a class to each element except for the first. In the JavaScript, we define
    a configuration object containing the `filter` option. The value of this option
    is the class selector of the elements that we want to be selectable; elements
    without this class name are filtered out of the selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Filtering selectables](img/2209OS_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the previous screenshot, the selection square is over the unselectable
    element, but it's not picking up the `ui-selecting` class like the others. The
    component completely ignores the filtered selectable and it does not become part
    of the selection.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling the selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with indirectly making elements unselectable using the `filter` option,
    we can also directly make elements unselectable using the `cancel` option. This
    option was also exposed by the interaction helper we looked at in [Chapter 12](ch12.html
    "Chapter 12. The Resizable Component"), *The Resizable Component*, although we
    didn't look at it in any detail. Now is the perfect opportunity to play with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the class name `unselectable` to the first and second elements in the container
    in `selectable4.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the configuration object from the last example so that it uses the `cancel`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `selectable5.html`. Instead of passing the class name of the selectable
    elements to the configuration object, we pass the class name of the unselectable
    element to it. When we run the example, we can see that the first element, with
    the class name `unselectable`, is still given the class `ui-selectee`. However,
    it is only selectable with the selection square; it cannot be selected by clicking,
    even with the *Ctrl* key held down.
  prefs: []
  type: TYPE_NORMAL
- en: Handling selectable events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the standard configurable options of the selectable API, there
    are also a series of event callback options that can be used to specify functions
    that are executed at specific points during a select interaction. These options
    are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Triggered when |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `selecte` | The select interaction ends and each element added to the selection
    triggers the callback. |'
  prefs: []
  type: TYPE_TB
- en: '| `selecting` | Each selected element triggers the callback during the select
    interaction. |'
  prefs: []
  type: TYPE_TB
- en: '| `start` | A select interaction begins. |'
  prefs: []
  type: TYPE_TB
- en: '| `stop` | A selection operation ends. |'
  prefs: []
  type: TYPE_TB
- en: '| `unselected` | Any elements that are part of the selectable, but are not
    selected during the interaction will fire this callback. |'
  prefs: []
  type: TYPE_TB
- en: '| `unselecting` | Unselected elements will fire this during the select interaction.
    |'
  prefs: []
  type: TYPE_TB
- en: Selecting really only becomes useful when something happens to the elements
    once they have been selected, which is where this event model comes into play.
    Let's put some of these callbacks to work so that we can appreciate their use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the configuration object in `selectable5.html` so that it contains
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `selectable6.html`. In the `<script>`, we've added functions to
    the selected, unselected, start, and stop options. These will be executed at the
    appropriate times during an interaction.
  prefs: []
  type: TYPE_NORMAL
- en: As with other components, these functions are automatically passed two objects.
    The first is the original browser event object (typically called `e`) and the
    other is an object containing useful properties of the selected element (often
    referred to as `ui`). However, not all callbacks can successfully work with the
    second object—start and stop, for example. In our example, we've left out the
    `ui` object; there is no need to include it, as it will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: When a `<div>` is selected, we change its inner text to reflect the selection
    using the `selected` event callback. We can use the `selected` property to get
    the element that was selected in order to change its text content to a new message.
    When an element is deselected, we set the text to `The div was selected` using
    the same technique.
  prefs: []
  type: TYPE_NORMAL
- en: We can also alter the text of any selectable that was previously selected using
    the `unselected` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the start of any interaction, we create a tooltip that is appended to the
    `<body>` of the page, slightly offset from the mouse pointer, using the `start`
    event. We use a basic conditional to check that the tool tip does not already
    exist to prevent duplicate tips. We can make use of the framework classes `ui-corner-all`,
    `ui-widget`, and `ui-widget-header` to do most of the styling for us. The few
    styles we require that are not provided by the theme are added using the `css()`
    method. We can get the pointer coordinates using the `e` (event) object, which
    is passed as the first argument to our callbacks, in order to position the tool
    tip. At the end of the selection, we remove the tool tip using the `stop` property.
    The following screenshot shows the results of different interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling selectable events](img/2209OS_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `selecting` and `unselecting` callback options work exactly the same way
    as those we have just looked at, but are fired as elements are added or removed
    to the selection. To see those in action, replace the `selected` and `unselected`
    options in the configuration object in `selectable6.html` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Save your work as `selectable7.html`. This time we use the `selecting` and `unselecting`
    properties to specify callback functions, which again change the text content
    of the elements at certain times during an interaction. We repeat the procedure
    from the last example, this time we're just using different callbacks and properties
    of the objects passed to them.
  prefs: []
  type: TYPE_NORMAL
- en: The second object passed to any of the selectable callbacks contains a property
    relating to the type of custom event. For example, the selected callback receives
    an object with a `selected` property, which can be used to gain information about
    the element that was added to the selection. All callbacks have a matching property
    that can be used in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Working with vast amounts of selectables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The jQuery UI library, such as jQuery itself, is already extremely efficient.
    It uses the ultra-effective **Sizzle selector engine** (via jQuery) and each component
    has been optimized as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sizzle is a pure JavaScript CSS Selector engine, used by jQuery, which allows
    you to use JavaScript on CSS selectors, such as `$("<div>")`. If you would like
    to learn more, you can visit the project site at [http://sizzlejs.com/](http://sizzlejs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: However, there is only so much that the creators of the library can do. In our
    examples so far, we've used a maximum of five selectable elements, which aren't
    really many at all. What if we were to use 500 instead?
  prefs: []
  type: TYPE_NORMAL
- en: When working with great numbers of selectables there is still something we can
    do to make sure that the select interactions are as efficient as possible. The
    `autoRefresh` option is set to `true` by default, which causes the sizes and positions
    of all selectable elements on the page to be recalculated at the beginning of
    every interaction.
  prefs: []
  type: TYPE_NORMAL
- en: This can cause delays on pages with many selectable elements on it, so the `autoRefresh`
    option can be set to `false` when dealing with large collections of elements.
    We can also use the `refresh` method to manually refresh the selectables at appropriate
    times in order to improve the speed and responsiveness of the interactions. On
    most pages we would not need to worry about configuring this option and can leave
    it at its default setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how this option can help our pages in certain situations.
    In the `<head>` of `selectable7.html` change the `<link>` for the custom stylesheet
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change the selectables container element so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to use a little jQuery to create our selectable elements automatically,
    so replace the existing script in `document.ready()` block with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Save this page as `selectable8.html`. Our page should now contain 100 individual
    selectables within the selectables container. We've also added a class name to
    the outer container so that the container is cleared properly when we float our
    selectables (which we will do in a moment). If the container is not cleared correctly,
    the selection square will not work. We added the `.ui-helper-clearfix` class to
    our selectables `div` to help cure this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a new stylesheet in this example that consists of the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Save this in the `css` folder as `selectableMany.css`. It's purely for layout
    purposes, so we don't need to discuss it further.
  prefs: []
  type: TYPE_NORMAL
- en: We can use something like Chrome's Developer Tools to profile a selection of
    all 100 selectables with and without the `autoRefresh` option enabled; it's enabled
    by default, so our example will disable it. The results will probably vary between
    tests, but you should find that the profile (in both milliseconds and the number
    of calls) is consistently lower with `autoRefresh` set to disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**How do I profile JavaScript performance?**'
  prefs: []
  type: TYPE_NORMAL
- en: For details of how to perform profiling in a browser such as Chrome, you can
    view a useful tutorial at [https://developers.google.com/chrome-developer-tools/docs/cpu-profiling](https://developers.google.com/chrome-developer-tools/docs/cpu-profiling).
  prefs: []
  type: TYPE_NORMAL
- en: Working with selectable methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The methods that we can use to control the selectables component from our code
    are similar to the methods found in other interaction helpers and follow the same
    pattern of usage. The only unique method exposed by the selectables component
    is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Refresh` | Manually refreshes the positions and sizes of all selectables.
    Should be used when `autoRefresh` is set to `false`. |'
  prefs: []
  type: TYPE_TB
- en: In addition to this unique method, the selectables component (like every other
    component) makes use of the common API methods `destroy`, `disable`, `enable`,
    `option`, and `widget`.
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing selectables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting the `autoRefresh` property to `false` can yield performance gains when
    there are many selectables on the page, especially in Internet Explorer. However,
    there will still be times when you will need to refresh the size and positions
    of the selectables, such as when this component is combined with the draggables
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `refresh` method as it leads on perfectly from the
    last example. Add the following new `<button>` element directly after the selectables
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need to link to the draggable source file for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change the final `<script>` element so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `selectable9.html`. We've added a new `<button>` to the page and
    we now link to the draggable source file as well as the selectable's. Each of
    the 100 elements is made both draggable and selectable.
  prefs: []
  type: TYPE_NORMAL
- en: Our click handler that is attached to the `<button>` will simply call the `refresh`
    method manually on the selectables container. When we run the page in a browser
    we should first select some, but not all, of the selectable widgets. We should
    then deselect the elements and move some of them around. We can move other elements
    that weren't selected into the selection group as well. Really shuffle them up!
  prefs: []
  type: TYPE_NORMAL
- en: 'When we try to select the same group again, we find that the wrong elements
    are being selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refreshing selectables](img/2209OS_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The component hasn't refreshed the positions of the selectables, so it still
    thinks that all of the selectables are in the same place as they were when the
    first selection was made. If we click on the **refresh** button and make a third
    selection, the correct elements will now be selected.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a selectable image viewer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our final selectable example, we're going to make a basic image viewer. Images
    can be chosen for viewing by selecting the appropriate thumbnail. Although this
    sounds like a relatively easy achievement, in addition to the actual mechanics
    of displaying the selected image, we'll also need to consider how to handle multiple
    selections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of what we''ll end up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a selectable image viewer](img/2209OS_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s get started with the code. In a fresh page in your text editor, add
    the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `imageSelector.html`. On the page, we have a parent `<div>` with
    an `id` of `imageSelector` into which all of our other elements go.
  prefs: []
  type: TYPE_NORMAL
- en: Within the parent, we have a `<div>` that will act as a status bar to display
    the names of individually selected images, and a `<div>` that will act as the
    viewing panel and will display the full-sized version of the image. Finally, we
    have our thumbnail images, which will be made selectable.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next we need to add the script that makes the image selector work, so directly
    after the final `<script>` element add the following code; throughout this section,
    we''ll walk through the code block by block, beginning with the configuration
    object for the selectables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We use the `stop callback` function to do some prep work, such as removing the
    contents of the image selector container (except for the thumbnails) and creating
    an empty viewer container. We then use an `if` conditional to call either the
    `singleSelect()` or `multiSelect()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We then define the first of two functions, which is `singleSelect()`. This will
    be invoked every time a single thumbnail is selected. We first cache the `id`
    of the selected element; we'll be referring to this several times, so it's more
    efficient to store it in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Next we create a new status bar and set its `innerText` to the `id` value that
    was cached a moment ago, which will be the `id` attribute of whichever thumbnail
    is selected. We give the new element some of the framework classes to style the
    element and then insert it into the image selector container.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we do in this function is to create the full-sized version of
    the thumbnail. To do this, we create a new image and set its `src` attribute to
    match the large version of the thumbnail that was selected (both the large and
    thumbnail versions of each image have the same filename). The full-size image
    is then inserted into the viewer container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next we define the `multiSelect()` function, which is called when multiple thumbnails
    are selected. This time we start by creating a new `<div>` element, give it an
    `id` of tabs and insert it before the viewer container. Following this, we create
    a new `<ul>` element, as this is a required component of the tabs widget (which
    we looked at in [Chapter 3](ch03.html "Chapter 3. Using the Tabs Widget"), *Using
    the Tabs Widget*). This element is appended to the tabs container we created a
    moment ago.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We then use jQuery's `each()` method to iterate over each of the thumbnails
    that were selected. For each item we create a series of variables, which will
    hold the different elements that make up the tab headings. We cache the `id` attribute
    of each image and create a new `<li>` and a new `<a>` element. The link will form
    the clickable tab heading and is given the `id` of the thumbnail as its text content.
  prefs: []
  type: TYPE_NORMAL
- en: We then create the new tab panel that will match the tab heading that we just
    created. Notice that we create a unique `id` for the content panel based on the
    thumbnail's `id` attribute and some hardcoded text. Note that the `id` will precisely
    match the `href` attribute that we set on the `<a>` element. Each new image is
    created in the same way as in the `singleSelect()` function.
  prefs: []
  type: TYPE_NORMAL
- en: After the `each()` method, we set a CSS property on the viewer container to
    tidy up its appearance and then append it to the tabs container. Finally the `tabs()`
    method is called on the tabs container, transforming it into the tabs widget.
    At the end of the script the thumbnails are made selectable.
  prefs: []
  type: TYPE_NORMAL
- en: Styling the image selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our example is also heavily reliant on CSS to provide its overall appearance.
    In a new file in your text editor, create the following new stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Save this in the `css` folder as `selectableViewer.css`. Most of the styles
    are arbitrary and are required purely for layout or visual appearance. We're using
    some of the framework classes in our mark up in order to add the rounded corners,
    so the amount of CSS we need to write is minimal. The last few selectors are required
    in order to override some of the tab widget's default styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the example in a browser, we should see something similar to what
    is shown in the previous screenshot. When a single thumbnail is selected the full-size
    version of the image will be displayed. When multiple images have been selected,
    tabs are recreated at the top of the viewer, which allow all of the selected images
    to be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling the image selector](img/2209OS_13_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting started with the sortable widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final interaction helper that we're going to look at is the sortables component.
    This component allows us to define one or more list of elements (not necessarily
    actual `<ul>` or `<ol>` elements), where the individual items in the list(s) can
    be reordered by dragging. The sortables component is like a specialized implementation
    of drag-and-drop, with a very specific role. It has an extensive API, which caters
    for a wide range of behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic sortable list can be enabled with no additional configuration. Let''s
    do this first, so that you can get an idea of the behavior enabled by this component.
    In a new file in your text editor, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this as `sortable1.html`. On the page, we have a simple unordered list
    with five list items. Thanks to the sortables component, we should find that the
    individual list items can be dragged to different positions in the list, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with the sortable widget](img/2209OS_13_8A.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Code-wise, the default implementation is the same as it has been for each of
    the other components. We simply call the sortable widget method on the parent
    `<ul>` element of the list items that we want to make sortable.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of behaviors are added to the page to accommodate this functionality.
    As we drag one of the list items up or down in the list, the other items automatically
    move out of the way, creating a slot for the item that is currently being sorted
    to be dropped on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, when a sortable item is dropped, it will slide quickly, but smoothly
    into its new position in the list. The library files that were needed for the
    basic implementation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jquery-2.0.3.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.core.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.widget.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.mouse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jquery.ui.sortable.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As I mentioned earlier, the sortables component is a flexible addition to the
    library that can be applied to many different types of elements. For example,
    instead of using a list, we could use a series of `<div>` elements as the sortable
    list items, in place of the `<ul>` element in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This can be saved as `sortable2.html`. As you can see, the behavior exhibited
    by this version is exactly the same as it was before. All that's changed is the
    underlying markup. We've added some of the CSS framework classes in order to add
    some basic styling to our elements, and we can also use a custom stylesheet to
    add a few extra styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file and add the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this in the `css` folder as `sortable.css`. Link to the CSS file in the
    `<head>` of `sortable2.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With our new stylesheet, the page should now appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with the sortable widget](img/2209OS_13_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Styling the sortable widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have styled our first set of sortable elements, it's a good point
    in journey at which to examine the style classes used by the sortable widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sortable widget uses a number of styles. They are shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class name | Used to… |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ui-widget ui-sortable` | Used on the container element; this first sets
    the generic classes from `ui-widget`, followed by those in `ui-sortable`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ui-widget-header` | Style each sortable element; this is by default with
    rounded corners, using the `ui-corner-all` style. |'
  prefs: []
  type: TYPE_TB
- en: '| `ui-sortable-helper –` | Show a clone of the element being sorted, during
    the dragging process. |'
  prefs: []
  type: TYPE_TB
- en: '| `ui-sortable-placeholder –` | Act as the placeholder element, ready to accept
    the element being sorted. This is hidden by default, but can be changed, as we
    will see later in the chapter. |'
  prefs: []
  type: TYPE_TB
- en: Configuring sortable options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sortables component has a huge range of configurable options, much more
    than any of the other interaction components (but not as many as some of the widgets).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the range of options at our disposal:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Default value | Used to… |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `appendTo` | `"parent"` | Set the element that helpers are appended to, during
    a sort. |'
  prefs: []
  type: TYPE_TB
- en: '| `axis` | `false` | Constrain sortables to one axis of movement. Possible
    values are the strings x or y. |'
  prefs: []
  type: TYPE_TB
- en: '| `cancel` | `":input, button"` | Specify elements that cannot be sorted, if
    they are the elements being sorted. |'
  prefs: []
  type: TYPE_TB
- en: '| `connectWith` | `false` | Enable one-way sorting from the current list to
    the specified list. |'
  prefs: []
  type: TYPE_TB
- en: '| `containment` | `false` | Constrain sortables to their container while they
    are being sorted. Values can be the string''s parent, window, or document, or
    can be a jQuery selector or element node. |'
  prefs: []
  type: TYPE_TB
- en: '| `cursor` | `"auto"` | Define the CSS cursor to apply while dragging a sortable
    element. |'
  prefs: []
  type: TYPE_TB
- en: '| `cursorAt` | `false` | Specify the coordinates that the mouse pointer should
    be at, while a sort is taking place. Accepts an object with the keys `top`, `right`,
    `bottom`, or `left` with integers as the values. |'
  prefs: []
  type: TYPE_TB
- en: '| `delay` | `0` | Set the time delay in milliseconds before the sort begins,
    once a sortable item has been clicked (with the mouse button held down). |'
  prefs: []
  type: TYPE_TB
- en: '| `disabled` | `false` | Disable the widget on page load. |'
  prefs: []
  type: TYPE_TB
- en: '| `distance` | `1` | Set how far in pixels the mouse pointer should move, while
    the left button is held down before the sort begins. |'
  prefs: []
  type: TYPE_TB
- en: '| `dropOnEmpty` | `true` | Allow linked items from linked sortables to be dropped
    onto empty slots. |'
  prefs: []
  type: TYPE_TB
- en: '| `forceHelperSize` | `false` | Force the `helper` to have a size when set
    to `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `forcePlaceholderSize` | `false` | Force the `placeholder` to have a size
    when set to `true`. The placeholder is the empty space that a sortable can be
    dropped on to. |'
  prefs: []
  type: TYPE_TB
- en: '| `grid` | `false` | Set sortables to snap to a grid while being dragged. Accepts
    an array with two items—the x and y distances between gridlines. |'
  prefs: []
  type: TYPE_TB
- en: '| `handle` | `false` | Specify an element to be used as the drag handle on
    sortable items. Can be a selector or an element node. |'
  prefs: []
  type: TYPE_TB
- en: '| `helper` | `original"` | Specify a helper element that will be used as a
    proxy, while the element is being sorted. Can accept a function that returns an
    element. |'
  prefs: []
  type: TYPE_TB
- en: '| `items` | `">*"` | Specify the items that should be made sortable. The default
    makes all children sortable. |'
  prefs: []
  type: TYPE_TB
- en: '| `opacity` | `false` | Specify the CSS opacity of the element being sorted.
    Value should be an integer from `0.01` to `1`, with `1` being fully opaque. |'
  prefs: []
  type: TYPE_TB
- en: '| `placeholder` | `false` | Specify a CSS class to be added to empty slots.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `revert` | `false` | Enable animation when moving sortables into their new
    slots, once they have been dropped. |'
  prefs: []
  type: TYPE_TB
- en: '| `scroll` | `true` | Enable page scrolling when a sortable is moved to the
    edge of the viewport. |'
  prefs: []
  type: TYPE_TB
- en: '| `scrollSensitivity` | `20` | Set how close a sortable must get, in pixels,
    to the edge of the viewport, before scrolling should begin. |'
  prefs: []
  type: TYPE_TB
- en: '| `scrolSpeed` | `20` | Set the distance in pixels that the viewport should
    scroll, when a sortable is dragged within the sensitivity range. |'
  prefs: []
  type: TYPE_TB
- en: '| `tolerance` | `"intersect"` | Control how much of the element being sorted
    must overlap other elements, before the placeholder is moved. Another possible
    value is the string pointer. |'
  prefs: []
  type: TYPE_TB
- en: '| `zIndex` | `1000` | Set the CSS `zIndex` of the `sortable` or `helper`, while
    it is being dragged. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s work some of these properties into our previous example to get a feel
    for the effect they have on the behavior of the component. First wrap the `#sortables`
    container in a new `<div>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change the final `<script>` element in `sortable2.html`, so that it appears
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this as `sortable3.html`. We also need to add a little padding to our
    new container element. Update `sortable.css`, so that it contains the following
    new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Resave this file as `sortableContainer.css` and update the `<link>` in the `<head>`
    of `sortable3.html`, so that it points to the new stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use four options in our configuration object: `axis`, `containment`, `resize,`and
    `distance`. Let''s take a look at the role they perform:'
  prefs: []
  type: TYPE_NORMAL
- en: The `axis` option is set to `y`, to constrain the motion of the sortable currently
    being dragged to just up-and-down.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `containment` option specifies the element that the sortables should be
    contained within, to limit the bounds of their movement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cursor` option that automatically adds the CSS `ns-resize` cursor. In a
    similar fashion to the draggable component that we looked at in [Chapter 11](ch11.html
    "Chapter 11. Drag and Drop"), *Drag and Drop*, the cursor is not actually displayed
    until the sort begins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `distance` option is configured with a value of `30`, which specifies that
    the mouse pointer should move `30` pixels before the sort begins. It works in
    the same way with sortables as it did with draggables, and is great for preventing
    unwanted sorts, but in practice, we'd probably use a much lower threshold than
    30 pixels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sortable spacing**'
  prefs: []
  type: TYPE_NORMAL
- en: Care should be taken when using the `containment` option. This is specifically
    why we added some padding to the container element in our stylesheet. Without
    this padding, the first sortable element is flushed against the top of the container
    and the last element is flushed against the bottom. In order to be able to push
    a sortable element out of the way, there must be some space above or below it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some more options. In this next example, we'll adapt the code
    from `sortable3.html` to restrict the handle of each item to a specific part of
    the item. We will also prevent jQuery UI from allow sorting until a certain time
    has passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the underlying `<div>` elements in `sortable3.html`, so that they appear
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get rid of the `#container` element for this example. We also need a
    modified stylesheet for this example. Change `sortable.css`, so that it includes
    the following new styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Save the new stylesheet as `sortableHandles.css` in the `css` folder and update
    the `<link>` element to point to the new stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, change the configuration object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `sortable4.html`. We've made a slight change to the page. Within
    each sortable element is a new `<span>` element that will be used as the sort
    handle. We give this element some CSS Framework classes in order to reduce the
    CSS we need to add manually.
  prefs: []
  type: TYPE_NORMAL
- en: The `revert` option has a default value of `true`, but can also take one of
    the speed integer or string values (`slow`, `normal`, or `fast`) that we've seen
    in other animation options in other components.
  prefs: []
  type: TYPE_NORMAL
- en: The `delay` option accepts a value in milliseconds that the component should
    wait, before allowing the sort to begin. If the mouse pointer is moved away from
    the handle while the left-button is held down, the sort will still occur after
    the specified time. If the mouse-button is released, however, the sort will be
    canceled.
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `opacity` option is used to specify the CSS opacity of the
    element that is being sorted, while the sort takes place. The value should be
    a floating-point number between `0` and `1`, with `1` corresponding to full opacity
    and `0` specifying no opacity.
  prefs: []
  type: TYPE_NORMAL
- en: Another option we've used is the `handle` option, which allows us to define
    a region within the sortable that must be used to initiate the sort. Dragging
    on other parts of the sortable will not cause the sort to begin.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see how the handle will appear in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring sortable options](img/2209OS_13_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Make my handles bigger**'
  prefs: []
  type: TYPE_NORMAL
- en: For usability reasons, we should probably use a bigger handle than the one used
    in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Placeholders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A placeholder defines the empty space or slot that is left, while one of the
    sortables is in the process of being moved to its new position. The placeholder
    isn't rigidly positioned. It will dynamically move to whichever sortable has been
    displaced by the movement of the sortable that is being sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options that are specifically concerned with placeholders the
    very aptly named `placeholder` option and the `forcePlaceholderSize` option. Let''s
    take a look at these two options in action. Remove the `<span>` elements from
    the sortable `<div>` elements in `sortable4.html` and then change the configuration
    object, so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this as `sortable5.html`. Next, we should add the new selector and rules
    to a CSS file. Change `sortable.css`, so that it contains the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `sortablePlaceholder.css` in the `css` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `placeholder` option allows us to define a CSS class that should be added
    to the placeholder element. This is a useful property that we can use often in
    our implementations. Remember this is a class name, not a class selector, so no
    period is used at the start of the string. It can accept multiple classnames.
  prefs: []
  type: TYPE_NORMAL
- en: The `forcePlaceholderSize` option ensures that the placeholder is the same size
    as the actual sortables. If we left this option at its default value of `false`,
    in this example, the placeholder would just be a thin line made up of the padding
    that we applied to the sortable `<div>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the new HTML file in a browser, we should be able to see the specified
    styles applied to the placeholder, while the sort is taking place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Placeholders](img/2209OS_13_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sortable helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We looked at helper/proxy elements back when we looked at the draggables component
    earlier in the book. Helpers can also be defined for sortables that function in
    a similar way to those of the draggable component, although there are some subtle
    differences in this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: With sortables, the original sortable is hidden when the sort interaction begins,
    and a clone of the original element is dragged instead. So with sortables, helpers
    are an inherent feature.
  prefs: []
  type: TYPE_NORMAL
- en: Like with draggables, the `helper` option of sortables may take a function as
    its value. The function, when used, will automatically receive the `event` object
    and an object containing useful properties from the sortable element as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function must return the element to use as a helper. Although it''s very
    similar to the draggable helper example, let''s take a quick look at it when used
    in conjunction with sortables. In `sortable5.html`, change the last `<script>`
    block, so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Save this file as `sortable6.html`. We define a `helperMaker` function that
    creates and returns the element to be used as the helper, while the sort is in
    progress. We set some basic CSS properties on the new element, so that we don't
    need to provide additional rules in the stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how the helper will appear while a sort is taking
    place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sortable helpers](img/2209OS_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sortable items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, all children of the element that the method is called on are turned
    into sortables. While this is a useful feature of the component, there may be
    times when we don't necessarily want all child elements to become sortable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `items` option controls which child elements of the specified element should
    be made sortable. It makes all child elements sortable using the string `>*` as
    its default value, but we can alter this to specify only the elements we want.
    Change the sortable `<div>` elements in `sortable6.html`, so that the last element
    has a new class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the configuration object to make use of the `items` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `sortable7.html`. In the `<script>`, we've specified the selector
    `">:not(.unsortable)"` as the value of the `items` option, so the element with
    the classname `unsortable` will not be made sortable, while the rest of the `<div>`
    elements will.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the page in a browser, we should find that the last item in the
    collection cannot be sorted, and other sortable items cannot be moved into the
    space that the last item occupies.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, the examples that we have looked at have all centered on a single list
    of sortable items. What happens when we want to have two lists of sortable items,
    and more importantly, can we move items from one list to another?
  prefs: []
  type: TYPE_NORMAL
- en: Having two sortable lists is of course extremely easy and involves simply defining
    two containers and their child elements, and then passing a reference to each
    container to the `sortable()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing separate lists of sortables to exchange and share sortables is also
    extremely easy. This is thanks to the `connectWith` option, which allows us to
    define an array of sortable containers, who can share their sortable contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this in action. Change the underlying markup on the page, so
    that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything on the page is pretty similar to what we have worked with before.
    We also need a new stylesheet for this example. In a new file, add the following
    styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this as `sortableConnected.css` in the `css` folder. Don''t forget to
    point to the new stylesheet in the `<head>` of the new page. Finally, change the
    last `<script>` element, so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `sortable8.html`. We still define a single configuration object,
    which can be shared between both sets of sortable elements. The `connectWith`
    option is able to accept multiple selectors if they are passed in as an array,
    and it's this option that allows us to share individual sortables between the
    two sortable containers.
  prefs: []
  type: TYPE_NORMAL
- en: This configuration option only provides a one-way transmission of sortables,
    so if we were to only use the configuration object with `sortablesA` and specify
    just the selector `#sortablesB`, we would only be able to move items from `sortablesA`
    to `sortablesB`, not the other way.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying both sortables' `id` attributes in the option and selecting both
    of the containers when calling the `sortable()` method allows us to move items
    between both elements, and allows us to cut down on coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the page in a browser, we find that not only can the individual
    items be sorted in their respective elements, but that items can also be moved
    between elements, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting lists](img/2209OS_13_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reacting to sortable events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the already large list of configurable options defined in the
    sortables class, there are also a whole lot more in the form of event callbacks,
    which can be passed as functions to execute at different points during a sortable
    interaction. These are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event | Fired when… |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `activate` | Sorting starts on a connected list. |'
  prefs: []
  type: TYPE_TB
- en: '| `beforeStop` | The sort has stopped, but the original slot is still available.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `change` | The DOM position of a sortable has changed and the sort is still
    in progress. |'
  prefs: []
  type: TYPE_TB
- en: '| `create` | The widget is initialized. |'
  prefs: []
  type: TYPE_TB
- en: '| `deactivate` | Sorting stops on a connected list. |'
  prefs: []
  type: TYPE_TB
- en: '| `out` | A sortable is moved out of a connected list. |'
  prefs: []
  type: TYPE_TB
- en: '| `over` | A sortable is over a connected list. This is great for providing
    visual feedback while a sort is taking place. |'
  prefs: []
  type: TYPE_TB
- en: '| `receive` | A sortable is received from a connected list. |'
  prefs: []
  type: TYPE_TB
- en: '| `remove` | A sortable is moved from a connected list. |'
  prefs: []
  type: TYPE_TB
- en: '| `sort` | A sort is taking place. |'
  prefs: []
  type: TYPE_TB
- en: '| `start` | A sort starts. |'
  prefs: []
  type: TYPE_TB
- en: '| `stop` | A sort ends. |'
  prefs: []
  type: TYPE_TB
- en: '| `update` | The sort has ended and the DOM position has changed. |'
  prefs: []
  type: TYPE_TB
- en: Each of the components that we've looked at in the preceding chapters has defined
    its own suite of custom events, and the sortables component is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of these events will fire during any single sort interaction. The following
    list shows the order in which they will fire:'
  prefs: []
  type: TYPE_NORMAL
- en: start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: beforeStop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: stop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As soon as one of the sortables is picked up, the `start` event is triggered.
    Following this, on every single mouse move, the `sort` event will fire, making
    this event very intensive.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as another item is displaced by the current sortable, the `change` event
    is fired. Once the sortable is dropped, the `beforeStop` and `stop` events fire,
    and if the sortable is now at a different position, the `update` event is fired
    last of all.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next few examples, we''ll work some of these event handling options
    into the previous example, starting with the `start` and `stop` events. Change
    the configuration object in `sortable8.html`, so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `sortable9.html`. Our event usage in this example is minimal. When
    the sort starts, we simply create a new paragraph element and add some text to
    it, including the text content of the element that is being sorted. The text message
    is then duly appended to the `<body>` of the page. When the sort stops, we remove
    the text. Using the second object passed to the callback function is very easy,
    as you can see. The object itself refers to the parent sortables container, and
    the `helper` property refers to the actual item being sorted (or its helper).
    As this is a jQuery object, we can call jQuery methods, such as `text`, on it.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the page, the message should appear briefly until the sort ends,
    at which point it's removed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reacting to sortable events](img/2209OS_13_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at one more of these simple callbacks, before we move on to look
    at the additional callbacks used with connected sortables. In our next example,
    we will take a look at how we can track movement of sortable items between lists,
    and use a callback function to display the results on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the final `<script>` element in `sortable9.html` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `sortable10.html`. In this example, we work with the `receive`
    and `beforeStop` callbacks to provide a message, indicating the position within
    the list that any sortable is moved to, as well as which list it is in. We also
    make use of the `ui.item` property from the object, which is automatically passed
    to any callback functions used by the events.
  prefs: []
  type: TYPE_NORMAL
- en: We first define a variable called `extraMessage`, which is initially set to
    an empty string. We then define a function called `getPlaces`. This function will
    be used as a callback function for sortable events and will, therefore, automatically
    receive `e` and `ui` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Within the function, we first check whether the event object's type property
    has a value of `sortreceive`; if it does, we know that a sortable has moved lists
    and can, therefore, set the extra part of the message.
  prefs: []
  type: TYPE_NORMAL
- en: We then remove any pre-existing messages, before creating a new `<p>` element
    and setting a message, indicating its new position in the list. We can obtain
    the new position of the element that was sorted using the `item` property of the
    second object passed to our callback in conjunction with jQuery's `index()` method,
    which we convert to a string and concatenate into a message.
  prefs: []
  type: TYPE_NORMAL
- en: In our configuration object, we connect the two lists using the `connectWith`
    option as before, and make use of both the `receive` and `beforeStop` options,
    which both point to our `getPlaces` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `receive` event is fired whenever a sortable container receives a new sortable
    element from a connected list. The `beforeStop` event is fired just before the
    sort interaction ends. In terms of event order, in this example the `beforeStop`
    event is fired first, followed by the `receive` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `receive` event will only be fired if a sortable element moves to a new
    sortable container. The following screenshot shows how the page should look following
    a sort interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reacting to sortable events](img/2209OS_13_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Six of the available callbacks can be used in conjunction with connected sortables.
    These events fire at different times during an interaction, alongside the events
    that we have already looked at.
  prefs: []
  type: TYPE_NORMAL
- en: Like the standard unconnected events, not all of the connected events will fire
    in any single interaction. Some events, such as `over`, `off`, `remove`, and `receive`
    will fire only if a sort item moves to a new list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other events, such as `activate` and `deactivate`, will fire in all executions,
    whether any sort items change lists or not. Additionally, some connected events,
    such as `activate` and `deactivate`, will fire for each connected list on the
    page. Provided at least one item is moved between lists, events will fire in the
    following order:'
  prefs: []
  type: TYPE_NORMAL
- en: start
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: activate
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: sort
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: change
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: beforeStop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: stop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: remove
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: update
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: receive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: deactivate
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now see some of these connected events in action. Change the final `<script>`
    element in `sortable10.html`, so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `sortable11.html`. The `activate` and `deactivate` events are fired
    for each connected list at the start of any sort interaction. Within our callback
    functions, `$(this)` refers to each sortable container. We can easily determine
    which sortable list the item originated in using the `sender` property of the
    second object, passed to our function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the page in a browser, we see that as soon as a sort begins, both
    of the sortables are activated, and when the sort ends, both of them are deactivated.
    If an item is moved between lists, the message generated by the `receive` callback
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting callbacks](img/2209OS_13_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Listing the sortable methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sortables component exposes the usual set of methods for making the component
    perform actions. Like the selectables component that we looked at before, it also
    defines a couple of unique methods not seen in any of the other components. The
    following table lists sortables'' unique methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Used to… |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cancel` | Cancel the sort and cause elements to return to their original
    positions. |'
  prefs: []
  type: TYPE_TB
- en: '| `refresh` | Reload the set of sortables. |'
  prefs: []
  type: TYPE_TB
- en: '| `refreshPositions` | Trigger a cache refresh of the set of sortables. |'
  prefs: []
  type: TYPE_TB
- en: '| `serialize` | Construct a query string that can be used to send a new sort
    order to the server, for further processing or storage. |'
  prefs: []
  type: TYPE_TB
- en: '| `toArray` | Serialize the sortables into an array of strings. |'
  prefs: []
  type: TYPE_TB
- en: Serializing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `serialize` and `toArray` methods are great for storing the new order of
    the sortables. Let's see this in action. We will create a series of sortable elements,
    and then set Sortable to display their order. This will be updated on screen each
    time you move one of the elements around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the underlying markup on the `<body>` of the page in `sortable11.html`
    to as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change the final `<script>` element, so that it appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `sortable12.html`. We've dropped the second set of sortables for
    this example and have added `id` attributes to each of the sortable items in the
    format of the name of the parent sortable and a number, separated by an underscore.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `stop` event to execute an anonymous function, after each sort interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this function, we store the result of the `serialize` method in the
    `order` variable, and then display this variable in a new `<p>` element on the
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Serializing](img/2209OS_13_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the format of the serialized string is quite straightforward.
    The sortable items appear in the order that the items appear on the page, and
    are separated by an ampersand. Each serialized item is made up of two parts: a
    hash of the `id` attribute of each sortable item followed by an integer representing
    the item''s new order.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, all we do is display the serialized string on the page,
    but the string is in the perfect format for use with jQuery's `ajax` method to
    pass to a server for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `serialize` method is also able to accept a configuration object to tailor
    how the serialization occurs. The options we can configure are listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Default value | Used to… |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `attribute` | `id` | Specify the attribute to use when parsing each item
    in the list of sortables and generating the hash. |'
  prefs: []
  type: TYPE_TB
- en: '| `connected` | `false` | Include all connected lists in the serialization.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `expression` | `"(.+)[-=_](.+)"` | Specify the `regexp` to use to parse the
    sortable list. |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | `The first part of the id attribute of each sortable item` | Specify
    the string to be used as the first part of each item in the serialized output.
    |'
  prefs: []
  type: TYPE_TB
- en: The `toArray` method works in a similar way to serialize, except that with `toArray`,
    the output is not a string, but an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring widget compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw that both the resizable and the selectable
    components worked well with the tabs widget (and we already know how well the
    dialog and resizables components go together). The sortable component is also
    highly compatible with other widgets. Let''s look at a basic example. In a new
    file in your text editor, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Save this page as `sortable13.html`. There is nothing in the code that we haven't
    seen before, so we won't go into any great detail about it. Note that only the
    `tabs()` and `sortable()` methods are called on the same element—the outer containing
    the `<div>` element.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the page in a browser, we should find that the components work in
    exactly the way that we want them to. The tabs can be sorted horizontally to any
    order, but as the tabs are linked to their panel by `href`, they will still show
    the correct panel, when selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting the tabs works on the `mousedown` event and selecting the tabs works
    on the `mouseup` event, so there are no event collisions and no situations arising
    where you want to select a tab, but end up sorting it. The following screenshot
    shows how the tabs may appear after sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring widget compatibility](img/2209OS_13_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding draggables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we looked at draggables and droppables, earlier in the book, we saw that
    there was a configuration option for draggables called `connectToSortable`. Let's
    take a look at that option now that we've been introduced to the fundamentals
    of the sortables component. In this example, we'll create a sortable task list
    that can have new tasks dragged into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting page will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding draggables](img/2209OS_13_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a new file in your text editor, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this as `sortable14.html`. On the page, we have a couple of `<ul>` elements:
    the first contains a single item that provides an instruction to the visitor and
    the second is the task list. The second list is wrapped in a container `<div>`,
    mostly for styling purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also use a new stylesheet for this example. Add the following code to a
    new page in your text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Save this as `sortableTasks.css` in the `css` folder. Mostly this is just decorative,
    superficial stuff for the purposes of the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can add the script that wires it all up. Add the following `<script>`
    element, after the library resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We first cache a couple of selectors that we''ll be using frequently throughout
    the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We then define and initialize the configuration object for the sortables. Sorting
    is restricted to the vertical axis and a callback function specified for the `stop`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: Within this function, we hide the `add` button and reset any text that has been
    added to the draggable, then use the `option` method of the draggable to disable
    dragging on the element, so that the text label cannot be dragged into the task
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, when we set the disabled option of the draggable, it adds a CSS
    framework class that reduces the opacity of the draggable. This is not necessary
    for our example, so we also remove this class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, we define and initialize the draggable configuration object
    and set the `connectToSortable` option to an `id` selector that matches the parent
    sortables container, and the `helper` option to clone. The dragging is initially
    disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create two helper functions: the first to count the number of items
    in the list, and the second to work out if the `<input>` field has any content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a click handler to the draggable element using jQuery''s `on()` method.
    When the draggable `<li>` is clicked, it checks that there aren''t too many tasks
    in the list already, and if not, it will create a new `<input>` field and append
    it to the `<li>` in the first `<ul>`. The hidden `add` button is also displayed.
    The visitor can then enter a new task and make the new task draggable, by clicking
    on the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We also add a click handler for the `add` button that we create, again using
    jQuery's `on()` method. This function checks that the `<input>` contains some
    text, and provided it does, it then gets the text and then removes the `text`
    field. The text is then added to the draggable `<li>` element, and the `<li>`
    is made draggable by setting the `disabled` option to `false`. Finally, the `<input>`
    is removed, and the message and button are set back to their original state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The text box and icon will appear as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding draggables](img/2209OS_13_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We also add a click handler for the `add` button that we create, again using
    jQuery's `on()` method. This function checks that the `<input>` contains some
    text, and provided it does, it then gets the text and then removes the `text`
    field. The text is then added to the draggable `<li>` element, and the `<li>`
    is made draggable by setting the `disabled` option to `false`. Finally, the `<input>`
    is removed, and the message and button are set back to their original state.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've finished our tour of the interaction components of the library, by looking
    at the selectable and sortable components. Similar to the other modules that we
    looked at before, both have a wide range of properties and methods that allow
    us to configure and control their behavior and appearance in both simple and more
    complex implementations.
  prefs: []
  type: TYPE_NORMAL
- en: We started off the chapter with a look at a simple, default implementation of
    the selectable with no configuration to see the most basic level of functionality
    added by the component.
  prefs: []
  type: TYPE_NORMAL
- en: We first looked at the default implementation of a selectable and then moved
    on to look at the configurable options, along the numerous callback properties,
    which can be used to perform different actions at different points in an interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Next we looked at how the performance of a page can be improved when there are
    a large number of selectables on the page, and how the single unique method exposed
    by the component, refresh, is used.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly we looked at a fun example that brought together what we had learned
    throughout the chapter and combined the selectables component with the tabs component
    to create an image viewer capable of handling single or multiple selections.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to look at some of the different elements that can be made
    sortable and added some basic styling to the page.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we looked at the range of configurable options that are exposed
    by the sortable API. The list is extensive and provides a wide range of functionality
    that can be enabled or disabled with ease.
  prefs: []
  type: TYPE_NORMAL
- en: We moved on to look at the extensive event model used by this component that
    gives us the ability to react to different events, as they occur in any sort operation,
    initiated by the visitor.
  prefs: []
  type: TYPE_NORMAL
- en: Connected lists offer the ability to be able to exchange sortable items between
    lists or collections of sortables. We saw the additional options and events that
    are used specifically with connected sortable lists.
  prefs: []
  type: TYPE_NORMAL
- en: In the last part of the chapter, we looked at the methods available for use
    with the sortables component, and focused on the highly useful `serialize` method,
    and also had a quick look at its compatibility with other members of the jQuery
    UI library in the form of the sortable tabs example. We've now looked at all of
    the current interaction components found in the library. In the next and final
    chapter, we'll look at all of the different animation effects that jQuery UI brings
    to the table.
  prefs: []
  type: TYPE_NORMAL
