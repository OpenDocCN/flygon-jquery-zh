- en: Chapter 4. Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we looked at how to find elements in the DOM and how
    to manipulate them after they are found. In this chapter, we actually start looking
    at how to build applications with jQuery and the important role that events play.
    Web applications use an event-driven programming model, so it is very important
    to understand events well. Without them, web apps—as we now know them—would not
    be possible. But before we go any further, let's look at what an event is.
  prefs: []
  type: TYPE_NORMAL
- en: An **event** is the occurrence of anything the system considers significant.
    It can originate in the browser, the form, the keyboard, or any other subsystem,
    and it can also be generated by the application via a trigger. An event can be
    as simple as a key press or as complex as the completion of an Ajax request.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are a myriad of potential events, events only matter when the application
    listens for them. This is also known as hooking an event. By hooking an event,
    you tell the browser that this occurrence is important to you and to let you know
    when it happens. When the event occurs, the browser calls your event handling
    code passing the event object to it. The event object holds important event data,
    including which page element triggered it. We will look at the event object in
    greater detail later in the chapter. Here is a list of the things we will cover
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The ready event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooking and unhooking events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespacing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event handler and object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing data to an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event shorthand methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ready event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing event programmers new to jQuery usually learn is the ready event,
    sometimes referred to as the **document ready event**. This event signifies that
    the DOM is fully loaded and that jQuery is open for business. The ready event
    is similar to the document load event except that it doesn't wait for all of the
    page's images and other assets to load. It only waits for the DOM to be ready.
    Also, if the ready event fires before it is hooked, the handler code will be called
    at least once, unlike most events. The `.ready()` event can only be attached to
    the document element. When you think about it, this makes sense since it fires
    when the DOM, is fully loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.ready()` event has a few different hooking styles. All of the styles
    do the same thing: they hook the event. Which hook you use is up to you. In its
    most basic form, the hooking code looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it can only be attached to the document element, the selector can be
    omitted. In such a case, the event hook looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The jQuery documentation does not recommend using the preceding form, however.
    There is a terser version of this event''s hook. This version omits nearly everything
    and only passes an event handler to the jQuery function. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While all of the different styles work, I only recommend the first form since
    it is the most clear. While the other forms work and save a few bytes worth of
    characters, they do that at the expense of code clarity. If you are worried about
    the number of bytes an expression uses, you should use a JavaScript minimizer
    instead; it will do a much more thorough job of shrinking the code than you can
    ever do by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ready event can be hooked as many times as you''d like. When the event
    is triggered, the handlers are called in the order in which they were hooked.
    Let''s take a look at an example via code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we hook the ready event three times, using a different
    hooking style each time. The handlers are called in the same order in which they
    are hooked. In the first event handler, we hook the event again. Since the event
    has been triggered already, we might expect that the handler will never be called,
    but we would be wrong. jQuery treats the ready event differently than other events.
    Its handler is always called, even if the event has already been triggered. This
    makes the ready event a great place for initialization and other code that must
    be run.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ready event is different than all of the other events. Its handler will
    be called once, unlike the other events. It is also hooked differently than the
    other events. All of the other events are hooked by chaining the `.on()` method
    to the set of elements with which you wish to trigger the event. The first parameter
    passed to the hook is the name of the event, followed by the handling function,
    which can either be an anonymous function or the name of a function. This is the
    basic pattern for event hooking. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `.on()` method and its companion, the `.off()` method, were first added
    in version 1.7 of jQuery. For older versions of jQuery, the method used to hook
    the event is `.bind()`. Neither the `.bind()` method nor its companion, the `.unbind()`
    method, are deprecated, but `.on()` and `.off()` are preferred over them. If you
    are switching from `.bind()`, the call to `.on()` is identical at its simplest
    levels. The `.on()` method has capabilities beyond that of the `.bind()` method,
    which requires different sets of parameter to be passed to it. We will explore
    these capabilities later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like more than one event to share the same handler, simply place
    the name of the next event after the previous with a space separating them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Unhooking events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main method used to unhook an event handler is `.off()`, and calling it
    is simple. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The handling function is optional, and the event name is optional as well.
    If the event name is omitted, then all events attached to the elements are removed.
    If the event name is included, then all handlers for the specified event are removed.
    This can create problems. Think about this scenario: you write a click event handler
    for a button. A bit later in the app''s life cycle, someone else needs to know
    when the button is clicked on. Not wanting to interfere with already working code,
    they add a second handler. When their code is complete, they remove the handler,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the handler was called using only the event name, it removed not only
    the handler it added, but also all of the handlers for the click event. This is
    not what was wanted. Don''t despair, however; there are two fixes for this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first fix is to pass the event handler to the `.off()` method. In the preceding
    code, we placed two click event handlers on the button named `clickB`. The first
    event handler is installed using a function declaration, and the second is installed
    using an anonymous function. When the button is clicked on, both of the event
    handlers are called. The second one turns off the first by calling the `.off()`
    method and passing its event handler as a parameter. By passing the event handler,
    the `.off()` method is able to match the signature of the handler you'd like to
    turn off. If you are not using anonymous functions, this fix works well. But what
    if you want to pass an anonymous function as the event handler? Is there a way
    to turn off one handler without turning off the other? Yes, there is; the second
    fix is to use event namespacing.
  prefs: []
  type: TYPE_NORMAL
- en: Namespacing events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At times, it is necessary to be able to distinguish between different handlers
    for the same event without using the handler function. When this need arises,
    jQuery provides the ability to namespace events. To namespace an event, you add
    a period and the namespace to the name of the event. For example, to give the
    click event the namespace of `alpha`, perform this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'jQuery only allows you to create namespaces that are one level deep. If you
    add a second namespace, you don''t create a second level; instead, you create
    a second namespace for the same event. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is equivalent to creating two separate namespaces, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using namespaces makes it possible for us to be more granular with our events,
    in the way we trigger them off and how we trigger them manually. We will explore
    how to trigger events programmatically later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The event handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we''ve just sort of glossed over the event handler. We''ve used it
    but not really explained it. It is time for us to correct that and look thoroughly
    at the event handler. Let''s begin with what jQuery passes to the event handler.
    jQuery passes two things to every event handler: the `event` object and the `this`
    object. The `this` object is passed implicitly, which means that it is not a parameter
    like the `event` object. It is set by jQuery to point to the element to which
    the event handler is bound. The `this` object in JavaScript is somewhat like `this`
    in Java and C# or `self` in Objective-C; it points to the active object. This
    can be very handy, especially when a set of elements shares the same handler.
    The use of the `this` object makes it easy to act upon the correct element among
    many others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we place a click event on each of the `<li>` tags. We
    use the `this` object, which is implicitly passed to us, to tell which one of
    the `<li>` tags triggered the event. Also, note that we didn't use the event parameter
    since it was not needed for our example.
  prefs: []
  type: TYPE_NORMAL
- en: The event object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The event object, which is based on W3C specifications and is explicitly passed
    as a parameter to all event handlers, holds quite a few important properties,
    many of which may be useful to the event handler function. Because each event
    is different, so to be the values in the properties passed in the event object.
    Not every event populates every property, so some properties may be undefined.
    But there are a few properties that are universal, and we will explore them in
    detail next.
  prefs: []
  type: TYPE_NORMAL
- en: event.target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the element that triggered the event. This is not the same thing as
    the element bound to the event handler (the one pointed to by the `this` object).
    For example, if you click an `<a>` tag, which doesn''t have a handler, but its
    parent, `<div>`, does, the event bubbles up to the parent. Under these conditions,
    `event.target` points to the `<a>` tag, but the `this` object points to the `<div>`
    element. Let''s explore this with code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the sample, we place a click event handler on the `<div>` tag that surrounds
    an `<a>` tag. There is no handler placed in `<a>`. When `<a>` is clicked on, since
    it doesn't have an elevator, it bubbles the event up to its parent, the `<div>`
    tag. The `this` object will now point to the `<div>` element, while `event.target`
    will still point to the `<a>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: event.relatedTarget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `relatedTarget` property also points to an element when valid, but rather
    than being the element that triggered the event, it is an element that is somehow
    related to the event instead. An easy way to see this is with the `mouseenter`
    event. Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When the `mouseenter` event is triggered, the `relatedTarget` property points
    to the element that will receive the `mouseleave` event. In our example, if we
    start on top `<a>` and move the cursor up and over the `<input>` tag, the related
    target will be the `<div>` tag that surrounds the `<a>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: event.type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This property holds the name of the current event. It could come in handy if
    you use a single event handler for multiple events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have two different events sharing the same handler.
    When either occurs, it displays the event type to enable us to tell them apart.
  prefs: []
  type: TYPE_NORMAL
- en: event.which
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a mouse or keyboard event occurs, this property can be used to tell which
    button or key was pressed. Let''s take a quick look at a code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When a key is pressed, the `which` property holds the key's code, which is a
    numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: event.metaKey
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a simple property, which holds a boolean value. It is set to `true`
    if the `metaKey` was pressed when the event fired or `false` if it was not. The
    `metaKey` method on the Macintosh keyboards is usually the command key; on Windows
    machines, it is the usually the Windows key.
  prefs: []
  type: TYPE_NORMAL
- en: event.pageX and event.pageY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `pageX` and `pageY` properties hold the mouse position relative to the
    upper-left corner of the page. This could be useful when creating dynamic applications
    that update the page as the user moves the mouse like how it''s done in a drawing
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the code sample, we hook the `mousemove` event and display the current x
    and y position of the mouse dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: event.originalEvent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an event occurs, jQuery normalizes it so that the events in every browser
    behave in the same manner. Occasionally, jQuery's normalized event object lacks
    something that the original event object had and your application needs. jQuery
    places a complete copy of the original event object in the `originalEvent` property
    exactly for this reason.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data to an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you ever need to pass data to an event, all you need to do is pass the data
    after the event name when hooking the event. You can pass nearly any type of data
    with a few caveats. First, if the data is a string, then you must also set the
    optional selector parameter that precedes it in the parameter list. If you don''t
    need the selector parameter, you can set it to null. Second, the data that you
    pass can''t be null or undefined. Here is a little sample that shows how to pass
    data to an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the second event hook, we pass a null selector parameter in order to avoid
    confusion since we are passing a string as the data parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Event shorthand methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Web programming is event-driven, and some events are used so often that jQuery
    has created shorthand methods to hook them. The following two methods are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The second form is shorter and possibly easier to read, but there is a downside.
    In the shorthand form, there is no way to add the extra and optional parameters.
    If you need the selector or data parameters, then you must use the longhand form.
    Here is a list of all of the shorthand methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating your own events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating your own events is common practice in JavaScript. There are a lot
    of reasons for this. For one, it is a best practice since it promotes the loose
    coupling of code. Code that uses events to communicate isn''t tightly coupled.
    This is easy to do; you create event handlers for your own events in the same
    way that you create handlers for system events. Imagine that we need to create
    an event and would like to call `superDuperEvent`. Here is the code that creates
    its handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we create two event handlers. The first creates a handler for our
    `superDuperEvent method`. If the code looks nearly identical to the handler code
    we've created for system events, then that is the way it is intended.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have created the handler code for your custom event, the next question
    you need to answer is this: how do you trigger the event? This is something we
    haven''t mentioned yet, but all you need is the `.trigger()` method. The `.trigger()`
    method executes all of the handlers bound to the matched set of elements for the
    event type. As the preceding code shows, all we need to do in order to trigger
    our custom event is call the `.trigger()` method on the set of elements and pass
    in the event''s name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''d like, we can also pass custom data to the event''s handler. And again,
    this is the same as what we''ve done with regular events. We simply call the `.trigger()`
    method, and after we pass the event name, we pass the custom data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As the preceding code shows, passing data to our event''s handler can do one
    thing that passing data bound to the event hook can''t: we can pass fresh data.
    When we pass data in the event hook, it never changes, which limits its usefulness.
    But the data in the trigger can be changed each time we call the event. Take a
    look at this code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Each time our custom event is triggered, we pass it the current time in milliseconds.
    Passing fresh data is not possible when hooking events.
  prefs: []
  type: TYPE_NORMAL
- en: The death of the .live() and .die() methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of version 1.7 of jQuery, both the `.live()` method and its companion, the
    `.die()` method, have been deprecated. And they were both removed from the library
    as of version 1.9\. While they still exist within the jQuery Migrate Plugin, they
    should not be used to write new code, and any old code using them should be rewritten.
    A lot of users really liked these methods, especially the `.live()` method. It
    was used to write very dynamic code. So, why were these methods removed from the
    library?
  prefs: []
  type: TYPE_NORMAL
- en: The jQuery documentation does a great job of listing some of the problems with
    the `.live()` method. First among them was its performance. The `.live()` method,
    in spite of what was passed in the selector, was actually bound to the document
    element. Yet, it would still retrieve the set of elements specified by the selector,
    which could be time consuming on large documents. When an event occurred, it had
    to bubble all the way up to the document before it could be handled. This meant
    that every event handled by `.live()` was guaranteed to take the longest, slowest
    path to its handler function.
  prefs: []
  type: TYPE_NORMAL
- en: The `.live()` method didn't behave similar to other jQuery methods, and this
    led to bugs. It didn't support chaining events, though it looked like it did.
    Calling `event.stopProgation()` does nothing since there is nothing at a level
    higher than the document. It also didn't play well with other events. So, it was
    decided to deprecate this event and remove it eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Looking deeper at .on()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `.on()` method is not just a renamed `.bind()` method. It has capabilities
    that the former lacked. Part of the reason for these new capabilities is to give
    developers a way to write code in a fashion similar to what the `.live()` method
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.on()` method has an optional parameter; the `which` selector is a string.
    Most of the time, it isn''t required, so either it isn''t passed, or a null is
    passed instead. When you''d like to replace the `.live()` method without its inefficiencies,
    use the `.on()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we hook two events. We first hook the parent element,
    the `<ul>` tag, which will serve as a container for all of the `<li>` tags: those
    that exist now and those that will be created later. Then, we hook the button
    that will be used to generate new `<li>` tags. Each time we create a new tag,
    we increment a counter and concatenate it to the string used for the new tags
    `id` and then append it to the `<ul>` tag.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve learned a lot about one of the most important things in web programming:
    events. Events make websites interactive. We began by looking at one of the most
    important events, the jQuery ready event. We continued to cover hooking and unhooking
    events, namespacing, and finally, writing event handlers using the event object.
    With the basics covered, we showed how to write your own events and trigger them.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to make our site smooth and polished
    using jQuery's built-in and custom animations. Animations help ease the transition
    from one application state to the next. Without it, a site can seem jarring to
    a user when elements on the page appear and disappear abruptly.
  prefs: []
  type: TYPE_NORMAL
