- en: Chapter 5. Form Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at how to create robust and attractive web forms
    with animation, validation, and user feedback. We will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic form validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding number validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding credit card number validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding date validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding e-mail address validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing live form validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a password strength indicator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding anti-spam measures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing input character restrictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collecting user data is a basic function of many websites and web applications,
    from simple data collection techniques such as registration or login information,
    to more complex scenarios such as payment or billing information. It is important
    that only relevant and complete information is collected from the user. To ensure
    this, the web developer must enforce validation on all data input. It is also
    important to provide a good user experience while enforcing this data integrity.
    This can be done by providing useful feedback to the user regarding any validation
    errors their data may have caused. This chapter will show you how to create an
    attractive web form that enforces data integrity while keeping a high-quality
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: A very important point to note is that any JavaScript or jQuery validation is
    open to manipulation by the user. JavaScript and jQuery resides within the web
    browser, so a user with little knowledge can easily modify the code to bypass
    any client-side validation techniques. This means that client-side validation
    cannot be totally relied on to prevent the user from submitting invalid data.
    Any validation done within the client side must be replicated on the server, which
    is not open for manipulation by the user.
  prefs: []
  type: TYPE_NORMAL
- en: We use client-side validation to improve the user experience. Because of this,
    the user does not need to wait for a server response.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic form validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the most basic level of form validation, you will need to be able to prevent
    the user from submitting empty values. This recipe will provide the HTML and CSS
    code for a web form that will be used for recipes 1 through 8 of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using your favorite text editor or IDE, create a blank HTML page in an easily
    accessible location and save this file as `recipe-1.html`. Ensure that you have
    the latest version of jQuery downloaded to the same location as this HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: This HTML page will form the basis of most of this chapter, so remember to keep
    it after you have completed this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Learn how to implement basic form validation with jQuery by performing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the following HTML code to `index.html`. Be sure to change the source location
    of the JavaScript included for the jQuery library, pointing it to where the latest
    version of jQuery is downloaded on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a CSS file named `styles.css` in the same directory and add the following
    CSS code to add style to our HTML page and form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition to the jQuery library, the previous HTML page also uses another
    JavaScript file. Create a blank JavaScript file in the directory where the `index.html`
    file is saved. Save this file as `validation.js` and add the following JavaScript
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `index.html` in a web browser and you should see a form similar to the
    following screenshot:![How to do it…](img/0896OS_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you click on the **Submit** button to submit an empty form, you will be presented
    with error messages under the required fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let us understand the steps performed previously in detail.
  prefs: []
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HTML creates a web form with various fields that will take a range of data
    inputs, including text, date of birth, and credit card number. This page forms
    the basis for most of this chapter. Each of the input elements has been given
    different classes depending on what type of validation they require. For this
    recipe, our JavaScript will only look at the `required` class, which indicates
    a required field and therefore cannot be blank. Other classes have been added
    to the input fields, such as `date` and `number`, which will be used in the later
    recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Basic CSS has been added to create an attractive web form. The CSS code styles
    the input fields so they blend in with the form itself and adds a hover effect.
    The Google Web Font Ubuntu has also been used to improve the look of the form.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first part of the jQuery code is wrapped within `$(function(){});`, which
    will ensure the code is executed on page load. Inside this wrapper, we attach
    a click event handler to the form submit button, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we want to handle the form submission based on whether valid data has been
    provided, we use `event.preventDefault();` to initially stop the form from submitting,
    allowing us to perform the validation first, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `preventDefault` code, an `inputs` variable is declared to hold all
    the input elements within the page, using `$(''input'')` to select them. Additionally,
    we create an `isError` variable, setting it to `false`. This will be a flag to
    determine if our validation code has discovered an error within the form. These
    variable declarations are shown previously. Using the length of the `inputs` variable,
    we are able to loop through all of the inputs on the page. We create an input
    variable for each input that is iterated over, which can be used to perform actions
    on the current input element using jQuery. This is done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After the input variable has been declared and assigned the current input,
    any previous error classes or data is removed from the element using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first line removes the `error` class from the input's parent (`.input-frame`),
    which adds the red border to the input element. The second line removes the error
    information that is displayed under the input if the validation check has determined
    that this input has invalid data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, jQuery''s `hasClass()` function is used to determine if the current input
    element has the `required` class. If the current element does have this class,
    we need to perform the required validation to make sure this field contains data.
    We call the `validateRequired()` function within the `if` statement and pass through
    the value of the current input, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We call the `validateRequired()` function prepended with an exclamation mark
    to check to determine if this function's results are equal to `false`; therefore,
    if the current input has the `required` class and `validateRequired()` returns
    `false`, the value of the current input is invalid. If this is the case, we call
    the `addErrorData()` function inside the `if` statement with the current input
    and the error message, which will be displayed under the input. We also set the
    `isError` variable to `true`, so that later on in the code, we will know a validation
    error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript''s `for` loop will repeat these steps for each of the selected
    input elements on the page. After the `for` loop has completed, we check if the
    `isError` flag is still set to `false`. If so, we use jQuery to manually submit
    the form, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the operator `===` is used to compare the variable type of `isError`
    (that is, `Boolean`) as well as its value. At the bottom of the JavaScript file,
    we declare our two functions that have been called earlier in the script. The
    first function, `validateRequired()`, simply takes the input value and checks
    to see if it is blank or not. If the value is blank, the function returns `false`,
    meaning validation failed; otherwise, the function returns `true`. This can be
    coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function used is the `addErrorData()` function, which takes the
    current input and an error message. It uses jQuery''s `addClass()` function to
    add the error class to the input''s parent, which will display the red border
    on the input element using CSS. It then uses jQuery''s `after()` function to insert
    a division element into the DOM, which will display the specified error message
    under the current input field, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This structure allows us to easily add additional validation to our web form.
    Because the JavaScript is iterating over all of the input fields in the form,
    we can easily check for additional classes, such as `date`, `number`, and `credit-card`,
    and call extra functions to provide the alternative validation. The other recipes
    in this chapter will look in detail at the additional validation types and add
    these functions to the current `validation.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing input character restrictions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding number validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When collecting data from a user, there are many situations when you will want
    to only allow numbers in a form field. Examples of this could be telephone numbers,
    PIN codes, or ZIP codes, to name a few. This recipe will show you how to validate
    the telephone number field within the form we created in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure that you have completed the previous recipe and have the same files available.
    Open `validation.js` in your text editor or IDE of choice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add number validation to the form you created in the previous recipe by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `validation.js` to be as follows, adding the `valdiateNumber()` function
    with an additional `hasClass(''number'')` check inside the `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `index.html` in a web browser, input something other than a valid integer
    into the telephone number field, and click on the **Submit** button. You will
    be presented with a form similar to the following screenshot:![How to do it…](img/0896OS_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we add an additional `if` statement to the main `for` loop of `validation.js`
    to check to see if the current input field has the class `number`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If it does, this input value needs to be validated for a number. To do this,
    we call the `validateNumber` function inline within the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the value of the current input field as an argument. It
    first checks to see if the value is blank. If it is, we do not need to perform
    any validation here because this is handled by the `validateRequired()` function
    from the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a value to validate, a range of actions are performed on the `return`
    statement. First, the value is parsed as an integer and passed to the `isNaN()`
    function. The JavaScript `isNaN()` function simply checks to see if the provided
    value is **NaN** (**Not a Number**). In JavaScript, if you try to parse a value
    as an integer and that value is not actually an integer, you will get the `NaN`
    value. The first part of the `return` statement is to ensure that the provided
    value is a valid integer. However, this does not prevent the user from inputting
    invalid characters. If the user was to input `12345ABCD`, the `parseInt` function
    would ignore `ABCD` and just parse `12345`, and therefore the validation would
    pass. To prevent this situation, we also use the `isFinite` function, which returns
    `false` if provided with `12345ABCD`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Adding credit card number validation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding credit card number validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Number validation could be enough validation for a credit card number; however,
    using regular expressions, it is possible to check for number combinations to
    match credit card numbers from Visa, MasterCard, American Express, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have `validation.js` from the previous two recipes in this
    chapter open and ready for modification.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use jQuery to provide form input validation for credit card numbers by performing
    the following step-by-step instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `validation.js` to add the credit card validation function and the additional
    class check on the input fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `index.html` and input an invalid credit card number. You will be presented
    with the following error information in the form:![How to do it…](img/0896OS_05_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add credit card validation, as with the previous two recipes, we added an
    additional check in the main `for` loop to look for the `credit-card` class on
    the input elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `validateCreditCard` function is also added, which uses a regular expression
    to validate the input value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first part of this function determines if the provided value is blank. If
    it isn't, the function will perform further validation; otherwise, it will return
    `true`. Most credit card numbers start with a prefix, which allows us to add additional
    validation to the inputted value on top of numeric validation. The regular expression
    used in this function will allow for Visa, MasterCard, American Express, Diners
    Club, Discover, and JCB cards.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Adding number validation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding date validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dates are common items of data, and it is important that the user be able to
    easily input a date into your web form. Typically, you would use a date picker
    that has date validation included to provide an easy input method. This recipe
    shows you how to manually validate a date in the UK format (that is, `DD/MM/YYYY`).
    Date pickers are covered in [Chapter 9](ch09.html "Chapter 9. jQuery UI"), *jQuery
    UI,* using the popular jQuery UI framework. Refer to the *See also* section of
    this recipe for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing the trend of the previous recipes of this chapter, ensure that you
    have `validation.js` open and ready for modification and that you have completed
    the previous three recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add date validation to your web form by performing the following simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `validation.js` to add the additional date validation function and class
    check within the main `for` loop, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `index.html` in a web browser, input an invalid date, and click on **Submit**
    to generate the invalid date error, shown in the following screenshot:![How to
    do it…](img/0896OS_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, we add an additional class check to the main `for` loop to see if
    the current input needs to have date validation applied. If it does, the `validateDate()`
    function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the other validation functions, we first check to see if the value
    is blank. If it is not blank, the value can be validated. A regular expression
    is used to determine if the string value provided is of a valid date format, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This test will pass if the provided value is separated with a slash, a hyphen,
    or a full stop and where the first two parts consist of two numbers and the last
    part consists of four numbers. This will ensure the provided value is `DD/MM/YYYY`,
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this test passes, the next step is to remove all of the leading zeros so
    that the provided date string can be converted into a date object with JavaScript
    (for example, `08-08-1989` will become `8-8-1989`). The code for the same is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, an array is created as follows, splitting the date string on either
    `-`, `/`, or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is possible to use these date values to create a JavaScript date object
    and test its validity. Before this can happen, we must convert the month value.
    JavaScript months start from `0`, whereas our user will have started from `1`.
    For example, the user will use `1` for January, `2` for February, and so on, whereas
    JavaScript uses `0` for January, `1` for February, and so on. To account for this,
    we simply subtract `1` from the provided date value, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With this done, it is possible to create the JavaScript date object and check
    that the outcome matches the input date, proving its validity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding date picker interfaces to input boxes quickly* recipe in [Chapter
    9](ch09.html "Chapter 9. jQuery UI"), *jQuery UI*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding e-mail address validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: E-mail address validation is one of the most common types of validation on the
    Web. Most people would believe that a valid e-mail address only contains alphanumeric
    characters with the exception of the `@` symbol and a full stop. While most e-mail
    addresses are typically of this format, a valid e-mail address can actually contain
    a variety of other characters. This recipe will show you how to add e-mail validation
    to the web form we have been using in the last four recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create e-mail validation that can be reused again and again by performing the
    following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the additional `hasClass` check and `if` statement to the main `for` loop
    in `validation.js` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `validateEmail()` function to the end of `validation.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `index.html` in a web browser, input an invalid e-mail address, and submit
    the form. You will be presented with an appropriate error in the same fashion
    as the other types of validation errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The e-mail validation function, however simple, contains a complex regular expression
    to validate an e-mail address to a practical version of RFC 5322 standards, which
    was provided by [http://www.regular-expressions.info/email.html](http://www.regular-expressions.info/email.html).
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the `validateEmail()` function checks to see if there is a
    value to validate. If so, it uses the complex regular expression to test the string
    values' validity, returning `true` or `false` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as with the other validation functions, there is the class check inside
    the main `for` loop, which determines which inputs need to be validated for e-mail
    addresses. If these input fields fail validation, it will provide the appropriate
    error output on screen.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to understand that this method of e-mail validation only validates
    the syntax to cut down on the amount of rubbish data provided by users. To truly
    validate an e-mail address, you would have to actually send an e-mail to verify
    that it exists and is ready to receive e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing live form validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be very useful for the user to get real-time feedback regarding validation
    errors as they type in your web form. If you are performing client-side validation
    with JavaScript as well as server-side validation, this can be achieved easily
    as you do not need to send a request to the server every time the user types in
    an input—you can do it all within the client. Once again, it is very important
    that the same data undergoes additional validation on the server side. The server-side
    validation can then be fed back to the web form after the user has submitted the
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will adapt the client-side validation that has been created as part
    of the last five recipes. Ensure that you have completed these recipes beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Provide real-time validation to users by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to move all of the class checks from the `for` loop into their
    own function so that they can be reused. Move all of the `if` statements, which
    perform the `hasClass` checks for `required`, `email`, `number`, `date`, and `credit-card`,
    into a function called `doValidation()`, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to update the main `for` loop to use this function so that the
    form validation is still performed when the user clicks on the submit button,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `isError` check after the `for` loop to use an alternative method
    to determine if there were errors so that the form can still be submitted, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To perform validation on the field that the user is typing into, we need to
    call the `doValidation()` function on the `keyup` event. Add the following code
    inside the `$(function(){});` block to attach a `keyup` event handler to each
    of the form inputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `index.html` in a web browser, start typing inside the e-mail field, and
    you will be provided with the appropriate error message as you type until you
    have entered a valid e-mail address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is easy to adapt the previous validation code to provide real-time validation
    for the user. Moving the main validation triggers to another function means that
    the code can be reused without the need for duplication. The function that holds
    these triggers takes one argument, which is the input it needs to perform the
    validation checks on. The `for` loop is still used to provide this input, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of relying on the `doValidation` function to return an `isError` value,
    we look to the DOM directly to see if there are any errors being displayed on
    screen by looking for any elements with the `error-data` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If there are no errors, the form is submitted manually as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide real-time validation, a `keyup` event handler is attached to each
    of the form inputs using the following jQuery code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The callback function for the `on()` method will be executed every time the
    user presses and releases a key inside one of the input fields. It is then possible
    to use `$(this)`, which refers to the input that triggered the event, thereby
    providing the `doValidation()` function with the input object it requires to perform
    the validation checks.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a password strength indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users like to create a really simple password that is easy to remember, such
    as cat, john, or even password. However, most people, especially web developers,
    know that these types of passwords are too insecure and are incredibly easy to
    decrypt from an encrypted database using techniques such as a dictionary attack,
    for example. Password strength indicators are useful to nudge the user in the
    right direction of using more complex passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to validate password strength, we need to create some rules that
    our code will use. There are no hard-and-fast rules regarding this, but plenty
    of information can be found online about what types of passwords are best. We
    will give the password a score out of five, one point for each of the following
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: It is greater than six characters in length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is greater than eight characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has both upper and lowercase characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has at least one number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has one of the following symbols: `@`, `$`,`!`, `&`, and `^`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe will add password strength indicator to the web form that we have
    been creating over the last six recipes. Ensure that you have the code from these
    recipes available before you begin this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an effective password strength indicator for web forms by performing
    each of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `index.html`, adding some additional classes to the password form elements
    and also some additional HTML, which will create the password strength indicator,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the following styles to the end of `styles.css` to position the strength
    indicator under the password field. These styles will also allow the strength
    indicator to act as a load bar showing the percentage of password strength.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `validatePasswords()` function to the end of `validation.js`, which
    will be used to ensure both passwords are entered and that they match, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the end of the `doValidation()` function to run the
    `validatePasswords()` function on the `confirm-password` input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following `keyup` event handler inside the `$(function(){});` block
    in `validation.js` to score the password strength when the user types in the first
    password field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `index.html` in a web browser and you will see an additional black box
    under the first password field. Start typing in a password and this field will
    provide information on the password strength as you type. This is illustrated
    in the following screenshot:![How to do it…](img/0896OS_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTML for the indicator itself has an `inner` element and a `text` element.
    The `text` element is used by jQuery to display the password strength and percentage
    based on the calculated score of the inputted password. The `inner` element is
    used to form the colored bar. Based on the calculated score, jQuery is used to
    change the inner element's color and positioning, creating the load bar impression,
    which can be seen in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS used needs little explanation since it provides basic styles and positioning.
    The `inner` element has an absolute position so that it can fill the `password-strength`
    element at different percentages. The `text` division has its `z-index` parameter
    set to ensure that the text will always display above the `inner` element.
  prefs: []
  type: TYPE_NORMAL
- en: The `validatePasswords` function, which was created as part of this recipe,
    simply adds basic password validation to our application. It checks to ensure
    that the `confirm-password` field has been filled and that the value matches the
    first `password` field. An additional check is added to the `doValdiation` function
    to ensure this validation gets applied along with the other validation methods
    created in earlier recipes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the password strength indicator as the user types within the password
    field, the same method is used as that used in the *Implementing live form validation*
    recipe, which is to use the `keyup` event. An event handler is attached to the
    `password` field using the jQuery `on()` function, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The code to calculate the score and update the `password-strength` HTML element
    is then placed within the callback function to this event handler. The first part
    of this code is to remove any current errors displayed for the password fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, there are a series of `if` statements which validate the password
    against the rules that were defined at the beginning of this recipe. The first
    basic validation is the password length, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The score variable is incremented by `1` using `score++` every time a validation
    condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more complex rules use regular expressions to determine whether the password
    value meets the requirements for the additional score points, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After all five rules have been considered, the final score is used to calculate
    the fill value. The fill value is the percentage of the `inner` element that needs
    to be filled from the right-hand side of the strength indicator. This allows us
    to create the load bar effect. In addition to the fill value, a normal percentage
    is calculated to be displayed along with the strength level text as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, the score value is used once more to determine the background color
    of the `inner` element and the strength level text as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, using the jQuery `password-strength`, the HTML code is updated with
    the acquired information to display the results to the user, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This code should be easily adaptable so that you can add your own rules regarding
    password strength. There are many discussions and resources online to point you
    to what a strong password should look like.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing live form validation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding anti-spam measures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most web developers will know that if you have a contact form or any kind of
    web form publically available on your website, there will be web bot submissions
    and a lot of spam. Most web bots will be thwarted by the JavaScript-only web form
    we have been creating over the last seven recipes, but with browser automation
    and web bots becoming ever cleverer, it is still important to add anti-spam measures
    to your web forms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure that you have completed the last seven recipes and have the code readily
    available. Remember that if you would just like to use the code without fully
    understanding how it works, skip to the end of this chapter, to the *How it works...*
    section, to grab it all.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add simple anti-spam measures to your web form by performing each of the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `index.html` to have an additional form input under the input labeled
    `Confirm Password` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using JavaScript, generate a random number between `1` and `100` at the top
    of `validation.js` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the very end of the `$(function(){});` jQuery block, add the following code
    to update the HTML `anti-spam-number` span element with the random number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following additional validation check to the end of the `doValidation()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, at the end of `validation.js`, add the `validateAntiSpam()` function,
    which is called by the previous code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `index.html` in a web browser and you will see the additional anti-spam
    form input field. Every time you refresh the page, it will ask you to input a
    different number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By declaring the `spamNumber` global variable outside any function, it is available
    for use by the whole JavaScript file. A new number between `1` and `100` is generated
    on every page load so that a web bot cannot store the answer and submit the form.
    Within the HTML code, there is a `span` element with the class `anti-spam-number`,
    which is updated with a random number on page load using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure the user is being told to input the correct number. We created
    an additional validation function named `validateAntiSpam` and called it from
    the `doValidation()` function for all inputs that have the `anti-spam-input` class.
    This will then validate the user-entered number with the globally available `spamNumber`
    variable, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that the input is parsed as an integer to ensure a number-on-number comparison.
    If the values do not match, this function will return `false` so that the `doValidation()`
    function can create the appropriate error message on-screen for the user.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This type of client-side spam validation cannot be completely relied upon. It
    is effective towards general web bots that are not directly targeting your website.
    If someone wants to write a bot script specific to your site, bypassing this JavaScript
    would not be a difficult process. If you think this is possible, more extreme
    server-side spam prevention must be used.
  prefs: []
  type: TYPE_NORMAL
- en: There are many effective spam-prevention methods available for free on the Internet.
    The most popular are CAPTCHAs. One of the most popular CAPTCHAs is available for
    free by Google at [http://www.google.com/recaptcha](http://www.google.com/recaptcha).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Adding a password strength indicator*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing input character restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, all of the recipes in this chapter have concentrated on input validation
    and providing appropriate feedback to the user. There are situations where it
    is better to simply prevent the user from inputting invalid characters in the
    first place. This method would not typically be used, because it can be confusing
    for some users; for example, if they are not being told why they cannot input
    *%*. A situation where this would work is a login form. If you know your registration
    system does not allow *%* in the username, you know that the user would be inputting
    *%* by mistake, and therefore preventing the input is acceptable. This recipe
    provides a method to prevent users from inputting non-alphanumeric characters
    into an input field.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe does not use any code from the last eight recipes; however, there
    are similarities in the CSS code. To complete this recipe, you are going to need
    three files. Create `recipe-9.html`, `recipe-9.js`, and `recipe-9.css` in the
    same directory as you have stored the latest version of jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use jQuery to prevent users from inputting invalid chapters into text inputs
    by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following HTML code to `recipe-9.html`. This creates a basic login
    form and includes the two other files along with the jQuery library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following CSS code to `recipe-9.css`, which adds style to the login
    form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following JavaScript code to `recipe-9.js` in order to watch for user
    input on the `username` field and ensure non-alphanumeric characters are not inputted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open `recipe-9.html` in a web browser and attempt to input a non-alphanumeric
    character (for example, `$`) inside the `username` field. You will see it will
    not be placed inside the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key press event handler is attached to the `username` field on page load.
    The callback function for this event handler has a single argument, which is the
    `event` object. This `event` object provides access to the key code of the key
    that the user is pressing. When the `username` field has focus and the user presses
    a key, the callback function is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, `String.fromCharCode(event.which);` is used to get the string value
    of the pressed key; for example, `D`, `H`, and `4`. A regular expression is then
    used to determine whether or not this character is alphanumeric. If not, the character
    is prevented from being inputted into the form field using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure that the event used in this recipe is the `keypress` event. If an alternative
    event is used, such as `keydown`, you may not achieve the desired result. If the
    `keydown` event is used, when the user presses *Shift* + *4* to input a `$` symbol,
    the `keydown` event will provide its event handler as just `4`, and not `$`, therefore
    passing validation.
  prefs: []
  type: TYPE_NORMAL
