- en: Chapter 6. Extending Chrome with jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an extension for Chrome (or any other browser that can be extended
    with plugins and extensions) is an easy way to create custom behavior or additional
    tools to enhance our browsing experience.
  prefs: []
  type: TYPE_NORMAL
- en: Chrome allows us to leverage our web development skills to extend its browser
    interface, using technologies we're already familiar with such as HTML, CSS, and
    JavaScript, and where you can use JavaScript you can usually use jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Briefing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project we'll build a Chrome extension that highlights elements on the
    page that are marked up with `Schema.org` **microdata**. Microdata is a way of
    specifying descriptive information about a variety of different entities, such
    as businesses, locations, or people using standard HTML attributes, and is rumored
    to become an important factor in Google's ranking algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we visit a page containing elements described as contact details, we
    can grab them from the page and store them in our extension, allowing us to slowly
    build up a directory of contact information for people that are using or making
    stuff we love.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use templating in this project to make creating a repeated group
    of elements much more efficient, as well as easier to maintain. We used JsRender
    in the previous project, so we can use it again, but this time we''ll need to
    use it slightly differently than before. Once completed, our extension will look
    something like that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mission Briefing](img/9106OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Why Is It Awesome?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microdata is used to describe the information contained within web pages in
    order to promote better interoperability between autonomous systems, such as search
    engine spiders and HTML documents.
  prefs: []
  type: TYPE_NORMAL
- en: When different elements on the page are described as being a company, a person,
    a product, or a movie, it allows things such as search engines to better understand
    the information contained on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Microdata is rapidly becoming more commonplace on the Web and is set to take
    an ever increasingly important role in the results generated by Google for search
    results, so there has never been a better time to exploit it.
  prefs: []
  type: TYPE_NORMAL
- en: Your Hotshot Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The tasks this project is broken down into are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the basic extension structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a manifest and installing the extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a sandboxed JsRender template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Posting a message to the sandbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a content script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scraping the page for microdata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a mechanism for saving the microdata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the basic extension structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this task we'll create the underlying files required by the extension. All
    files used by an extension need to reside in the same directory, so we'll set
    that up and make sure it contains all the files we need.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One thing I should point out, although hopefully you'll already have realized
    – we're going to require the Chrome browser for the duration of this project.
    If you don't have it installed, which as a web developer you really ought to,
    if only for testing purposes, get it and install it immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The latest version of Chrome can be downloaded from [https://www.google.com/intl/en/chrome/browser/](https://www.google.com/intl/en/chrome/browser/).
  prefs: []
  type: TYPE_NORMAL
- en: We'll keep all of the files for this project in a single directory, so set one
    up in the project folder now and call it `chrome-extension`. The extension will
    be built from the same base code files as most of the other projects that we've
    created have been built from; the only difference is that all files will need
    to be local to the extension.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to need a copy of JsRender, so we should also download a copy of
    that and place it in the `chrome-extension` directory. Last time we used JsRender
    we linked to the live hosted version. This time we'll download it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The latest version of JsRender can be downloaded from [https://github.com/BorisMoore/jsrender/](https://github.com/BorisMoore/jsrender/).
  prefs: []
  type: TYPE_NORMAL
- en: We can use the template file that we've started the other projects with, but
    we should make sure the paths to jQuery, the JavaScript file, and the style sheets
    all point to files in the same directory. All of the files used by a Chrome extension
    must be in the same folder, which is why we download the scripts instead of linking
    to online versions.
  prefs: []
  type: TYPE_NORMAL
- en: We should place copies of jQuery, JsRender, and the `common.css` style sheet
    into the new directory. We also need to create a new JavaScript file called `popup.js`
    and a new style sheet called `popup.css` and save these files into the new directory
    also.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we can create a new HTML page called `popup.html`. This file should
    also be saved in the `chrome-extension` directory, and should contain the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTML file we just created will be used as the extension's popup. This is
    the page that is displayed as a popup when the extension's icon is clicked in
    the toolbar. In this project we'll be creating a type of extension known as a
    **browser action**, which automatically adds a button to Chrome's toolbar which
    is used to open the popup.
  prefs: []
  type: TYPE_NORMAL
- en: The popup will display a button used to trigger a scan of the current page for
    microdata and display any previously saved contacts. Any previously stored contacts
    will be retrieved using the localStorage API, and we can use a template to render
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we can add the general markup to the page; in `popup.html` add the following
    code to the `<body>` of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add some basic styling for these elements. In `popup.css`, add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete - Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chrome extensions are built using the same files that as web developers we're
    used to working with – HTML, CSS, and JavaScript. The extension will add a button
    to the toolbar and when this button is clicked, it will display a popup. The HTML
    page that we added in this task is the basis of this popup.
  prefs: []
  type: TYPE_NORMAL
- en: We create the page like we would create any other standard HTML5 page. We linked
    to the CSS and JavaScript files as usual, and then added a small `<section>` container
    which will be used as a container for any previously saved contacts. Initially
    there won't be any, and when there are, we'll render them using a template.
  prefs: []
  type: TYPE_NORMAL
- en: We've added a `<header>` containing a `<h1>` to give the saved contacts a title,
    and have added an empty`<ul>` element that we'll populate shortly with a script.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly we added an `<iframe>` to the page, which will be hidden from view. We'll
    use this to communicate with another part of the extension a little later on.
    The `src` attribute of the element is set to the page we want to send messages
    to.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS we added was purely for presentation and just laid out the initial elements
    in a simple layout. We're also linking to the common CSS file that each of the
    other projects have also used, but don't forget, all files used by the extension
    must be in the extension's directory.
  prefs: []
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we are creating a browser action we'll get a new button added to Chrome's
    toolbar which will be visible as long as the unpacked extension is loaded. By
    default it will have the standard extension icon – a puzzle piece, but we can
    replace this with an icon of our own creation.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create other types of extension which don't add a button to the
    toolbar. We could create a page action instead of a browser action, which adds
    an icon to the address bar instead of the toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Whether this icon is visible on all pages or not will depend on how the extension
    behaves. For example, if we wanted to run our extension every time a page was
    loaded in the browser, but only display the icon if it found `Schema.org` microdata
    on the page, we could use a page action.
  prefs: []
  type: TYPE_NORMAL
- en: A browser action, such as we'll create here, is accessible all of the time,
    regardless of the page being viewed. We're using a browser action instead of a
    page action because the users of our extension will probably want to be able to
    see contacts they have previously found and saved, so a browser action is perfect
    for facilitating an always-available button to display any data stored by the
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a manifest and installing the extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to actually install our extension and see the fruits of our labor so
    far, we'll need to create a manifest file. This special file, saved in JSON format,
    controls certain aspects of the extension such as the pages it uses, and the content
    scripts it can run.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a new file add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Save this file in the `chrome-extension` directory that we created at the start
    of the task within our main project directory as `manifest.json`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the text editor you're using doesn't show **.json** in the **Save as type:**
    (or equivalent) drop-down, select the **All types (*)** option and type the full
    filename `manifest.json` in the **File name:** input field.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to view the extension as it currently exists, it will need to be loaded
    in Chrome as an extension. To do this, you should go to **Settings** | **Tools**
    | **Extensions**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In recent versions of Chrome, the **Settings** menu is accessed by clicking
    on the button that has three stripes as its icon, which is situated at the top-right
    of the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: When the extensions page loads, there should be a button to **Load unpacked
    extension…**. If there isn't, tick the **Developer mode** checkbox and the button
    will appear.
  prefs: []
  type: TYPE_NORMAL
- en: Hit the button and select the `chrome-extension` folder as the extension directory.
    This should install the extension and add the browser action button to the toolbar
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Objective Complete - Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simple manifest file is required by the extension before it can be loaded
    in the browser. Only manifests of at least Version 2 are allowed by the current
    version of Chrome. The manifest is required and the extension will not run without
    it. It is a simple text file, in JSON format, that is used to tell the browser
    some of the basic information about the extension, such as its name, who authored
    it, and the current version.
  prefs: []
  type: TYPE_NORMAL
- en: We can specify that our extension is a browser action, which adds a button for
    the extension to Chrome's toolbar. We can also specify the page that will be displayed
    in the popup using the manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the new button for our extension is clicked, the HTML page (`popup.html`)
    we added in the previous task will be displayed in the extension popup, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Objective Complete - Mini Debriefing](img/9106OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a sandboxed JsRender template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this task we can add the template that JsRender will use to display the saved
    contacts. At this point we don't have any saved, but we can still wire it up ready,
    and then when we do have some contacts, they'll be rendered into the popup without
    any fuss.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chrome uses a **Content Security Policy** (**CSP**) in order to prevent a large
    number of common **cross-site scripting** (**XSS**) attacks, and because of this
    we are not allowed to execute any scripts that use either `eval()` or `new Function()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JsRender templating library, like many other popular libraries and frameworks,
    uses `new Function()` when compiling templates and therefore is not allowed to
    run directly inside the extension. There are two ways we can overcome this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: We could switch to a templating library that offers a pre-compilation of templates,
    such as the popular `Dust.js`. We could then compile our template outside of the
    extension in a browser and link to a JavaScript file containing the function that
    the template is compiled into from within the extension. The function that would
    be created with `new Function()` would then already have been created prior to
    the extension even being installed, and the template could then be rendered inside
    the extension, interpolated with any data made available within the extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or, Chrome's extension system allows us to use certain files inside a specified
    sandbox. Unsafe string-to-function features such as `eval()` or `new Function()`
    are allowed to run in the sandbox because the code is insulated from the extension's
    data and API access within the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use the sandboxing feature in this example, so that we can continue using
    JsRender.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all we have to set up the sandbox, which is done by specifying which
    pages to sandbox using the manifest file that we created earlier. Add the following
    code to `manifest.json`, directly before the final closing curly bracket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to add a comma directly after the closing curly bracket of the
    `browser_action` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve specified `template.html` as the page to sandbox. Create a new file
    called `template.html` and save it in the `chrome-extension` directory. It should
    contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The template page also references the `template.js` script file. We should
    create this file in the `chrome-extension` directory and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete - Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We started out by adding a new HTML page to the extension. The page called `template.html`
    is like a regular web page except that it doesn't have a `<body>`, just a `<head>`
    that links to some JavaScript resources, and a `<script>` element containing the
    template we'll be using.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually in a Chrome extension, the CSP prevents us from running any inline scripts
    – all scripts should reside within external files. Using a non-standard `type`
    attribute on the `<script>` element allows us to circumvent this so that we can
    store our template inside the page instead of having another external file.
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of the new page is the template itself. `Schema.org` microdata allows
    people to add a lot of additional information to describe the elements on the
    page, so there are a range of different bits of information that may be stored
    in the extension.
  prefs: []
  type: TYPE_NORMAL
- en: Our template therefore makes use of a lot of conditionals to display things
    if they are present. The extension should always display the name, but aside from
    that it may display an image, a job title and company, an address, or various
    contact methods, or any combination thereof.
  prefs: []
  type: TYPE_NORMAL
- en: The most complex part of the template is the `getMembers()` helper function.
    We'll call this helper function for each object in the `contactMethods` object
    using JsRender's `{{for}}` tag, which calls the helper function using the tilde
    (~) character. Inside the loop we'll have access to the values returned by the
    helper and can insert these into the relevant elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we added the `template.js` script file. At this point all we need to add
    to this script file is the helper method used by the template to render any contact
    methods. These will be in the format `{ email: me@me.com }`.'
  prefs: []
  type: TYPE_NORMAL
- en: The helper is registered using JsRender's `helpers()` method. This method is
    passed an object where the name of the helper is specified as the key and the
    function that should be invoked is the value.
  prefs: []
  type: TYPE_NORMAL
- en: The function receives an object. We first create an empty array and then iterate
    the object using a standard `for in` loop. We first check that the property being
    iterated belongs to the object and is not inherited from the prototype using JavaScript's
    `hasOwnProperty()` function.
  prefs: []
  type: TYPE_NORMAL
- en: We then just create a new object and set the key as a property called `key`,
    and the value as a property called `val`. These are the template variables that
    we use in the `<dl>` in our template.
  prefs: []
  type: TYPE_NORMAL
- en: This new object is then pushed into the array we created, and once the object
    passed to the helper has been iterated, we return the array to the template for
    the `{{for}}` loop to iterate.
  prefs: []
  type: TYPE_NORMAL
- en: Posting a message to the sandbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this task we'll set up the communication between our popup and the sandboxed
    template page to see how we can get the template to render when the popup is opened.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all we can add the code that sends the message to the sandboxed page
    requesting the template to render. In `popup.js`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to add the code that will respond to the initial message. Add
    the following code to `template.js` directly after the helper method we added
    in the last task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete - Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all we set up the initial messaging in `popup.js`. We cached the `<iframe>`
    element from the popup in a variable and then composed a message. The message
    is in the form of an object literal with a `command` property and a `context`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: The `command` property tells the code running in the `<iframe>` what to do,
    while the `context` contains the data to be rendered into a template. The data
    that we'll render will be stored in localStorage under the `webContacts` key,
    and the data will be in JSON format so we need to convert it back to a JavaScript
    object using `JSON.parse()`.
  prefs: []
  type: TYPE_NORMAL
- en: We then add a load handler to the `<iframe>` element using jQuery's `on()` method.
    The code contained in the anonymous function passed to `on()` will be executed
    when the contents of the `<iframe>` have loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Once this occurs, we check whether the `context` property of the `message` object
    has a truthy value. If it does, we post the `message` object to the `<iframe>`
    using the `postMessage()` function of the iframe's `contentWindow` property.
  prefs: []
  type: TYPE_NORMAL
- en: The `postMessage()` function takes two arguments – the first is what to post,
    which in this case is our `message` object, and the second argument specifies
    which files can receive the message. We set this to a wildcard `*` so that any
    files can subscribe to our message.
  prefs: []
  type: TYPE_NORMAL
- en: If there aren't any stored contacts, the `context` property of our `message`
    object will have the falsey value `null`. In this case we simply create a new
    `<li>` element with a text message advising that there are no saved contacts and
    append this directly to the empty `<ul>` hardcoded into `popup.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Our script file `popup.js` will also need to receive messages. We use the standard
    JavaScript `addEventListener()` function to attach a listener for `message` events
    to the `window`. By default jQuery does not handle `message` events.
  prefs: []
  type: TYPE_NORMAL
- en: The messages received by `popup.js` will be the response from the sandboxed
    page containing the HTML markup to render. The markup will be contained in a property
    called `markup`, which will be contained in the `data` property of the event object.
    We simply select the `<ul>` element in `popup.html` and append the markup we receive.
  prefs: []
  type: TYPE_NORMAL
- en: We also added some code to `template.js`, the script file referenced by the
    page inside our `<iframe>`. We used the `addEventListener()` function here to
    subscribe to message events again.
  prefs: []
  type: TYPE_NORMAL
- en: This time we first check whether the `command` property of the object sent as
    the message is equal to `issueTemplate`. If it is, we then create and render the
    data into our JsRender template and compose a new `message` object containing
    the rendered template markup.
  prefs: []
  type: TYPE_NORMAL
- en: Once the message object has been created we post it back to `popup.js`. We can
    get the `window` object to send the message using the `source` property of the
    event object, and we can specify which files can receive the message using the
    `origin` property of the event object.
  prefs: []
  type: TYPE_NORMAL
- en: These two properties are very similar except that `source` contains a `window`
    object and `origin` contains a filename. The filename will be a special chrome
    extension name. At this point we should be able to launch the popup and see the
    **No contacts** message as we don't have any saved contacts yet.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a content script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're now at the stage where everything is in place to display stored contacts,
    so we can focus on actually getting some contacts. In order to interact with pages
    that the user navigates to in their browser, we need to add a content script.
  prefs: []
  type: TYPE_NORMAL
- en: A content script is just like a regular script, except that it interacts with
    the page being displayed in the browser instead of with the files that make up
    the extension. We'll see that we can post messages between these different areas
    (the page in the browser and the extension) in a similar way that we posted a
    message to our sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we''ll need to add some new files to the `chrome-extension` directory.
    We''ll need a JavaScript file called `content.js` and a style sheet called `content.css`.
    We need to tell our extension to use these files, so we should also add a new
    section to the manifest file (`manifest.json`) we created earlier in the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This new section should be added directly after the sandbox section that we
    added earlier (as before, don't forget to add the trailing comma after the `sandbox`
    property).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we can add the required behavior to `content.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add some basic styling that highlights any elements that contain
    microdata attributes using the `content.css` style sheet. Update this file now
    so that it contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete - Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all we updated our manifest file to include a content script. As I
    mentioned, content scripts are used to interact with the visible page being displayed
    in the browser instead of any files used by the extension.
  prefs: []
  type: TYPE_NORMAL
- en: We can enable a content script using the `content_script` rule in the manifest.
    We need to specify which pages the content script should be loaded into. We use
    a wildcard (`*`) for the `protocol`, `host`, and `path` portions of URLs so that
    the script is loaded when any page is visited.
  prefs: []
  type: TYPE_NORMAL
- en: When using `Schema.org` microdata to describe people, the different bits of
    information that are present are placed within a container (usually a `<div>`
    element although any element can be used) that has the special attribute `itemtype`.
  prefs: []
  type: TYPE_NORMAL
- en: The value of this attribute is a URL that specifies what the data the elements
    it contains describe. So to describe a person, this container would have the URL
    [http://schema.org/Person](http://schema.org/Person). This means that the elements
    the container has in it may have additional attributes that describe a specific
    piece of data, such as a name, or a job title. These additional attributes on
    the elements within the container will be `itemprop`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case we're using a jQuery attribute-contains selector (`*=`) to attempt
    to select elements containing this attribute from the page. If the array the attribute
    selector returns has length (and is therefore not empty), we know that at least
    one of these elements exists on the page and so can process the element further.
  prefs: []
  type: TYPE_NORMAL
- en: The collection of elements with this attribute are stored in a variable called
    `people`. We also create an empty array in the variable `peopleData` ready to
    store all of the information about all of the people found on the page.
  prefs: []
  type: TYPE_NORMAL
- en: We then use jQuery's `each()` method to iterate the elements selected from the
    page. Instead of using `$(this)` inside our `each()` loop, we can use the collection
    of elements that we've already selected from the page, in conjunction with jQuery's
    `eq()` method along with the current index of the loop in order to reference each
    element, which we store in a variable called `person`.
  prefs: []
  type: TYPE_NORMAL
- en: We also create an empty object and store it in a variable called `data` ready
    to store the microdata for each person, and an empty object called `contactMethods`
    as any microdata for a telephone number or e-mail address needs to be added to
    a subobject for our template to consume.
  prefs: []
  type: TYPE_NORMAL
- en: All we do at this point is add a new class name to the container element. We
    can then use the `content.css` style sheet to add some very basic styling to the
    element so that it is brought to the user's attention.
  prefs: []
  type: TYPE_NORMAL
- en: Scraping the page for microdata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've got our content script in place, we can interact with any web
    page that the user of the extension visits and check whether it has any microdata
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, any element containing microdata is highlighted to the user,
    so we need to add the functionality that will allow the user to view the microdata
    and save it if he/she wishes, which is what we'll be covering in this task.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Directly after where we add a class name to each element that has an `itemtype`
    attribute in `content.js`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete - Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last task we added a class name to each container of elements marked
    up with microdata. In this task we're still in the context of the `each()` loop
    that processed each container.
  prefs: []
  type: TYPE_NORMAL
- en: So in the code we added in this task we first call `each()` again, this time
    on the direct children of the container element; we can get these easily using
    jQuery's `children()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this `each()` loop we first get the current item from the existing cached
    `person` variable using the loop counter passed to our iteration function (`j`)
    as an argument for jQuery's `eq()` method. This avoids creating a brand new jQuery
    object inside our loop.
  prefs: []
  type: TYPE_NORMAL
- en: We also store the value of the current element's `itemprop` attribute in a variable
    called `iProp` because we'll need to refer to it a number of times and using a
    nice short variable means less typing for us.
  prefs: []
  type: TYPE_NORMAL
- en: At this point we don't know whether we're dealing with a regular element, or
    an element containing microdata, so we use an `if` statement that checks whether
    the `iProp` variable we just set has a truthy value. If the element doesn't have
    an `itemprop` attribute this variable will hold an empty string, which is falsey
    and stops the code progressing further if the element is just a regular element.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this conditional we know we're dealing with an element containing microdata,
    but there are different formats that the data may take. If the element contains
    an address for example, it won't have any content directly, but will have child
    elements of its own containing the data instead. In this case, the element will
    have an `itemscope` attribute. First we want to process the elements that don't
    contain an `itemscope` attribute so the first branch of our nested conditional
    checks the value returned by selecting the `itemscope` attribute is not an empty
    string.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember our template, we set up a helper function that displayed contact
    information using an object. In order to create this new object instead of creating
    a new property of the `data` object, we use another nested `if` statement to check
    whether the `iProp` variable contains an e-mail or telephone number.
  prefs: []
  type: TYPE_NORMAL
- en: If it does, we add the value of the `iProp` variable as the key of the `contactMethods`
    object, and the text of the element as the value. If the `iProp` variable doesn't
    contain an e-mail address or a telephone number, we set the `iProp` variable as
    a key of the `data` object, and its value as the element's content.
  prefs: []
  type: TYPE_NORMAL
- en: The next branch of the second nested `if` statement is for elements that do
    have an `itemscope` attribute. In this case, we first define an empty array and
    store it in a variable called `content`. We then iterate over the child elements
    using jQuery's `each()` method and push the text content of each element into
    the `content` array.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have iterated over the child elements and populated the array, we can
    then add the current `iProp` variable and the data in the `content` array to our
    `data` object. Any element that has an `itemscope` attribute should still have
    an `itemprop` attribute, so this should still work.
  prefs: []
  type: TYPE_NORMAL
- en: So at this point our data object should be an accurate representation of the
    microdata set on elements inside our main container. Before we do anything with
    them however, we need to check whether the `contentMethods` object has been populated,
    and if so add it to our `data` object.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `hasProps()` function to check whether an object has its own
    properties. The function will receive the object to test as an argument. Inside
    the function we first define the `hasData` variable, which we set to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: We then use a `for in` loop to iterate over each property of the object. For
    each property we check whether the property actually exists on the object and
    was not inherited using JavaScript's `hasOwnProperty()` function. If the property
    does belong to the object, we set the `hasData` to `true` and then break out of
    the loop using `break`.
  prefs: []
  type: TYPE_NORMAL
- en: We then check whether the `contactMethods` object has any properties by passing
    it to our `hasProps()` function, and if it does we add it to the `data` object.
    Finally, once all this processing has been done, we add the `data` object to the
    `peopleData` array we defined at the start of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a mechanism for saving the microdata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, if the page being displayed in Chrome contains any person microdata,
    we'll have an array containing one or more objects that contain the microdata
    and the text it describes. In this task we'll allow the user to store that data
    if he/she wishes.
  prefs: []
  type: TYPE_NORMAL
- en: Because our content script runs in the context of a web page and not our extension,
    we'll need to use messaging once again to pass any gathered data back to the extension
    for storage.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to set up messaging between our content script and the extension, we'll
    need to add a background page. A background page runs continuously while the extension
    is installed and enabled and will allow us to set up handlers to listen and respond
    to messages sent from the content script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Background pages may be HTML or JavaScript. In this project we''ll use the
    JavaScript version. Create a new file now and save it in the `chrome-extension`
    directory as `background.js`. We also need to register this file as a background
    script by adding a new `background` section to the `manifest.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code should come directly after the array listing the `content_scripts`.
    Again, don't forget the trailing comma after the array.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we''ll add the required behavior to our background page. In `background.js`,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in `content.js`, directly after where we pushed a `data` object into
    the `peopleData` array, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can add a little styling for the new save link that we just added.
    In `content.css`, add the following code at the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Objective Complete - Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added quite a lot of code in this task as there were a number of different
    files that we updated in order to get the different parts of the extension communicating.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the communication module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First of all we updated the behavior page that we added at the start of the
    task. We'll be using localStorage to store saved contacts gathered by the extension,
    but the content script that runs in the context of web pages viewed by the user
    of the extension only has access to the localStorage area for any given page,
    but we need access to the localStorage area for the extension itself.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, our `background.js` file will act as a mediator that will access
    the extension's localStorage area and pass data back and forth between the content
    script and the extension.
  prefs: []
  type: TYPE_NORMAL
- en: First we added a listener to the `onConnect` event, which we can access via
    Chrome's `extension` utility module. When a content script makes a connection
    to the extension, a port will be opened automatically by the browser. An object
    representing this port will be passed to our handler function automatically.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the port to add an event handler for message events. As with our
    simple `<iframe>` messaging from earlier in the project, this handler function
    will automatically be passed the message that triggers the event.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the message handler, we check whether the message's `command` property
    is equal to `getData`. If it is, we first create a `contacts` object, which will
    consist of either the contacts obtained from the localStorage `getItem()`method,
    or a very simple JSON object that simply contains the message `no contacts`, which
    we can create manually.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have either of these JSON objects, we can then parse it into a proper
    JavaScript object using Chrome's native JSON `parse()` method. We can then pass
    this object back to the port using the `postMessage()` method. A new port will
    be opened whenever a new connection is made, so messages will automatically be
    passed back to the correct port without additional configuration by us.
  prefs: []
  type: TYPE_NORMAL
- en: If the `command` property of the `msg` object does not equal `getData`, it may
    equal `setData` instead. If it does, we want to store one or more new contacts
    to localStorage. In this case we'll pass the contacts to store as an object contained
    in the `contacts` property of the `msg` object, so we can simply use the `stringify()`
    method on the object in this property as the second argument to the `setItem()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We can then pass back a short message confirming that saving the data has been
    a success using the `port` object's `postMessage()` method once more.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the content script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Secondly we updated the `content.js` file in order to harvest and store any
    contact information found on the web page being viewed by the visitor.
  prefs: []
  type: TYPE_NORMAL
- en: We started out by adding a new `<a>` element that will be used as a button to
    save contact information and which will be added to any element containing microdata.
    We added a simple `# href` attribute to the new element, a class name for styling
    purposes, and the text `Save`.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the new functionality is contained in a click event handler attached
    directly to each new `<a>` element when it is created using jQuery's `on()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Within this event handler we first stop the default behavior of the browser
    using `preventDefault()`, as we usually do when attaching event handlers to `<a>`
    elements. We then cache a reference to the current `<a>` element by storing `$(this)`
    in a variable called `el`. We also open up a new port to handle our communication
    needs using the `extension` module's `connect()` method. A `contacts` variable
    is declared but not defined straight away.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code resides within an `if` conditional that checks the element
    does not already have the class name `app-saved`, which will help prevent duplicate
    entries for the same person on a single page being saved to localStorage.
  prefs: []
  type: TYPE_NORMAL
- en: In the conditional we first need to get any previously stored contacts, so we
    request the saved contacts from the behavior page by posting a message to the
    port we opened a moment ago. We send an object as the message which has a `command`
    property set to `getData`.
  prefs: []
  type: TYPE_NORMAL
- en: We then add a handler for the response to this message using the `addListener()`
    method on the `onMessage` event. The rest of our code is within this handler,
    which consists of another conditional that reacts differently depending on the
    response message.
  prefs: []
  type: TYPE_NORMAL
- en: The first branch of the conditional deals with when the `message` property of
    the response `msg` contains the string `no contacts`. In this case we create a
    new array which contains the contact information harvested from the person for
    whichever save link was clicked. We already have this information in the `peopleData`
    array and as we're still inside the loop that updates each person, we can use
    the `i` variable to store the correct person.
  prefs: []
  type: TYPE_NORMAL
- en: We can then send this array to the behavior page for permanent storage in the
    extension's localStorage area.
  prefs: []
  type: TYPE_NORMAL
- en: If the `msg` object doesn't have a `message` property it may have a `contacts`
    property instead. This property will contain the array of previously stored contacts
    so we can save the array to a variable, and add the new contact to this array
    before posting the updated array back to the behavior page for permanent storage.
  prefs: []
  type: TYPE_NORMAL
- en: The final branch of the conditional deals with a successful save of the contact.
    In this case the `message` property of the `msg` object will contain the `success`
    string. In this case we add the class name `app-saved` to the `<a>` element and
    change the text to `Contact information saved`. As the port is no longer required
    we can close it using the `disconnect()` method of the `port` object.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the simple styling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lastly we added some very simple styling for the save links. It's important
    to show feedback once the operation that the user initiates has completed.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we do that by changing the text of the link simply making it
    more opaque using CSS to make it look as if it is no longer clickable, which is
    the case because of the `if` statement we used in the script.
  prefs: []
  type: TYPE_NORMAL
- en: At this point we should now be able to browse to a page that contains microdata
    and save contact information. When the browser action button is clicked, we'll
    see the popup, which should display the saved contact, as shown in the screenshot
    at the start of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When testing content scripts, it's important to realize that whenever any of
    the content files change, which in this case means either the JavaScript file
    or the style sheet, the extension must be reloaded.
  prefs: []
  type: TYPE_NORMAL
- en: To reload the extension, there's a **Reload** (*Ctrl* + *R*) link below the
    extension listed on Chrome's **Extensions** page. We'll need to click on this
    link to apply changes made to any of the content files. Other parts of the extension,
    such as the popup files for example, do not require that the extension be reloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful tool for extension programmers is the developer tool, which can
    be opened specifically to monitor the code in the background page. This can be
    useful for troubleshooting errors and script debugging when using a background
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Accomplished
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project we've covered most of the basics of building a Chrome extension.
    We covered creating a browser action that triggers a popup when it is clicked
    in order to display saved contacts.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how we can safely sandbox pages that need to run dangerous code
    such as `eval()` or `new Function` in order to protect our extension from XSS
    attacks, and how we can use the simple messaging API to send messages and receive
    responses to an `<iframe>` element containing the sandboxed page.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that as well as defining scripts that run in the context of the extension,
    we can also add content scripts that run in the context of the web page being
    displayed in the browser. We also learned how to use the `manifest.json` file
    to specify these different areas of our extension.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw that we can use a much more advanced messaging system that allows
    us to open ports that allow for more than simple one-way messages. Communicating
    via ports allows us to send as many messages back and forth from different areas
    of our extension as we need to in order to complete a given task such as saving
    data to the extension's localStorage area.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the type of data that can be described using `Schema.org`
    microdata, and the HTML attributes that can be added to elements in order to do
    the describing. As well as being able to describe people, there are also `Schema.org`
    formats for describing places, companies, movies, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: We've learned a lot about creating extensions in Chrome, but we've also used
    a ton of jQuery methods in order to simplify the scripts that we've written to
    power the extension.
  prefs: []
  type: TYPE_NORMAL
- en: You Ready To Go Gung HO? A Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When our extension saves new contacts, the highlighted elements representing
    the elements containing microdata are given a new CSS class name and have some
    very minimal additional styling added to them.
  prefs: []
  type: TYPE_NORMAL
- en: This is ok, but a better way of confirming success would be to make use of Chrome's
    desktop notification system to generate growl-style pop-up notifications that
    confirm success instead.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the notification documentation at [http://developer.chrome.com/extensions/notifications.html](http://developer.chrome.com/extensions/notifications.html)
    and see if you can update the extension to include this feature.
  prefs: []
  type: TYPE_NORMAL
