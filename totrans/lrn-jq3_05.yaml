- en: Manipulating the DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Web experience is a partnership between web servers and web browsers. Traditionally,
    it has been the domain of the server to produce an HTML document that is ready
    for consumption by the browser. The techniques we have seen in this book have
    shifted this arrangement slightly, using CSS techniques to alter the appearance
    of the HTML document on the fly. To really flex our JavaScript muscles, though,
    you'll need to learn to alter the document itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the document using the interface provided by the **Document Object
    Model** (**DOM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating elements and text on a page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving or deleting elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming a document by adding, removing, or modifying attributes and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating attributes and properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the first four chapters of this book, we have been using the `.addClass()`
    and `.removeClass()` methods to demonstrate how we can change the appearance of
    elements on a page. Although we discussed these methods informally in terms of
    manipulating the `class` attribute, jQuery actually modifies a DOM property called
    `className`. The `.addClass()` method creates or adds to the property, while `.removeClass()`
    deletes or shortens it. Add to these the `.toggleClass()` method, which alternates
    between adding and removing class names, and we have an efficient and robust way
    of handling classes. These methods are particularly helpful in that they avoid
    adding a class if it already exists on an element (so we don't end up with `<div
    class="first first">`, for example), and correctly handle cases where multiple
    classes are applied to a single element, such as `<div class="first second">`.
  prefs: []
  type: TYPE_NORMAL
- en: Non-class attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may need to access or change several other attributes or properties from
    time to time. For manipulating attributes such as `id`, `rel`, and `href`, jQuery
    provides the `.attr()` and `.removeAttr()` methods. These methods make changing
    an attribute a simple matter. In addition, jQuery lets us modify more than one
    attribute at a time, similar to the way we worked with multiple CSS properties
    using the `.css()` method in [Chapter 4](6544cf68-239c-4a0b-99f6-2d128dc5f7b1.xhtml),
    *Styling and Animating*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can easily set the `id`, `rel`, and `title` attributes for
    links all at once. Let''s start with some sample HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Getting the example code
  prefs: []
  type: TYPE_NORMAL
- en: You can access the example code from the following GitHub repository: [https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can iterate through each of the links inside `<div class="chapter">`
    and apply attributes to them one by one. If we need to set a single attribute
    value for all of the links, we can do so with a single line of code within our
    `$(() => {})` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like the `.css()` method, `.attr()` can accept a pair of parameters, the
    first specifying the attribute name and the second being its new value. More typically,
    though, we supply an object of key-value pairs, as we have in *Listing 5.1*. The
    following syntax allows us to easily expand our example to modify multiple attributes
    at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.2
  prefs: []
  type: TYPE_NORMAL
- en: Value callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The straightforward technique for passing `.attr()` a simple object is sufficient
    when we want the attribute or attributes to have the same value for each matched
    element. Often, though, the attributes we add or change must have different values
    each time. One common example is that for any given document, each `id` value
    must be unique if we want our JavaScript code to behave predictably. To set a
    unique `id` value for each link, we can harness another feature of jQuery methods
    such as `.css()` and `.each()`--**value callbacks**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A value callback is simply a function that is supplied instead of the value
    for an argument. This function is then invoked once per element in the matched
    set. Whatever data is returned from the function is used as the new value for
    the attribute. For example, we can use the following technique to generate a different
    `id` value for each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.3
  prefs: []
  type: TYPE_NORMAL
- en: Each time our value callback is fired, it is passed an integer indicating the
    iteration count; we're using it here to give the first link an `id` value of `wikilink-0`,
    the second `wikilink-1`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using the `title` attribute to invite people to learn more about the
    linked term at Wikipedia. In the HTML tags we have used so far, all of the links
    point to Wikipedia. However, to account for other types of links, we should make
    the selector expression a little more specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.4
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our tour of the `.attr()` method, we''ll enhance the `title` attribute
    of these links to be more specific about the link destination. Once again, a value
    callback is the right tool for the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.5
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we''ve taken advantage of the context of value callbacks. Just as
    with event handlers, the keyword `this` points to the DOM element we''re manipulating
    each time the callback is invoked. Here, we''re wrapping the element in a jQuery
    object so that we can use the `.text()` method (introduced in [Chapter 4](6544cf68-239c-4a0b-99f6-2d128dc5f7b1.xhtml),
    *Styling and Animating*) to retrieve the textual content of the link. This makes
    each link title different from the rest, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Data attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML5 data attributes allow us to attach arbitrary data values to page elements.
    Our jQuery code can then use these values, as well as modify them. The reason
    for using data attributes is so that we can separate DOM attributes that control
    how they're displayed and how they behave, from data that's specific to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll use the `data()` jQuery method to read data values and to change data
    values. Let''s add some new functionality that allows the user to mark a paragraph
    as read by clicking on it. We''ll also need a checkbox that hides paragraphs that
    have been marked as read. We''ll use data attributes to help us remember which
    paragraphs have been marked as read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.6
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on a paragraph, the text is marked with a like through it to
    indicate that it has been read:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Screen-Shot-2017-01-08-at-12.21.23-PM.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the click event handler changes the visual appearance of paragraphs
    when they're clicked on. But the handler does something else too--it toggles the
    `read` data for the element: `data('read', !$(e.target).data('read'))` . This
    lets us tie application-specific data to the element, in a way that doesn't interfere
    with other HTML attributes that we might set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change handler for the Hide read paragraphs checkbox looks for paragraphs
    that have this data. The `filter((i, p) => $(p).data(''read''))` call will only
    return paragraphs that have a `read` data attribute with a value of `true`. We''re
    now able to filter elements based on specific application data. Here''s what the
    page looks like with read paragraphs hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Screen-Shot-2017-01-08-at-12.33.01-PM.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll revisit some advanced usage scenarios of data handling with jQuery later
    in the book.
  prefs: []
  type: TYPE_NORMAL
- en: DOM element properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, there is a subtle distinction between HTML **attributes**
    and DOM **properties**. Attributes are the values given in quotation marks in
    the HTML source for the page, while properties are the values as accessed by JavaScript.
    We can observe attributes and properties easily in a developer tool like Chrome''s:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Screen-Shot-2017-01-08-at-5.29.42-PM.png)'
  prefs: []
  type: TYPE_IMG
- en: The Chrome Developer Tool's elements inspector shows us that the highlighted
    `<p>` element has an attribute called `class` with the value `square`. In the
    right panel, we can see that this element has a corresponding property called
    `className` with the value `square`. This illustrates one of the rare situations
    in which an attribute and its equivalent property have different names.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, attributes and properties are functionally interchangeable,
    and jQuery takes care of the naming inconsistencies for us. However, at times
    we do need to be mindful of the differences between the two. Some DOM properties,
    such as `nodeName`, `nodeType`, `selectedIndex`, and `childNodes`, have no equivalent
    attribute and therefore are not accessible via `.attr()`. Moreover, data types
    may differ: the `checked` attribute, for example, has a string value, while the
    `checked` property has a Boolean value. For these Boolean attributes, it is best
    to test and set the *property* rather than the *attribute* to ensure consistent
    cross-browser behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get and set properties from jQuery using the `.prop()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `.prop()` method has all the same features as `.attr()`, such as accepting
    an object of multiple values to set at the same time and taking value callback
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: The value of form controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most troublesome difference between attributes and properties arises
    when trying to get or set the value of a form control. For text inputs, the `value`
    attribute is equivalent to the `defaultValue` property, not the `value` property.
    For `select` elements, the value is usually obtained via the element's `selectedIndex`
    property or the `selected` property of its `option` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of these discrepancies, we should avoid using `.attr()`--and, in the
    case of `select` elements, even `.prop()`--to get or set form element values.
    Instead, we can use the `.val()` method, which jQuery provides for these occasions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As with `.attr()` and `.prop()`, `.val()` can take a function for its setter
    argument. With its multipurpose `.val()` method, jQuery yet again makes developing
    for the web much easier.
  prefs: []
  type: TYPE_NORMAL
- en: DOM tree manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `.attr()` and `.prop()` methods are very powerful tools, and with them we
    can make targeted changes to the document. We still haven't seen ways to change
    the overall structure of the document though. To actually manipulate the DOM tree,
    you'll need to learn a bit more about the function that lies at the very heart
    of the `jQuery` library.
  prefs: []
  type: TYPE_NORMAL
- en: The $() function revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the start of this book, we've been using the `$()` function to access elements
    in a document. As we've seen, this function acts as a factory, producing new jQuery
    objects that point to the elements described by CSS selectors.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't all that the `$()` function can do. It can also change the contents
    of a page. Simply by passing a snippet of HTML code to the function, we can create
    an entirely new DOM structure.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility reminder
  prefs: []
  type: TYPE_NORMAL
- en: We should keep in mind, once again, the inherent danger in making certain functionality,
    visual appeal, or textual information available only to those with web browsers
    capable of (and enabled for) using JavaScript. Important information should be
    accessible to all, not just people who happen to be using the right software.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A feature commonly seen on FAQ pages is the back to top link that appears after
    each question-and-answer pair. It could be argued that these links serve no semantic
    purpose, and therefore they can be legitimately included via JavaScript as an
    enhancement for a subset of the visitors to a page. For our example, we''ll add
    a back to top link after each paragraph, as well as the anchor to which the back
    to top links will take us. To begin, we simply create the new elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.7
  prefs: []
  type: TYPE_NORMAL
- en: We've created a back to top link in the first line of code and a target anchor
    for the link in the second line. However, no back to top links appear on the page
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: While the two lines of code that we've written do indeed create the elements,
    they don't yet add the elements to the page. We need to tell the browser where
    these new elements should go. To do that, we can use one of the many jQuery **insertion
    methods**.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting new elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `jQuery` library has a number of methods available for inserting elements
    into the document. Each one dictates the relationship the new content will have
    to the existing content. For example, we will want our back to top links to appear
    after each paragraph, so we''ll use the appropriately named `.insertAfter()` method
    to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.8
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that we''ve actually inserted the links into the page (and into the
    DOM) after each paragraph that appears within `<div class="chapter">`, the back
    to top links will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the new links appear on their own line, not within the paragraph.
    This is because the `.insertAfter()` method, and its counterpart `.insertBefore()`,
    add content *outside* the specified element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the links won''t work yet. We still need to insert the anchor
    with `id="top"`. This time, we''ll use one of the methods that insert elements
    *inside* of other elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.9
  prefs: []
  type: TYPE_NORMAL
- en: This additional code inserts the anchor right at the beginning of the `<body>`
    tag; in other words, at the top of the page. Now, with the `.insertAfter()` method
    for the links and the `.prependTo()` method for the anchor, we have a fully functioning
    set of back to top links for the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we add the corresponding `.appendTo()` method, we now have a complete
    set of options for inserting new elements before and after other elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.insertBefore()`: Adds content *outside of* and *before* existing elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.prependTo()`: Adds content *inside of* and *before* existing elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.appendTo()`: Adds content *inside of* and *after* existing elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.insertAfter()`: Adds content *outside of* and *after* existing elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When adding the back to top links, we created new elements and inserted them
    on the page. It''s also possible to take elements from one place on the page and
    insert them into another place. A practical application of this type of insertion
    is the dynamic placement and formatting of footnotes. One footnote already appears
    in the original *Flatland* text that we are using for this example, but we''ll
    also designate a couple of other portions of the text as footnotes for the purpose
    of this demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our HTML document contains three footnotes; the previous paragraph contains
    one example. The footnote text is inside the paragraph text, set apart using `<span
    class="footnote"></span>`. By marking up the HTML document in this way, we can
    preserve the context of the footnote. A CSS rule applied in the stylesheet italicizes
    the footnotes, so an affected paragraph initially looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we need to grab the footnotes and move them to the bottom of the document.
    Specifically, we'll insert them in between `<div class="chapter">` and `<div id="footer">`.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that even in cases of implicit iteration, the order in which elements
    are processed is precisely defined, starting at the top of the DOM tree and working
    down. Since it's important to maintain the correct order of the footnotes in their
    new place on the page, we should use `.insertBefore('#footer')`. This will place
    each footnote directly before the `<div id="footer">` element so that the first
    footnote is placed between `<div class="chapter">` and `<div id="footer">`, the
    second footnote is placed between the first footnote and `<div id="footer">`,
    and so on. Using `.insertAfter('div.chapter')`, on the other hand, would cause
    the footnotes to appear in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, our code looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.10
  prefs: []
  type: TYPE_NORMAL
- en: 'The footnotes are in `<span>` tags, which means they display inline by default,
    one right after the other with no separation. However, we''ve anticipated this
    in the CSS, giving `span.footnote` elements a `display` value of `block` when
    they are outside of `<div class="chapter">`. So, the footnotes are now beginning
    to take shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_05_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The footnotes are in the proper position now, yet there is still a lot of work
    that can be done to them. A more robust footnote solution should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Number each footnote.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mark the location in the text from which each footnote is pulled using the number
    of the footnote.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a link from the text location to its matching footnote, and from the
    footnote back to the location in the text from which each footnote is pulled using
    the number of the footnote.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrapping elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To number the footnotes, we could explicitly add numbers in the markup, but
    here we can take advantage of the standard ordered list element that takes care
    of numbering for us. To do this, we need to create a containing `<ol>` element
    surrounding all of the footnotes and an `<li>` element surrounding each one individually.
    To achieve this, we'll use **wrapping methods**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When wrapping elements in another element, we need to be clear about whether
    we want each element wrapped in its own container or all elements wrapped in a
    single container. For our footnote numbering, we need both types of wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.11
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have inserted the footnotes before the footer, we wrap the entire set
    inside a single `<ol>` element using `.wrapAll()`. We then proceed to wrap each
    individual footnote inside its own `<li>` element using `.wrap()`. We can see
    that this has created properly numbered footnotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_05_09.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we're ready to mark and number the place from which we're pulling the footnote.
    To do this in a straightforward manner, though, we need to rewrite our existing
    code so that it doesn't rely on implicit iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `.each()` method, which acts as an **explicit iterator**, is very similar
    to the `forEach` array iterator that was recently added to the JavaScript language.
    The `.each()` method can be employed when the code we want to use on each of the
    matched elements is too complex for the implicit iteration syntax. It is passed
    a callback function that will be called once for each element in the matched set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.12
  prefs: []
  type: TYPE_NORMAL
- en: The motivation for our change here will become clear shortly. First, we need
    to understand the information that's provided to our `.each()` callback.
  prefs: []
  type: TYPE_NORMAL
- en: In *Listing 5.12*, we use the `span` parameter to create a jQuery object pointing
    to a single footnote, `<span>`, then we append the element to the notes `<ol>`,
    and finally wrap the footnote inside an `<li>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark the locations in the text from which the footnotes were pulled, we
    can take advantage of the `.each()` callback''s parameter. This parameter provides
    the iteration count, starting at `0` and incrementing each time the callback is
    invoked. Therefore, this counter will always be 1 less than number of the footnote.
    We''ll account for this fact when producing the appropriate labels in the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.13
  prefs: []
  type: TYPE_NORMAL
- en: Now, before each footnote is pulled out of the text to be placed at the bottom
    of the page, we create a new `<sup>` element containing the footnote's number
    and insert it into the text. The order of actions is important here; we need to
    make sure that the marker is inserted before the footnote is moved, or else we
    lose track of its initial position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at our page again, now we can see footnote markers where the inline
    footnotes used to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_05_10.png)'
  prefs: []
  type: TYPE_IMG
- en: Using inverted insertion methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Listing 5.13*, we inserted content before an element, then appended that
    same element to another place in the document. Typically, when working with elements
    in jQuery, we can use chaining to perform multiple actions succinctly and efficiently.
    We weren't able to do that here, though, because `this` is the *target* of `.insertBefore()`
    and the *subject* of `.appendTo()`. The **inverted insertion methods** will help
    us get around this limitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the insertion methods, such as `.insertBefore()` or `.appendTo()`,
    has a corresponding inverted method. The inverted methods perform exactly the
    same task as the standard ones, but the subject and target are reversed. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `.before()`, the inverted form of `.insertBefore()`, we can now re-factor
    our code to exploit chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.14
  prefs: []
  type: TYPE_NORMAL
- en: Insertion method callbacks
  prefs: []
  type: TYPE_NORMAL
- en: The inverted insertion methods can accept a function as an argument, much like
    `.attr()` and `.css()` can. This function is invoked once per target element,
    and should return the HTML string to be inserted. We could use this technique
    here, but since we will encounter several such situations for each footnote, the
    single `.each()` call will end up being the cleaner solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re now ready to take care of the final step in our checklist: create a
    link from the text location to its matching footnote, and from the footnote back
    to the text location. We''ll need four pieces of markup per footnote to achieve
    this: two links, one in the text and one after the footnote, and two `id` attributes
    in those same locations. Because the argument to the `.before()` method is about
    to get complex, this is a good time to introduce a new notation for string creation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Listing 5.14,* we prepare our footnote marker using a **template string**.
    This is a very useful technique, but for joining a large number of strings it
    can start to look cluttered. Instead, we can use the array method `.join()` to
    construct the larger string. The following statements have the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'While it requires a few more characters to type in this example, the `.join()`
    method can add clarity when otherwise difficult to read string concatenation or
    string templates. Let''s look at our code again, this time using `.join()` to
    create the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.15
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this technique, we can augment the footnote marker with a link to the
    bottom of the page as well as a unique `id` value. While we''re at it, we''ll
    also add an `id` for the `<li>` element, so the link has a destination to point
    at, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.16
  prefs: []
  type: TYPE_NORMAL
- en: 'With the additional markup in place, each footnote marker now links down to
    the corresponding footnote at the bottom of the document. All that remains is
    to create a link back from the footnote to its context. For this, we can employ
    the inverse of the `.appendTo()` method, `.append()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.17
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `href` tag points back to the `id` value of the corresponding
    marker. In the following screenshot, you can see the footnotes again, except this
    time with the new link appended to each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_05_11.png)'
  prefs: []
  type: TYPE_IMG
- en: Copying elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we have inserted newly created elements, moved elements
    from one location in the document to another, and wrapped new elements around
    existing ones. Sometimes, though, we may want to copy elements. For example, a
    navigation menu that appears in the page's header could be copied and placed in
    the footer as well. Whenever elements can be copied to enhance a page visually,
    we can let jQuery do the heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: For copying elements, jQuery's `.clone()` method is just what we need; it takes
    any set of matched elements and creates a copy of them for later use. As in the
    case of the `$()` function's element creation process we explored earlier in this
    chapter, the copied elements will not appear in the document until we apply one
    of the insertion methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following line creates a copy of the first paragraph inside
    `<div class="chapter">`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This alone is not enough to change the content of the page. We can make the
    cloned paragraph appear before `<div class="chapter">` with an insertion method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the first paragraph to appear twice. So, to use a familiar analogy,
    `.clone()` is related to the insertion methods just as *copy* is to *paste*.
  prefs: []
  type: TYPE_NORMAL
- en: Clone with events
  prefs: []
  type: TYPE_NORMAL
- en: The `.clone()` method, by default, does not copy any events that are bound to
    the matching element or any of its descendants. However, it can take a single
    Boolean parameter that, when set to true (`.clone(true)`), clones events as well.
    This convenient event cloning allows us to avoid having to deal with manually
    rebinding events, as was discussed in [Chapter 3](2036c6b0-e8c5-405a-b54b-b3f31eab404c.xhtml),
    *Handling Events*.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning for pull quotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many websites, like their print counterparts, use **pull quotes** to emphasize
    small portions of text and attract the reader''s eye. A pull quote is simply an
    excerpt from the main document that is presented with a special graphical treatment
    alongside the text. We can easily accomplish this embellishment with the `.clone()`
    method. First, let''s take another look at the third paragraph of our example
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that the paragraph begins with `<span class="pull-quote">`. This is the
    class we will be targeting for cloning. Once the copied text inside that `<span>`
    tag is pasted into another place, we need to modify its style properties to set
    it apart from the rest of the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this type of styling, we''ll add a `pulled` class to the copied
    `<span>`. In our stylesheet, that class receives the following style rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: An element with this class is visually differentiated from the main content
    by applying style rules for background, border, font, and so on. Most importantly,
    it's absolutely positioned, 20 pixels above and 20 pixels to the right of the
    nearest (`absolute` or `relative`) positioned ancestor in the DOM. If no ancestor
    has positioning (other than `static`) applied, the pull quote will be positioned
    relative to the document `<body>`. Because of this, we need to make sure in the
    jQuery code that the cloned pull quote's parent element has `position:relative`
    set.
  prefs: []
  type: TYPE_NORMAL
- en: CSS position calculation
  prefs: []
  type: TYPE_NORMAL
- en: While the top positioning is fairly intuitive, it may not be clear at first
    how the pull quote box will be located 20 pixels to the right of its positioned
    parent. We derive the number first from the total width of the pull-quote box,
    which is the value of the `width` property plus the left and right padding, or
    `145px + 5px + 10px = 160px`. We then set the `right` property of the pull quote.
    A value of `0` would align the pull quote's right side with that of its parent.
    Therefore, to place its left side 20 pixels to the right of the parent, we need
    to move it in a negative direction 20 pixels more than its total width, or `-180px`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can consider the jQuery code needed to apply this style. We''ll start
    with a selector expression to find all of the `<span class="pull-quote">` elements
    and apply the `position: relative` style to each parent element as we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.18
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create the pull quote itself, taking advantage of the CSS
    we''ve prepared. We need to clone each `<span>` tag, add the `pulled` class to
    the copy, and insert it into the beginning of its parent paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.19
  prefs: []
  type: TYPE_NORMAL
- en: Because we're using absolute positioning for the pull quote, the placement of
    it within the paragraph is irrelevant. As long as it remains inside the paragraph,
    it will be positioned in relation to the top and the right of the paragraph, based
    on our CSS rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pull quote now appears alongside its originating paragraph, as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_05_12.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a good start. For our next enhancement, we'll clean up the content of
    the pull quotes a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Content getter and setter methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be nice to be able to modify the pull quote a bit by dropping some
    words and replacing them with ellipses to keep the content brief. To demonstrate
    this, we have wrapped a few words of the example text in a `<span class="drop">`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to accomplish this replacement is to directly specify the new
    HTML entity that is to replace the old one. The `.html()` method is perfect for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.20
  prefs: []
  type: TYPE_NORMAL
- en: The new lines in *Listing 5.20* rely on the DOM traversal techniques we learned
    in [Chapter 2](195342ed-f533-42e7-8a8d-f9a3462382b7.xhtml), *Selecting Elements*.
    We use `.find()` to search inside the pull quote for any `<span class="drop">`
    elements, operate on them, and then return to the pull quote itself by calling
    `.end()`. In between these methods, we invoke `.html()` to change the content
    into an ellipsis (using the appropriate HTML entity).
  prefs: []
  type: TYPE_NORMAL
- en: When called without arguments, `.html()` returns a string representation of
    the HTML entity inside the matched element. With an argument, the contents of
    the element are replaced by the supplied HTML entity. We must take care to only
    specify a valid HTML entity, escaping special characters properly when using this
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specified words have now been replaced by an ellipsis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_05_13.png)'
  prefs: []
  type: TYPE_IMG
- en: Pull quotes typically do not retain their original font formatting, such as
    the boldfaced one more side text in this example. What we really want to display
    is the text of `<span class="pull-quote">` stripped of any `<strong>`, `<em>`,
    `<a href>`, or other inline tags. To replace all of the pull-quote HTML entities
    with a stripped, text-only version, we can employ the`.html()` method's companion
    method, `.text()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `.html()`, the `.text()` method can either retrieve the content of the
    matched element or replace its content with a new string. Unlike `.html()`, however,
    `.text()` always gets or sets a plain text string. When `.text()` retrieves content,
    all of the included tags are ignored, and HTML entities are translated into plain
    characters. When it sets content, special characters such as `<` are translated
    into their HTML entity equivalents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Listing 5.21
  prefs: []
  type: TYPE_NORMAL
- en: When you retrieve values using `text()`, the markup is removed. This is exactly
    what we're trying to accomplish with this example. As with some of the other jQuery
    functions that you've learned about so far, `text()` accepts a function. The return
    value is used to set the text of the element, while the current text is passed
    in as the second argument. So to strip tags from element text, just call `text((i,
    text) => text)`. Awesome!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the results of this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_05_14.png)'
  prefs: []
  type: TYPE_IMG
- en: DOM manipulation methods in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The extensive DOM manipulation methods that jQuery provides vary according
    to their task and their target location. We haven''t covered them all here, but
    most are analogous to the ones we''ve seen, and more will be discussed in [Chapter
    12](0446c068-e7fd-426a-ab8b-0157b1387e1f.xhtml), *Advanced DOM Manipulation*.
    The following outline can serve as a reminder of which method we can use to accomplish
    which task:'
  prefs: []
  type: TYPE_NORMAL
- en: To *create* new elements from HTML, use the `$()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To *insert* new elements *inside* every matched element, use the following
    functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.append()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.appendTo()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.prepend()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.prependTo()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To *insert* new elements *adjacent to* every matched element, use the following
    functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.after()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.insertAfter()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.before()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.insertBefore()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To *insert* new elements *around* every matched element, use the following
    functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.wrap()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.wrapAll()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.wrapInner()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To *replace* every matched element with new elements or text, use the following
    functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.html()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.text()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.replaceAll()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.replaceWith()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To *remove* elements inside every matched element, use the following function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.empty()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To *remove* every matched element and descendants from the document without
    actually deleting them, use the following functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.remove()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.detach()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have created, copied, reassembled, and embellished content
    using jQuery's DOM modification methods. We've applied these methods to a single
    web page, transforming a handful of generic paragraphs to a footnoted, pull-quoted,
    linked, and stylized literary excerpt. This chapter has shown us just how easy
    it is to add, remove, and rearrange the contents of a page with jQuery. In addition,
    you have learned how to make any changes we want to the CSS and DOM properties
    of page elements.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we'll take a round-trip journey to the server via jQuery's Ajax methods.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of DOM manipulation will be explored in more detail in [Chapter 12](0446c068-e7fd-426a-ab8b-0157b1387e1f.xhtml),
    *Advanced DOM Manipulation*. A complete list of DOM manipulation methods is available
    in [Appendix B](d9485d2d-4300-48c1-825b-1c26c9b57a66.xhtml)*, Quick Reference*, of
    this book, or in the official jQuery documentation at [http://api.jquery.com/](http://api.jquery.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The challenge exercises may require the use of the official jQuery documentation
    at `http://api.jquery.com/`.
  prefs: []
  type: TYPE_NORMAL
- en: Alter the code that introduces the back to top links, so that the links only
    appear after the fourth paragraph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a back to top link is clicked on, add a new paragraph after the link containing
    the message You were here. Ensure that the link still works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the author's name is clicked, turn it bold (by adding an element, rather
    than manipulating classes or CSS attributes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Challenge: On a subsequent click of the bolded author''s name, remove the `<b>`
    element that was added (thereby toggling between bold and normal text).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Challenge: Add a class of `inhabitants` to each of the chapter''s paragraphs
    without calling `.addClass()`. Make sure to preserve any existing classes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
