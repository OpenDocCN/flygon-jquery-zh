- en: Selecting Elements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The jQuery library harnesses the power of **Cascading Style Sheets** (**CSS**)
    selectors to let us quickly and easily access elements or groups of elements in
    the **Document Object Model** (**DOM**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the elements on a web page
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use CSS selectors to find elements on the page
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when the specificity of a CSS selector changes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom jQuery extensions to the standard set of CSS selectors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DOM traversal methods, which provide greater flexibility for accessing elements
    on the page
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using modern JavaScript language features to iterate over jQuery objects efficiently
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the DOM
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most powerful aspects of jQuery is its ability to make selecting
    elements in the DOM easy. The DOM serves as the interface between JavaScript and
    a web page; it provides a representation of the source HTML as a network of objects
    rather than as plain text.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'This network takes the form of a family tree of elements on the page. When
    we refer to the relationships that elements have with one another, we use the
    same terminology that we use when referring to family relationships: parents,
    children, siblings, and so on. A simple example can help us understand how the
    family tree metaphor applies to a document:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `<html>` is the ancestor of all the other elements; in other words, all
    the other elements are descendants of `<html>`. The `<head>` and `<body>` elements
    are not only descendants, but children of `<html>` as well. Likewise, in addition
    to being the ancestor of `<head>` and `<body>`, `<html>` is also their parent.
    The `<p>` elements are children (and descendants) of `<div>`, descendants of `<body>`
    and `<html>`, and siblings of each other.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3145OS_02_01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: To help visualize the family tree structure of the DOM, we can use the browser's
    developer tools to inspect the DOM structure of any page. This is especially helpful
    when you're curious about how some other application works, and you want to implement
    something similar.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: With this tree of elements at our disposal, we'll be able to use jQuery to efficiently
    locate any set of elements on the page. Our tools to achieve this are jQuery **selectors**
    and **traversal methods**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Using the $() function
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The resulting set of elements from jQuery's selectors and methods is always
    represented by a jQuery object. These objects are very easy to work with when
    we want to actually do something with the things that we find on a page. We can
    easily bind events to these objects and add visual effects to them, as well as
    chain multiple modifications or effects together.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Note that jQuery objects are different from regular DOM elements or node lists,
    and as such do not necessarily provide the same methods and properties for some
    tasks. In the final part of this chapter, we will look at ways to directly access
    the DOM elements that are collected within a jQuery object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a new jQuery object, we use the `$()` function. This function
    typically accepts a CSS selector as its sole parameter and serves as a factory,
    returning a new jQuery object pointing to the corresponding elements on the page.
    Just about anything that can be used in a stylesheet can also be passed as a string
    to this function, allowing us to apply jQuery methods to the matched set of elements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Making jQuery play well with other JavaScript libraries
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In jQuery, the dollar sign `($)` is simply an alias for `jQuery`. Because a
    `$()` function is very common in JavaScript libraries, conflicts could arise if
    more than one of these libraries were being used in a given page. We can avoid
    such conflicts by replacing every instance of `$` with `jQuery` in our custom
    jQuery code. Additional solutions to this problem are addressed in [Chapter 10](d150ca06-e7dc-4100-8c91-060f0272ff67.xhtml),
    *Advanced Events*. On the other hand, jQuery is so prominent in frontend development,
    that libraries tend to leave the `$` symbol alone.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The three primary building blocks of selectors are **tag name**, **ID**, and
    **class**. They can be used either on their own or in combination with others.
    The following simple examples illustrate how these three selectors appear in code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '| **Selector type** | **CSS** | **jQuery** | **What it does** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| **Tag name** | `p { }` | `$(''p'')` | This selects all paragraphs in the
    document. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| **ID** | `#some-id { }`                             | `$(''#some-id'')`  
                            | This selects the single element in the document that
    has an ID of `some-id`. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| **Class** | `.some-class { }`                                           
        | `$(''.some-class'')`                                         | This selects
    all elements in the document that have a class of `some-class`. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: As mentioned in [Chapter 1](33c0dcc2-d368-4c19-b3aa-15fd462917f8.xhtml), *Getting
    Started*, when we call methods of a jQuery object, the elements referred by the
    selector we passed to `$()` are looped through automatically and implicitly. Therefore,
    we can usually avoid explicit iteration, such as a `for` loop, that is so often
    required in DOM scripting.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Now that we covered the basics, we're ready to start exploring some more powerful
    uses of selectors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: CSS selectors
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The jQuery library supports nearly all the selectors included in CSS specifications
    1 through 3, as outlined on the World Wide Web Consortium''s site: [http://www.w3.org/Style/CSS/specs](http://www.w3.org/Style/CSS/specs).
    This support allows developers to enhance their websites without worrying about
    which browsers might not understand more advanced selectors, as long as the browsers
    have JavaScript enabled.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Progressive Enhancement
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Responsible jQuery developers should always apply the concepts of progressive
    enhancement and graceful degradation to their code, ensuring that a page will
    render as accurately, even if not as beautifully, with JavaScript disabled as
    it does with JavaScript turned on. We will continue to explore these concepts
    throughout the book. More information on progressive enhancement can be found
    at [http://en.wikipedia.org/wiki/Progressive_enhancement](http://en.wikipedia.org/wiki/Progressive_enhancement).
    Having said this, it's not very often that you'll encounter users with JavaScript
    disabled these days--even on mobile browsers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin learning how jQuery works with CSS selectors, we''ll use a structure
    that appears on many websites, often for navigation--the nested unordered list:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Downloadable code examples
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: You can access the example code from the following Github repository: [https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the first `<ul>` has an ID of `selecting-plays`, but none of the
    `<li>` tags have a class associated with them. Without any styles applied, the
    list looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: The nested list appears as we would expect it to--a set of bulleted items arranged
    vertically and indented according to their level.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Styling list-item levels
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s suppose that we want the top-level items, and only the top-level items--Comedies,
    Tragedies, and Histories--to be arranged horizontally. We can start by defining
    a `horizontal` class in the stylesheet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `horizontal` class floats the element to the left-hand side of the one following
    it, removes the bullet from it if it's a list item, and adds a 10-pixel margin
    on all sides of it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than attaching the `horizontal` class directly in our HTML, we''ll add
    it dynamically to the top-level list items only, to demonstrate jQuery''s use
    of selectors:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listing 2.1
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](091dd3f4-9663-47df-af02-817487c3038f.xhtml), *Getting
    Started*, we begin jQuery code by calling `$(() => {})`, which runs the function
    passed to it once the DOM has been loaded, but not before.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The second line uses the child combinator (`>`) to add the `horizontal` class
    to all the top-level items only. In effect, the selector inside the `$()` function
    is saying, "Find each list item (`li`) that is a child (`>`) of the element with
    an ID of `selected-plays` (`#selected-plays`)".
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'With the class now applied, the rules defined for that class in the stylesheet
    take effect, which in this case means that the list items are arranged horizontally
    rather than vertically. Now, our nested list looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_03.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'Styling all the other items--those that are not in the top level--can be done
    in a number of ways. Since we have already applied the `horizontal` class to the
    top-level items, one way to select all sub-level items is to use a negation pseudo-class
    to identify all list items that do not have a class of `horizontal`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Listing 2.2
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we are selecting every list item (`<li>`) that:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Is a descendant of the element with an ID of `selected-plays` (`#selected-plays`)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not have a class of `horizontal`  (`:not(.horizontal)`)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we add the `sub-level` class to these items, they receive the shaded background
    defined in the stylesheet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now the nested list looks like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_04.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Selector specificity
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selectors in jQuery have a spectrum of specificity, from very general selectors,
    to very targeted selectors. The goal is to select the correct elements, otherwise
    your selector is broken. The tendency for jQuery beginners is to implement very
    specific selectors for everything. Perhaps through trial and error, they've fixed
    selector bugs by adding more specificity to a given selector. However, this isn't
    always the best solution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example that increases the size of the first letter for top-level
    `<li>` text. Here''s the style we want to apply:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And here''s what the list item text looks like:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Screenshot-from-2016-11-27-11-02-54-3.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: 'As you see, Comedies, Tragedies, and Histories have the `big-letter` style
    applied to them as expected. In order to do this, we need a selector that''s more
    specific than just `$(''#selected-plays li'')`, which would apply the style to
    every `<li>`, even the sub-elements. We can use change the specificity of the
    jQuery selector to make sure we''re only getting what we expect:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Listing 2.3
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'All three of these selectors do the same thing--apply the `big-letter` style
    to the top-level `<li>` elements in `#selected-plays`. The specificity is different
    in each of these selectors. Let''s review how each of these work, and what their
    strengths are:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '`#selected-plays > li`: This finds `<li>` elements that are direct children
    of `#selected-plays`. This is easy to read, and semantically relevant to the DOM
    structure.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#selected-plays li.horizontal`: This finds `<li>` elements or sub-elements
    of `#selected-plays` with the `horizontal` class. This is also easy to read and
    enforces a particular DOM schema (applying the `horizontal` class).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#selected-plays li:not(.sub-level)`: This is difficult to read, inefficient,
    and doesn''t reflect the actual DOM structure.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are endless examples where selector-selector specificity comes up. Every
    application is unique, and as we just saw, there's no one correct way to implement
    selector specificity. What's important is that we exercise good judgement by considering
    the ramifications of selectors on the DOM structure, and consequently, the maintainability
    of our application or website.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Attribute selectors
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attribute selectors are a particularly helpful subset of CSS selectors. They
    allow us to specify an element by one of its HTML attributes, such as a link''s
    `title` attribute or an image''s `alt` attribute. For example, to select all images
    that have an `alt` attribute, we write the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Styling links
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attribute selectors accept a wildcard syntax inspired by regular expressions
    for identifying the value at the beginning (`^`) or end (`$`) of a string. They
    can also take an asterisk (`*`) to indicate the value at an arbitrary position
    within a string or an exclamation mark (`!`) to indicate a negated value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to have different styles for different types of links. We
    first define the styles in our stylesheet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, we add the three classes--`mailto`, `pdflink`, and `henrylink`--to the
    appropriate links using jQuery.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a class for all e-mail links, we construct a selector that looks for
    all anchor elements (`a`) with an `href` attribute (`[href]`) that begins with
    `mailto:` (`^="mailto:"`), as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Listing 2.4
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the rules defined in the page''s stylesheet, an envelope image appears
    after the mailto: link on the page.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_05-1.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: 'To add a class for all the links to PDF files, we use the dollar sign rather
    than the caret symbol. This is because we''re selecting links with an `href` attribute
    that ends with `.pdf`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 2.5*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The stylesheet rule for the newly added `pdflink` class causes an Adobe Acrobat
    icon to appear after each link to a PDF document, as shown in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_06-1.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: 'Attribute selectors can be combined as well. We can, for example, add the class
    `henrylink` to all links with an `href` value that both starts with `http` and
    contains `henry` anywhere:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Listing 2.6
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'With the three classes applied to the three types of links, we should see the
    following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_07-1.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: Note the PDF icon to the right-hand side of the Hamlet link, the envelope icon
    next to the email link, and the white background and black border around the Henry
    V link.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Custom selectors
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To the wide variety of CSS selectors, jQuery adds its own custom selectors.
    These custom selectors enhance the capabilities of CSS selectors to locate page
    elements in new ways.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Performance note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: When possible, jQuery uses the native DOM selector engine of the browser to
    find elements. This extremely fast approach is not possible when custom jQuery
    selectors are used. For this reason, it is recommended to avoid frequent use of
    custom selectors when a native option is available.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the custom selectors allow us to choose one or more elements from a
    collection of elements that we have already found. The custom selector syntax
    is the same as the CSS pseudo-class syntax, where the selector starts with a colon
    (`:`). For example, to select the second item from a set of `<div>` elements with
    a class of `horizontal`, we write this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that `:eq(1)` selects the second item in the set because JavaScript array
    numbering is zero-based, meaning that it starts with zero. In contrast, CSS is
    one-based, so a CSS selector such as `$('div:nth-child(1)')` would select all
    `div` selectors that are the first child of their parent. Because it can be difficult
    to remember which selectors are zero based and which are one based, we should
    consult the jQuery API documentation at [http://api.jquery.com/category/selectors/](http://api.jquery.com/category/selectors/)
    when in doubt.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Styling alternate rows
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two very useful custom selectors in the jQuery library are `:odd` and `:even`.
    Let''s take a look at how we can use one of them for basic table striping given
    the following tables:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With minimal styles applied from our stylesheet, these headings and tables
    appear quite plain. The table has a solid white background, with no styling separating
    one row from the next, as shown in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_08-1.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can add a style to the stylesheet for all the table rows and use an
    `alt` class for the odd rows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we write our jQuery code, attaching the class to the odd-numbered
    table rows (`<tr>` tags):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 2.7
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait! Why use the `:even` selector for odd-numbered rows? Well, just as
    with the `:eq()` selector, the `:even` and `:odd` selectors use JavaScript''s
    native zero-based numbering. Therefore, the first row counts as zero (even) and
    the second row counts as one (odd), and so on. With this in mind, we can expect
    our simple bit of code to produce tables that look like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_09.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Note that for the second table, this result may not be what we intend. Since
    the last row in the Plays table has the alternate gray background, the first row
    in the Sonnets table has the plain white background. One way to avoid this type
    of problem is to use the `:nth-child()` selector instead, which counts an element''s
    position relative to its parent element rather than relative to all the elements
    selected so far. This selector can take a number, `odd` or `even` as its argument:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Listing 2.8
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, note that `:nth-child()` is the only jQuery selector that is one
    based. To achieve the same row striping as we did earlier--except with consistent
    behavior for the second table--we need to use `odd` rather than `even` as the
    argument. With this selector in place, both tables are now striped nicely, as
    shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_10.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: The `:nth-child()` selector is a native CSS selector in modern browsers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Finding elements based on textual content
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For one final custom selector, let''s suppose for some reason we want to highlight
    any table cell that referred to one of the Henry plays. All we have to do--after
    adding a class to the stylesheet to make the text bold and italicized ( `.highlight
    {font-weight:bold; font-style: italic;}` )--is add a line to our jQuery code using
    the `:contains()` selector:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Listing 2.9
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we can see our lovely striped table with the Henry plays prominently
    featured:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_11.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: It's important to note that the `:contains()` selector is case sensitive. Using
    `$('td:contains(henry)')` instead, without the uppercase "H", would select no
    cells. It's also important to note that `:contains()` can cause catastrophically
    bad performance, since the text of every element that matches the first part of
    the selector needs to be loaded and compared to our supplied argument. When `:contains()`
    has the potential to search hundreds of nodes for content, it's time to rethink
    our approach.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, there are ways to achieve the row striping and text highlighting
    without jQuery--or any client-side programming, for that matter. Nevertheless,
    jQuery, along with CSS, is a great alternative for this type of styling in cases
    where the content is generated dynamically and we don't have access to either
    the HTML or server-side code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Form selectors
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The capabilities of custom selectors are not limited to locating elements based
    on their position. For example, when working with forms, jQuery''s custom selectors
    and complementary CSS3 selectors can make short work of selecting just the elements
    we need. The following table describes a handful of these form selectors:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '| **Selector** | **Match** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `:input` | Input, text area, select, and button elements |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `:button` | Button elements and input elements with a `type` attribute equal
    to `button` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `:enabled` | Form elements that are enabled |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `:disabled` | Form elements that are disabled |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `:checked` | Radio buttons or checkboxes that are checked |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `:selected` | Option elements that are selected |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: As with the other selectors, form selectors can be combined for greater specificity.
    We can, for example, select all checked radio buttons (but not checkboxes) with
    `$('input[type="radio"]:checked')` or select all password inputs and disabled
    text inputs with `$('input[type="password"], input[type="text"]:disabled')`. Even
    with custom selectors, we can use the same basic principles of CSS to build the
    list of matched elements.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: We have only scratched the surface of available selector expressions here. We
    will dive further into the topic in [Chapter 9](27c55a6c-368a-4007-9e8c-1f9d9be254f8.xhtml),
    *Advanced Selectors and Traversing*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: DOM traversal methods
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The jQuery selectors that we have explored so far allow us to select a set of
    elements as we navigate across and down the DOM tree and filter the results. If
    this were the only way to select elements, our options would be somewhat limited.
    There are many occasions when selecting a parent or ancestor element is essential;
    that is where jQuery's DOM traversal methods come into play. With these methods,
    we can go up, down, and all around the DOM tree with ease.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the methods have a nearly identical counterpart among the selector
    expressions. For example, the line we first used to add the `alt` class, `$(''tr:even'').addClass(''alt'')`,
    could be rewritten with the `.filter()` method as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the most part, however, the two ways of selecting elements complement each
    other. Also, the `.filter()` method in particular has enormous power because it
    can take a function as its argument. The function allows us to create complex
    tests for whether elements should be included in the matched set. Let''s suppose,
    for example, that we want to add a class to all external links:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'jQuery has no selector for this sort of thing. Without a filter function, we''d
    be forced to explicitly loop through each element, testing each one separately.
    With the following filter function, however, we can still rely on jQuery''s implicit
    iteration and keep our code compact:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Listing 2.10
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'The supplied function filters the set of `<a>` elements by two criteria:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: They must have an `href` attribute with a domain name (`a.hostname`). We use
    this test to exclude mailto links, for instance.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The domain name that they link to (again, `a.hostname`) must not match (`!==`)
    the domain name of the current page (`location.hostname`).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More precisely, the `.filter()` method iterates through the matched set of elements,
    calling the function once for each and testing the return value. If the function
    returns `false`, the element is removed from the matched set. If it returns `true`,
    the element is kept.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `.filter()` method in place, the Henry V link is styled to indicate
    it is external:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_12.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: In the next section, we'll take another look at our striped table example to
    see what else is possible with traversal methods.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Styling specific cells
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, we added a `highlight` class to all cells containing the text Henry.
    To instead style the cell next to each cell containing Henry, we can begin with
    the selector that we have already written and simply call the `.next()` method
    on the result:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Listing 2.11
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The tables should now look like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_13.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'The `.next()` method selects only the very next sibling element. To highlight
    all of the cells following the one containing Henry, we could use the `.nextAll()`
    method instead:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Listing 2.12
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the cells containing Henry are in the first column of the table, this
    code causes the rest of the cells in these rows to be highlighted:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_14.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: 'As we might expect, the `.next()` and `.nextAll()` methods have counterparts:
    `.prev()` and `.prevAll()`. Additionally, `.siblings()` selects all other elements
    at the same DOM level, regardless of whether they come before or after the previously
    selected element.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'To include the original cell (the one that contains Henry) along with the cells
    that follow, we can add the `.addBack()` method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Listing 2.13
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'With this modification in place, all of the cells in the row get their styles
    from the `highlight` class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5297_02_15.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'There are a multitude of selector and traversal-method combinations by which
    we can select the same set of elements. Here, for example, is another way to select
    every cell in each row where at least one of the cells contains Henry:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Listing 2.14
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Rather than traversing across to sibling elements, we travel up one level in
    the DOM to the `<tr>` tag with `.parent()` and then select all of the row's cells
    with `.children()`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Chaining
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traversal method combinations that we have just explored illustrate jQuery's
    chaining capability. With jQuery, it is possible to select multiple sets of elements
    and do multiple things with them, all within a single line of code. This chaining
    not only helps keep jQuery code concise, but it can also improve a script's performance
    when the alternative is to respecify a selector.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: How chaining works
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Almost all jQuery methods return a jQuery object and so can have more jQuery
    methods applied to the result. We will explore the inner workings of chaining
    in [Chapter 8](091dd3f4-9663-47df-af02-817487c3038f.xhtml), *Developing Plugins*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to break a single line of code into multiple lines for
    greater readability, as we''ve been doing throughout this chapter so far. For
    example, a single chained sequence of methods could be written in one line:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Listing 2.15
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'This same sequence of methods could also be written in seven lines:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Listing 2.16
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The DOM traversal in this example is contrived and not recommended. There are
    clearly simpler, more direct methods at our disposal. The point of the example
    is simply to demonstrate the tremendous flexibility that chaining affords us,
    especially when many calls need to be made.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Chaining can be like speaking a whole paragraph's worth of words in a single
    breath--it gets the job done quickly, but it can be hard for someone else to understand.
    Breaking it up into multiple lines and adding judicious comments can save more
    time in the long run.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over jQuery objects
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'New in jQuery 3 is the ability to iterate over jQuery objects using a `for...of`
    loop. This by itself isn''t a big deal. For one thing, it''s rare that we need
    to explicitly iterate over jQuery objects, especially when the same result is
    possible by using implicit iteration in jQuery functions. But sometimes, explicit
    iteration can''t be avoided. For example, imaging you need to reduce an array
    of elements (a jQuery object) to an array of string values. The `each()` function
    is a tool of choice here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Listing 2.17
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off with an array of `<td>` elements, the result of our `$(''td'')`
    selector. We then reduce it to an array of strings by passing the `each()` function
    a callback that pushes each string that starts with "H" onto the `eachText` array.
    There''s nothing wrong with this approach, but having callback functions for such
    a straightforward task seems like a bit much. Here''s the same functionality using
    `for...of` syntax:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Listing 2.18
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: We can now reduce jQuery objects using simple for loops and if statements. We'll
    revisit this `for...of` approach later on in the book for more advanced usage
    scenarios involving generators.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Accessing DOM elements
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every selector expression and most jQuery methods return a jQuery object. This
    is almost always what we want because of the implicit iteration and chaining capabilities
    that it affords.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, there may be points in our code when we need to access a DOM element
    directly. For example, we may need to make a resulting set of elements available
    to another JavaScript library, or we might need to access an element''s tag name,
    which is available as a property of the DOM element. For these admittedly rare
    situations, jQuery provides the `.get()` method. To access the first DOM element
    referred to by a jQuery object, for example, we would use `.get(0)`. So, if we
    want to know the tag name of an element with an ID of `my-element`, we would write:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For even greater convenience, jQuery provides a shorthand for `.get()`. Instead
    of writing the previous line, we can use square brackets immediately following
    the selector:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It's no accident that this syntax appears to treat the jQuery object as an array
    of DOM elements; using the square brackets is like peeling away the jQuery layer
    to get at the node list, and including the index (in this case, `0`) is like plucking
    out the DOM element itself.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the techniques that we covered in this chapter, we should now be able to
    locate sets of elements on the page in a variety of ways. In particular, we learned
    how to style top-level and sub-level items in a nested list using basic CSS selectors,
    how to apply different styles to different types of links using attribute selectors,
    add rudimentary striping to a table using either the custom jQuery selectors `:odd`
    and `:even` or the advanced CSS selector `:nth-child()`, and highlight text within
    certain table cells by chaining jQuery methods.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have been using the `$(() => {})` document ready handler to add a
    class to a matched set of elements. In the next chapter, we'll explore ways in
    which to add a class in response to a variety of user-initiated events.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic of selectors and traversal methods will be explored in more detail
    in [Chapter 9](27c55a6c-368a-4007-9e8c-1f9d9be254f8.xhtml), *Advanced Selectors
    and Traversing*. A complete list of jQuery's selectors and traversal methods is
    available in Appendix B of this book and in the official jQuery documentation
    at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Challenge exercises may require the use of the official jQuery documentation
    at [http://api.jquery.com/](http://api.jquery.com/):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Add a class of `special` to all of the `<li>` elements at the second level of
    the nested list.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a class of `year` to all the table cells in the third column of a table.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the class `special` to the first table row that has the word Tragedy in
    it.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here's a challenge for you. Select all the list items (`<li>s`) containing a
    link (`<a>`). Add the class `afterlink` to the sibling list items that follow
    the ones selected.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一个挑战给你。选择所有包含链接（`<a>`）的列表项（`<li>`）。给所选项后面的兄弟列表项添加类`afterlink`。
- en: Here's another challenge for you. Add the class `tragedy` to the closest ancestor
    `<ul>` of any `.pdf` link.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有另一个挑战给你。给任何`.pdf`链接最近的祖先`<ul>`添加类`tragedy`。
