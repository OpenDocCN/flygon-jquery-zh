- en: Chapter 7. Asynchronous Control Flow Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to development patterns that are used to ease the
    programming of asynchronous and concurrent procedures.
  prefs: []
  type: TYPE_NORMAL
- en: At first, we will have a refresher on how Callbacks are used in JavaScript programming
    and how they are an integral part of web development. We will then proceed and
    identify their benefits and limitations when used in large and complex implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Right after this, we will be introduced to the concept of Promises. We will
    learn how jQuery's Deferred and Promise APIs work and how they differ from ES6
    Promises. We will see where and how they are used internally by jQuery to simplify
    its implementation and lead to more readable code. We will analyze their benefits,
    classify the best matching use cases, and compare them with the classic Callback
    Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will be able to use jQuery Deferred and Promises
    to efficiently orchestrate the execution of asynchronous procedures that run either
    in order or parallel to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a refresher on how Callbacks are used in JavaScript programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get introduced to the concept of Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use jQuery's Deferred and Promise APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare jQuery Promises with ES6 Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to orchestrate asynchronous tasks using Promises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming with callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Callback can be defined as a function that is passed as an invocation argument
    to another function or method (which is referred to as a Higher-Order Function)
    and is expected to be executed at some later point of time. In this way, the piece
    of code that was handed our Callback will eventually invoke it, propagating the
    results of an operation or event back to the context that the Callback was defined.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks can be characterized as synchronous or asynchronous, based on the
    way that the invoked method operates. A Callback is characterized as synchronous
    when it is executed by a blocking method. On the other hand, JavaScript developers
    are more familiar with **asynchronous callbacks**, also called **deferred callbacks**,
    which are set to be executed after an asynchronous procedure finishes or when
    a specific event occurs (page load, click, AJAX response arrival, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '![Programming with callbacks](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Callbacks are widely used in JavaScript applications since they are an integral
    part of many core JavaScript APIs such as AJAX. Moreover, JavaScript implementations
    of this pattern are almost word for word as described by the above simple definition.
    This is a result of the way that JavaScript treats functions as objects and allows
    us to store and pass method references as simple variables.
  prefs: []
  type: TYPE_NORMAL
- en: Using simple callbacks in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps one of the simplest examples of asynchronous callbacks in JavaScript
    is the `setTimeout()` function. The following code demonstrates a simple use of
    it, where we invoke `setTimeout()` with the `doLater()` function as a callback
    parameter and, after 1000 milliseconds of waiting, the `doLater()` callback is
    invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As seen in the simple preceding example, the callback is executed in the context
    that it was defined. The callback still has access to the variables of the context
    that it was defined by creating a closure. Even though the preceding example uses
    a named function defined earlier, the same applies for anonymous callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In many cases, using anonymous callbacks is a more convenient way of programming,
    since it results in shorter code and also reduces the readability noise, which
    is a result of defining several different named functions that are used only once.
  prefs: []
  type: TYPE_NORMAL
- en: Setting callbacks as object properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A small variation of the above definition also exists, where the callback function
    is assigned to a property of an object instead of being passed as an argument
    of a method invocation. This is commonly used in cases where there are several
    different actions that need to take place during or after a method invocation
    is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another use case of the above variant is to add handlers on objects that have
    already been instantiated and initialized. A good example of this case is the
    way we set up a result handler for simple (non-jQuery) AJAX calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we set an anonymous function on the `onreadystatechange`
    property of the XMLHttpRequest object. This function acts as a callback and is
    invoked every time there is a state change on the ongoing request. Inside our
    callback, we check whether the request has completed with a successful HTTP status
    code and display an alert with the response body. Like in this example, where
    we initiate the AJAX call by invoking the `send()` method without passing any
    arguments, it is common for APIs that use this variant to lead to minimal ways
    of invoking their methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using callbacks in jQuery applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most common way in which callbacks are used in jQuery applications
    is for event handling. This is logical since the first thing that every interactive
    application should do is handle and respond to user actions. As we saw in earlier
    chapters, one of the most convenient ways to attach event handlers to elements
    is by using jQuery's `$.fn.on()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Another common place where callbacks are used in jQuery is for AJAX requests,
    where the `$.ajax()` method has the central role. Moreover, the jQuery library
    also provides several other convenient methods to make AJAX requests that are
    focused on the most common use cases. Since all these methods are executed asynchronously,
    they also accept a callback as a parameter, as a way to make the retrieved data
    available back to the context that initiated the AJAX request. One of these convenient
    methods is `$.getJSON()`, which is a wrapper around `$.ajax()`, and is used as
    a better matching API to execute AJAX requests that intend to retrieve JSON responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other widely used jQuery APIs accepting callbacks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The effects-related jQuery methods such as `$.animate()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$(document).ready()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now continue by demonstrating a code example where all the above methods
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code firstly delays its execution until the DOM tree of the page
    has been fully loaded and then adds an Observer for clicks on the `<button>` with
    ID `fetchButton` by using the jQuery''s `$.fn.on()` method. Whenever the click
    event is fired, the provided callback will be invoked and initiate an AJAX call
    to fetch the `AjaxContent.json` file. For the needs of this example, we are using
    a simple JSON file, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When the response is received and the JSON is parsed successfully, the callback
    is invoked with the parsed object as a parameter. Finally, the callback itself
    locates the page element with the ID `newContent` in the page, hides it, and then
    sets the data field of the retrieved JSON as its text content. Right after this,
    we use the jQuery `$.fn.slideDown()` method that makes the newly set page content
    appear, by progressively increasing its height. Finally, after the animation is
    complete, we write a log message to the browser console.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Further documentation regarding jQuery's `$.ajax()`, `$.getJSON()`, and `$.fn.slideDown()`
    methods can be found at [http://api.jquery.com/jQuery.ajax/](http://api.jquery.com/jQuery.ajax/),
    [http://api.jquery.com/jQuery.getJSON/](http://api.jquery.com/jQuery.getJSON/),
    and [http://api.jquery.com/slideDown/](http://api.jquery.com/slideDown/).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the `$.getJSON()` method might not work in some browsers when
    the page is loaded through the filesystem, but works as intended when served using
    any web server such as Apache, IIS, or nginx.
  prefs: []
  type: TYPE_NORMAL
- en: Writing methods that accept callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing a function that utilizes one or more asynchronous APIs, that also
    dictates that the resulting function will be asynchronous by definition. In that
    case, it is obvious that simply returning a result value is not an option, since
    the result will probably be available after the function invocation has already
    finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest solution for asynchronous implementations is to use a callback
    as a parameter of your function, which, as we discussed earlier, is hassle-free
    in JavaScript. As an example, we will create an asynchronous function that generates
    a random number of a specified range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getRandomNumberAsync()` function accepts its `max` argument as the numeric
    upper bound for the generated random number and also a callback function that
    it will invoke with the generated result. It uses `setTimeout()` to emulate an
    asynchronous calculation that ranges from 1000 to 2000 milliseconds. For the generation
    of the result, it uses the `Math.random()` method, multiplying it with the maximum
    allowed value, and finally invokes the provided callback with it. A simple way
    to invoke this function will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the above example uses `setTimeout()` to emulate asynchronous processing,
    the implementation principles remain the same regardless of the asynchronous API(s)
    that is used. For example, we can rewrite the above function to retrieve its result
    through an AJAX call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation uses the `$.ajax()` method that is invoked with
    an object parameter, enclosing all the options of the request. Except for the
    URL for the request, the object also defines the expected `dataType` of the result
    and the `success` and `error` callbacks, which are wired with the respective parameters
    of our function.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the only extra concern that the preceding code has to resolve is how
    to handle errors inside the success callback so that the caller of the function
    can be notified in case something goes wrong during the creation of the result.
    For example, the AJAX request might return an empty object. Adding proper handling
    for such cases is left as an exercise for the reader, after reading the rest of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Australian National University (ANU) provides free, truly random, numbers
    to the public, through their REST Web Service. For more information, you can visit
    [http://qrng.anu.edu.au/API/api-demo.php](http://qrng.anu.edu.au/API/api-demo.php).
  prefs: []
  type: TYPE_NORMAL
- en: Orchestrating callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now continue by analyzing some patterns that are commonly used to control
    the execution flow when dealing with asynchronous methods that accept callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Queuing in order execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As our first example, we will create a function that demonstrates how we can
    queue the execution of several asynchronous tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding implementation, our function creates a queue of three random
    number generations. The first two random numbers are generated from our sample
    `setTimeout()` implementation and the third is retrieved from the aforementioned
    web service though an AJAX call. In this example, all the numbers are gathered
    in the `result` array, which is passed as an invocation parameter to the `callbackFn`
    after all the asynchronous tasks have completed.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding implementation is quite straightforward and just applies the simple
    principles of the Callback Pattern repeatedly. For every extra or queued asynchronous
    task, we just need to nest its invocation inside the callback of the task that
    it depends on. Keep in mind that, in different use cases, we might only care to
    return the result of the final task and have the results of the intermediate steps
    be propagated as arguments for each subsequent asynchronous call.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the Callback Hell anti-pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though writing code as shown in the above example is easy, when applied
    to large and complex implementations, it can lead to bad readability. The triangular
    shape that is created by the white-spaces in front of our code and the stacking
    of several `});` near its end, are the two signs that our code might lead to an
    anti-pattern known as **Callback Hell**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information, you can visit [http://callbackhell.com/](http://callbackhell.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'A way to avoid this anti-pattern is to unfold the nested callbacks, by creating
    separate named functions at the same level with the asynchronous task that they
    are used. After applying this simple tip to the above example, the resulting code
    looks a lot cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the resulting code surely does not remind us of the characteristics
    of the Callback Hell anti-pattern. On the other hand, it now needs more lines
    of code for its implementation, mostly used for the additional function declarations
    `function taskX () { }` that are now required.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A middle ground solution between the above two approaches is to organize the
    related parts of such asynchronous execution queues in small and manageable functions.
  prefs: []
  type: TYPE_NORMAL
- en: Running concurrently
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though JavaScript in web browsers is single-threaded, making independent
    asynchronous tasks run concurrently can make our applications work faster. As
    an example, we will rewrite the preceding implementation to fetch all three random
    numbers in parallel, which can make the result to be retrieved a lot faster than
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we defined the `gatherResult()` helper function, which
    returns an anonymous function that is used as a callback for our random number
    generators. The returned callback function uses the `resultPos` parameter as the
    index of the array where it will store the generated or retrieved random number.
    Additionally, it tracks how many times it has been invoked, as a way to know whether
    all three concurrent tasks have ended. Finally, right after the third and final
    invocation of the callback, the `callbackFn` function is invoked with the `results`
    array as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Another great application of this technique, other than AJAX calls, is to access
    data stored in **IndexedDB**. Retrieving many values from the database concurrently
    can lead to performance gains, since the data retrievals can execute in parallel
    without blocking each other.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on IndexedDB, you can visit [https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the concept of Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Promises, also known as Futures, are described by Computer Science as specialized
    objects that are used for synchronization of asynchronous, concurrent, or parallel
    procedures. They are also used as proxies to propagate the result of a task when
    its generation completes. This way, a Promise object is like a contract where
    an operation will eventually complete its execution, and anyone having a reference
    to this contract can declare their interest to be notified about the result.
  prefs: []
  type: TYPE_NORMAL
- en: Since they were introduced to JavaScript developers, as part of several libraries,
    they revolutionized the way we use asynchronous functions and compose them in
    implementation with complex synchronization schemes. This way, web developers
    can create more flexible, scalable, and readable implementations, making method
    invocations with callbacks look like a primitive pattern and effectively eliminating
    the Callback Hell situations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the concept of Promises](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: One of the key concepts of Promises is that asynchronous methods return an object
    that represents their eventual result. Every Promise has an internal state that
    initially starts as Pending. This internal state can change only once, from Pending
    to either Resolved or Rejected, by using one of the `resolve()` or `reject()`
    methods that every implementation provides. These methods can be invoked only
    to change the state of a Pending Promise; in most cases, they are intended to
    be used only by the original creator of the Promise object and not be available
    to its consumers. The `resolve()` method can be invoked with the result of the
    operation as a single parameter, while the `reject()` method is usually invoked
    with the `Error` that caused the Promise object to get Rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Another key concept of Promises is the existence of a `then()` method, giving
    them the characterization of the "thenable", as a general term to describe promises
    among all the different implementations. Every Promise object exposes a `then()`
    method that is used by a caller in order to provide the function(s) that will
    be invoked when the Promise is settled (Resolved or Rejected). The `then()` method
    can be invoked with two functions as parameters, where the first is invoked in
    case the Promise gets Resolved, while the second is invoked when it is Rejected.
    The first argument is commonly referred to as the `onFulfilled()` callback, while
    the second is referred to as the `onRejected()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the concept of Promises](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Every Promise preserves two internal list containing all the `onFulfilled()`
    and `onRejected()` callback functions that are passed as arguments to the `then()`
    method. The `then()` method can be invoked several times for each Promise, adding
    new entries to the appropriate internal list, as far as the respective parameter
    is actually a function. When a Promise eventually gets Resolved or Rejected, it
    iterates over the appropriate list of callbacks and invokes them in order. Moreover,
    from the point that a Promise gets settled and after, every further usage of the
    `then()` method has, as a result, the immediate invocation of the appropriate
    provided callback.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Based on its characteristics, a Promise can be likened to a Broker from the
    Publish/Subscribe Pattern to some degree. Their key differences include the facts
    that it can only be used for a single Publish and that the Subscribers get notified
    of the result even if they expressed their interest after the Publish took place.
  prefs: []
  type: TYPE_NORMAL
- en: Using Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said earlier, the concept of Promises revolutionized programming of asynchronous
    tasks in JavaScript and, for a long time, they were the new big thing that everyone
    was enthusiastic about. At that time, many specialized libraries appeared where
    each one provided an implementation of Promises with slight differences to each
    other. Moreover, Promise implementations became available as part of utility libraries
    such as jQuery and web frameworks such as AngularJS and EmberJS. At that time,
    the "CommonJS Promises/A" specification made its appearance as a reference point
    and was the first attempt to define how Promises should actually work across all
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the "CommonJS Promises/A" specification, you can visit
    [http://wiki.commonjs.org/wiki/Promises/A](http://wiki.commonjs.org/wiki/Promises/A).
  prefs: []
  type: TYPE_NORMAL
- en: Using the jQuery Promise API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Promise-based API first appeared in the jQuery library in v1.5, based on the
    "CommonJS Promises/A" design. This implementation introduced the additional concept
    of the Deferred object, which works like a **Promise Factory**. The Deferred objects
    expose a superset of the methods that Promises provide, where the additional methods
    can be used to do manipulations to the state of its internal Promise. Additionally,
    the Deferred object exposes a `promise()` method and returns the actual Promise
    object, which does not expose any way to manipulate its internal state and just
    exposes observation methods such as `then()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words:'
  prefs: []
  type: TYPE_NORMAL
- en: Only code that has a reference to a Deferred object can actually change the
    internal state of its Promise, by either resolving or rejecting it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any piece of code that has a reference to a Promise object can't change its
    state but just observe for its state to change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on jQuery's Deferred object, you can visit [http://api.jquery.com/jQuery.Deferred/](http://api.jquery.com/jQuery.Deferred/).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple example of jQuery''s Deferred object, let''s see how we can rewrite
    the `getRandomNumberAsync()` function that we saw earlier in this chapter, to
    use Promises instead of Callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our target is to make an asynchronous function that returns a Promise that is
    eventually resolved to the resulting random number. At first, a new Deferred object
    is created and then the respective Promise object is returned, by using the `promise()`
    method of the Deferred. When the asynchronous generation of the result is complete,
    our method uses the `resolve()` method of the Deferredobject to set the final
    state of the Promise that was returned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The caller of our function uses the `then()` method of the returned Promise,
    to attach a callback that will be invoked with the result as a parameter as soon
    as the Promise gets Resolved. Moreover, a second callback can also be passed in
    order to get notified in case the Promise gets Rejected. An important thing to
    notice is that, by following the above pattern where functions always return Promises
    and never the actual Deferred objects, we can be sure that only the creator of
    the Deferred object can change the state of the Promise.
  prefs: []
  type: TYPE_NORMAL
- en: Using Promises/A+
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After some time of hands-on experimentation with CommonJS Promises/A, the community
    identified some of their limitations and also recommended some ways to improve
    them. The result was the creation of the Promises/A+ specification, as a way to
    improve the existing specification and also as a second attempt to unify the various
    available implementations. The most important parts of the new specification focused
    on how chaining Promises should work, making them even more useful and convenient
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the Promises/A+ specification, you can visit [https://promisesaplus.com/](https://promisesaplus.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Promises/A+ specification was published as part of the 6th version
    of JavaScript, commonly referred as ES6, that was released as a standard on June,
    2015\. As a result, Promises/A+ started to be implemented natively in browsers,
    removing the need to use custom third-party libraries and pushing most of the
    existing libraries to upgrade their semantics. As of writing of this book, native
    Promises/A+ compliant implementations have been available in most modern browsers,
    except for IE11, making them available out-of-the-box to more than 65% of web
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the adoption of A+ Promises in browsers, you can visit
    [http://caniuse.com/#feat=promises](http://caniuse.com/#feat=promises).
  prefs: []
  type: TYPE_NORMAL
- en: 'A rewrite of the `getRandomNumberAsync()` function using the now natively implemented
    ES6 A+ Promises will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, ES6 / A+ Promises are created by using the Promise constructor
    function with the `new` keyword. The constructor is invoked with a function as
    a parameter, which makes a closure that has access to both the variables of the
    context that the Promise is created, but also gets access to the `resolve()` and
    `reject()` functions as parameters, which is the only way to change the state
    of the newly created Promise. After the `setTimeout()` function fires its callback,
    the `resolve()` function is invoked with the generated random number as a parameter,
    changing the state of the Promise object to Fulfilled. Finally, the caller of
    our function uses the `then()` method of the returned Promise in exactly the same
    way as we saw in the earlier implementation that was using jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing jQuery and A+ Promises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will now have an in-depth step-by-step analysis of the core concepts of the
    jQuery and A+ Promise APIs, by also doing a side-by-side code comparison of the
    two. This can be a great asset to have, since you will also be able to use it
    as a reference while the implementations of Promises are gradually adapting to
    the ES6 A+ specification.
  prefs: []
  type: TYPE_NORMAL
- en: The need to understand from the beginning how the two variants differ seems
    even greater, since the jQuery team has already announced that Version 3.0 of
    the library will have Promises/A+ compliant implementation. Specifically, as of
    writing this book, the first beta version is already out, making the time that
    the migration will happen to appear even closer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on jQuery v3.0 A+ Promises implementation, you can visit
    [http://blog.jquery.com/2016/01/14/jquery-3-0-beta-released/](http://blog.jquery.com/2016/01/14/jquery-3-0-beta-released/).
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most obvious differences between the two implementations is the
    way that new Promises are created. As we saw, jQuery uses the `$.Deferred()` function
    like a factory of a more complex object that provides direct access to the state
    of the Promise and eventually extracts the actual Promise using a separate method.
    On the other hand, A+ Promises use the `new` keyword and a function as a parameter,
    which will be invoked by the runtime with the `resolve()` and `reject()` functions
    as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, jQuery also provides another way to create Promises that look more
    like the way that A+ Promises work. In this case, `$.Deferred()` can be invoked
    with a function as an argument that receives the Deferred object as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed earlier, the second possible outcome of a Promise is to be Rejected,
    a feature that nicely pairs with the classical exceptions of JavaScript in synchronous
    programming. Rejecting a Promise is commonly used for cases where an error occurs
    during the processing of the result, or in situations where the result is not
    valid. While ES6 Promises provide a `reject()` function as an argument to the
    function passed to its constructor, in jQuery's implementation a `reject()` method
    is simply exposed on the Deferred object itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In both the implementations, the result of a Promise can be retrieved using
    the `then()` method, which can be invoked with two functions as arguments, one
    to handle the case that the Promise gets Fulfilled and one for the case where
    it is Rejected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Both implementations also provide convenient methods to handle the case where
    the Promise gets Rejected, but with different method names. Instead of using `p.then(null,
    fn)`, ES6 Promises provide the `catch()` method that nicely pairs with the try...catch
    JavaScript expression, while jQuery''s implementation provides, for the same purpose,
    the `fail()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, as a jQuery exclusive feature, jQuery Promises also expose a `done()`
    and an `always()` method. The callbacks provided to `done()` are invoked when
    the Promise gets Fulfilled and is equivalent to using the `then()` method with
    a single parameter, while the callbacks of the `always()` method are invoked when
    the promise gets settled in both possible outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on `done()` and `always()`, you can visit [http://api.jquery.com/deferred.done](http://api.jquery.com/deferred.done)
    and [http://api.jquery.com/deferred.always](http://api.jquery.com/deferred.always).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, both implementations provide an easy way to directly create Promises
    that are already Resolved or Rejected. This can be useful as a starting value
    to implement complex synchronization schemes or as an easy way to make synchronous
    functions to operate like asynchronous ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Advanced concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another key concept of Promises that makes them unique and greatly increases
    their usefulness is the ability to easily create compositions of several Promises
    that in turn are Promises themselves. Composition is available in two forms, serial
    composition that chains Promises together and parallel composition that uses special
    methods to join the resolution of concurrent Promises into a new one. As we saw
    earlier in this chapter, implementing such synchronization schemes can be hard
    to implement with the traditional callback approach. Promises, on the other hand,
    try to solve this problem in a more convenient and readable way.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every invocation of the `then()` method returns a new Promise, whose both final
    status and result depends on the Promise that the `then()` method was called on,
    but is also subject to the value returned by the attached callbacks. This allows
    us to chain calls of the `then()` method, enabling us to compose Promises by serially
    joining them. This way, we can easily orchestrate both asynchronous and synchronous
    code, where each chaining step propagates its result to the next one and allows
    us to construct the final result in a readable and declarative way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now proceed to analyzing all the different ways that chaining of calls
    to the `then()` method works. Since we will be focusing on the concepts of Promise
    composition by chaining, which works the same as jQuery and ES6 Promises, let''s
    suppose that there is a `p` variable that is holding a Promise object created
    by either of the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest use case that demonstrates the power of chaining is when the invoked
    callback returns a (non-promise) value. The newly created Promise uses the returned
    value as its result, while preserving the same state as the Promise that the `then()`
    method was called on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A special case to have in mind is that functions that do not return anything
    as a result are handled like returning `undefined`. This essentially removes the
    result value from the newly returned Promise, which now only preserves the parent
    settlement status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case where the invoked callback returns another Promise, its state and
    result are used for the Promise returned by the `then()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code samples demonstrate the implementations for both the jQuery
    and A+ Promises, and both have equivalent results. In both cases, **7** is logged
    into the console from the first `then()` method invocation and a new Promise is
    then returned that will be Resolved at a later time using `setTimeout()`. After
    2000 milliseconds, that `setTimeout()` will fire its callback, the returned Promise
    will be Resolved with `21` as a value and, at that point, `21` will also be logged
    into the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'One extra thing to note is the case where the original Promise gets settled
    and there is no appropriate callback provided to the chained `then()` method.
    In this case, the newly created Promise settles to the same state and result,
    as the Promise where the `then()` method was called on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the callback with the `console.error` statement that
    is passed as the second argument of the `then()` method, does not get invoked
    since the Promise is resolved with 7 as its value. As a result, the callback of
    the chain eventually receives a new Promise, which is also resolved with `7` as
    its value and logs that in the console. Something to have in mind in order to
    deeply understand how chaining of Promises works, is that `p != p.then()` in all
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Handling thrown errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final concept of chaining defines the case where exceptions are thrown during
    the invocation of a `then()` callback. The Promise/A+ specification defined that
    the newly created Promise is Rejected and that its result is the `Error` that
    was thrown. Moreover, the Rejection will bubble through the entire chain of Promises,
    enabling us to be notified about any error in the chain only defining the error
    handling once, near to the end of the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this is not consistent in the implementation of the latest stable
    version of jQuery, which as of the writing of this book is v2.2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, the exception that is thrown stops the execution of the Promise
    chain. The only way around it is probably explicitly adding a try...catch statement
    inside the callback that is passed to the `then()` method, as shown in the second
    case that is demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: Joining Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other way of orchestrating Promises that run concurrently is by composing
    them together. As an example, let''s suppose the existence of two Promises, p1
    and p2, that get resolved with 7 and 11 as their values, after 2000 and 3000 milliseconds,
    respectively. Since these two Promises are executed concurrently, the composed
    Promise will only need 3000 milliseconds to get Resolved, as it is the greater
    of the two durations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Both Promise APIs provide a specialized function that allows us to easily create
    Promise compositions and also retrieve the individual results of the composition.
    A composed Promise gets Resolved when all its parts get Resolved, while it gets
    Rejected when any one of its parts gets Rejected. Unfortunately, the two Promise
    APIs differ, not only by the name of the functions, but also by the way they are
    invoked and the way they provide their results.
  prefs: []
  type: TYPE_NORMAL
- en: The jQuery implementation provides the `$.when()` method that can be invoked
    with any number of arguments that we want to be composed. By using the `then()`
    method on a composed jQuery Promise, we can get notified when the composition
    gets settled as a whole and also access each individual result as arguments of
    our callback.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the A+ Promises specification provides us the `Promise.all()`
    method that is invoked with an array as its single parameter that contains all
    the Promises that we want to get composed. The returned composed Promise does
    not differ at all from the Promises that we have seen so far and the callback
    of the `then()` method is invoked with an array as its parameter, which contains
    all the results of the Promises that are part of the composition.
  prefs: []
  type: TYPE_NORMAL
- en: How jQuery uses Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time that jQuery added an implementation of Promises to its API, it also
    started to expose it through other asynchronous methods of its API. Perhaps the
    most well-known example of this kind is the method of the `$.ajax()` family that
    returns a jqXHR object, which is a specialized Promise object that also provides
    some extra methods related to the AJAX request.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the jQuery's `$.ajax()` method and the jqXHR object,
    you can visit [http://api.jquery.com/jQuery.ajax/#jqXHR](http://api.jquery.com/jQuery.ajax/#jqXHR).
    The jQuery team also decided to change the implementation of several internal
    parts of the library to use Promises, in order to improve their implementations.
    First of all, the `$.ready()` method is implemented using Promises so that the
    provided callbacks fire even if the page has already been loaded a long time before
    its invocation. Also, some of the complex animations that jQuery provides use
    Promises internally as the preferred way to synchronize the execution of the sequential
    parts of the animation queue.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming Promises to other types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developing by using several different JavaScript libraries often makes many
    Promise implementations available to our projects that unfortunately tend to have
    different levels of compliance to the reference Promises specification. Composing
    Promises returned by the methods of different libraries can often lead to problems
    that are hard to track and resolve, as a result of their implementation inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid confusions in such situations, it isn't considered a good
    practice to transform all the Promises to a single type before attempting to compose
    them. The suggested type for such situations is the Promises/A+ specification,
    since not only is it widely accepted by the community but it is also part of the
    newly released version of JavaScript (the ES6 language specification) that is
    already natively implemented in many browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming to Promises/A+
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For example, let''s see how a jQuery Promise can be transformed to an A+ Promise
    that is available in most recent browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `Promise.resolve()` method detects that it has
    been invoked with a "thenable" and that the newly created A+ Promise that is returned
    binds its status and result to those of the provided jQuery Promise. This is essentially
    equivalent to doing something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this is not limited to Promises that are created by direct invocations
    of the `$.Deferred()` method. The above technique can also be used to transform
    Promises that are returned by any jQuery method. For example, this is how it can
    be used with the `$.getJSON()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Transforming to jQuery Promises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even though I would generally not recommend this, it is also possible to transform
    any Promise to a jQuery variant. The newly created jQuery Promise receives all
    the extra functionalities that jQuery provides, but the transformation is not
    as straightforward as the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You should only use the preceding technique in cases where you need to extend
    a big web application that is already implemented using jQuery Promises. On the
    other hand, you should also consider upgrading such implementations, since the
    jQuery team has already announced that Version 3.0 of the library will have Promises/A+
    compliant implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on jQuery v3.0 A+ Promises implementation, you can visit
    [http://blog.jquery.com/2016/01/14/jquery-3-0-beta-released/](http://blog.jquery.com/2016/01/14/jquery-3-0-beta-released/).
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing the benefits of Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Overall, the benefits of using Promises over plain Callbacks include:'
  prefs: []
  type: TYPE_NORMAL
- en: Having a unified way to handle the result of asynchronous invocations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having predictable invocation parameters for the used callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to attach multiple handlers for each outcome of the Promise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The guarantee that the appropriate attached handlers will execute even if the
    Promise has already been Resolved (or Rejected)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to chain asynchronous operations, making them run in order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to easily create compositions of asynchronous operations, making
    them run concurrently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The convenient way of handling errors in Promise chains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a method that returns a Promise removes the need to directly pass functions
    of one context to another as an invocation argument and the question regarding
    which parameters are used as the success and the error Callbacks. Moreover, we
    already know to some degree how to retrieve the result of any operation that returns
    a Promise, by using the `then()` method, even before reading the documentation
    about the method's invocation parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Less parameters often means less complexity, smaller documentation, and less
    searching every time we want to do a method invocation. Even better, there is
    a good chance that there will only be a single or a few parameters, making the
    invocation more sensible and readable. The implementation of asynchronous methods
    also becomes less complex, since there is no longer the need to accept callback
    functions as an extra argument or having to properly invoke them with the result.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed the development patterns that are used to program
    asynchronous and concurrent procedures. We also learned how to use them to efficiently
    orchestrate the execution of asynchronous procedures that run either in order
    or parallel to each other.
  prefs: []
  type: TYPE_NORMAL
- en: At first, we had a refresher on how Callbacks are used in JavaScript programming
    and how they are an integral part of web development. We analyzed their benefits
    and limitations when used in large and complex implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Right after this, we were introduced to the concepts of Promises. We learned
    how jQuery's Deferred and Promise APIs work and how they differ from ES6 Promises.
    We also saw where and how they are used internally by jQuery itself, as an example
    of how they can lead to more readable code and simplify such complex implementations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will proceed to learning how to design, create, and
    use MockObjects and Mock Services in our applications. We will analyze the characteristics
    that a proper Mock Object should have and understand how they can be used as representative
    use cases and even as test cases for our code.
  prefs: []
  type: TYPE_NORMAL
